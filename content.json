[{"title":"Lantern专业版邀请码 2CR4W2","date":"2027-01-14T17:08:07.000Z","path":"2027/01/15/Lantern专业版邀请码/","text":"输入我的邀请码 2CR4W2 来获得三个月的蓝灯专业版！立即下载 https://github.com/getlantern/forum自从Lantern更新了之后，现在在Youtube上看1080P的视频都很流畅，如果大家喜欢用Lantern的话，可以试试。","tags":[{"name":"Lantern","slug":"Lantern","permalink":"https://github.com/itgoyo/tags/Lantern/"}]},{"title":"mac如何搭建Hexo博客","date":"2019-10-06T17:11:35.000Z","path":"2019/10/07/mac如何搭建Hexo博客/","text":"1、Hexo搭建 ####环境一、环境安装 node.js（在node.js官网中下载安装）node.js官网 git（OS系统中直接安装x-code就可以了） hexo 1）打开OS系统终端 2）输入安装hexo的代码(此处安装时有可能会提示输入系统管理员密码) $ sudo npm install -g hexo二、hexo创建静态博客 新建blog文件夹 在终端进入该文件夹，初始化博客 $ hexo init 上述完成后，生成原始文件；blog文件夹就是博客的根目录 本地查看：启用本地服务命令(退出按ctrl+c) $ hexo s 将出现的地址输入浏览器，即可可查看到本地效果 三、github配置 注册github账号并登陆 获取本机的SSH口令 1）输入获取代码，回车直到出现图片所示图形为止 $ ssh-keygen 2）输入编译代码 $ vim ~/.ssh/id_rsa.pub3）出现SSH口令后，将红框部分复制，并在下方输入:q，随后按下回车可以退出该窗口 4）进入到github页面设置SSH口令 点击用户下拉菜单中的settings（step1) 点击左侧的SHH and GPG keys（step2) 在Title中输入口令名称（随意）（step3) 在key中贴上SSH口令（step4) 创建新的仓库 1）创建新的仓库（repOSitory） 点击用户左侧的+号菜单中的New repOSitory（step1) 在repOSitory name中输入二级域名，格式请严格遵照username.github.io（step2) ps：username填写github的登录用户名，否则上线的时候会报错 是否公开选项可以选取Public（step3) 勾选step4处，会自动生成一份可编辑的README.md文件（建议勾选）（step4) 点击create repOSitory生成仓库完毕（step5) 2）查看新建的仓库（repOSitory） 可以回到github个人首页点击右侧的仓库区 进入后在step1处选择并复制http地址，注意此时step2处应该是空的 四、发布博客 设置blog配置文件 1）打开blog文件夹下的_config.yml文件 2）找到最下方的type，输入git（注意冒号后面是带空格的） 3）repo行可能没有，需要自己输入，后面跟上github上仓库中复制的http地址（注意此时1、2两处应该是一样的username），不然上传时会报错 4）其他博客设置 title：博客名称 subtitle：博客副标题 description：博客描述 author：作者 language：语言（简体中文是zh-CN） 在终端上传博客 1）进入终端，输入git上传插件安装代码（安装时会提示输入github用户名及密码） $ npm install hexo-deployer-git –save2）安装完毕后，输入获取代码 $ hexo g3）最后输入上传代码 $ hexo d4）重新在github仓库查看上传文件，此时在step2中会有之前bolg中生成的文件 5）step3处就是你的博客地址 五、新建与更新博客 新建博客 1）终端bolg文件下，输入新建博客代码 $ hexo new &apos;filename&apos; 2）此时在bolg/source/_posts/下面会看到新建的博客 3）博客文件的后缀是.md文件，OS下推荐使用MOU编辑器mou下载地址 更新博客 1）完成编辑后，在终端上依次重复以下代码（此时必须先将编辑器关闭，否则会出现获取错误） $ hexo g $ hexo d 2）完成后便能刷新博客网页看到新更新的内容了","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/itgoyo/tags/Hexo/"}]},{"title":"Hexo加入评论功能","date":"2017-01-15T04:44:20.000Z","path":"2017/01/15/Hexo加入评论功能/","text":"Yilia主题（别的主题也是一样的操作）首先，我们要有一个多说的账号多说 然后进入到后台把我们的网站填写进去 最后在theme/yilia/_config.yml 里边添加一下代码（名字换成自己的） 12duoshuo: trueshort_name: itgoyo #名字换你自己在多说后台的名字 然后重新提交代码刷新即可看到评论功能","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/itgoyo/tags/Hexo/"}]},{"title":"Hexo加入百度统计","date":"2017-01-15T04:07:01.000Z","path":"2017/01/15/Hexo加入百度统计/","text":"###litten的主题yilia编辑文件 themes/yilia/_config.yml ,添加一行配置，可以删除原来的google analytics 1baidu_tongji: true 新建 themes/yilia/layout/_partial/baidu_tongji.ejs 内容如下 12345&lt;% if (theme.baidu_tongji) &#123; %&gt;&lt;script type=\"text/javascript\"&gt;#申请的百度统计代码&lt;/script&gt;&lt;% &#125; %&gt; 编辑themes/yilia/layout/_partial/head.ejs 在 前添加 1&lt;%- partial(\"baidu_tongji\") %&gt; 重新生产部署站点即可。Light主题编辑文件 themes/light/_config.yml ,添加一行配置，可以删除原来的google analytics 1baidu_tongji: true` 新建 themes/light/layout/_partial/baidu_analytics.ejs 内容如下 12345&lt;% if (theme.baidu_tongji) &#123; %&gt;&lt;script type=\"text/javascript\"&gt;#申请的百度统计代码&lt;/script&gt;&lt;% &#125; %&gt; 编辑themes/light/layout/_partial/head.ejs 在 前添加 1&lt;%- partial(\"baidu_tongji\") %&gt;` 重新生产部署站点即可。 邮箱 ：itgoyo@gamail.com Good Luck!","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/itgoyo/tags/Hexo/"}]},{"title":"怎么在Hexo搭建GithubPage中加入网易云音乐","date":"2017-01-10T12:45:40.000Z","path":"2017/01/10/怎么在Hexo搭建GithubPage中加入网易云音乐/","text":"Yilia主题（我使用的是这个主题就用这个来讲）进入网易云音乐: 官网 推荐：自己注册账号，这样子可以创建自己喜欢的歌单，在里边收藏自己喜欢的歌曲 然后进入到自己的歌单 点击生成外链，获取到云音乐播放器代码 选择生成自己喜欢的样式，然后复制代码 最后打开（themes/yilia/layout/_partial/left-col.ejs）把复制好的网易云音乐放到第二行里边(当然这个是我的样式，我选择放在左边，你喜欢放在那里自己选择) 最后的效果图如下 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/itgoyo/tags/Hexo/"}]},{"title":"","date":"2017-01-10T12:34:31.000Z","path":"2017/01/10/windows10 使用Markdown Pad2不能预览/","text":"windows10 使用Markdown Pad2不能预览标签（空格分隔）： Markdown 电脑升级到了Win10之后，在使用Warkdown写文章的时候右边的不能正确预览 官方的说法是从 Win 8 开始就有这个问题了，解决办法就是安装 Awesomium 1.6.6 SDK.，如果还是不行就再安装 Microsoft’s DirectX End-User Runtimes (June 2010)，经我实际测试，只需要安装前者就可以了。下面是官方的原文： LivePreview is not working - it displays an error message stating This view has crashed!This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane. To fix this issue, please try installing the Awesomium 1.6.6 SDK. If you continue to experience issues, please install Microsoft’s DirectX End-User Runtimes (June 2010). Referer:MarkdownPad - Frequently Asked Questions 完成之后效果如下： 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[]},{"title":"深入了解Java接口和抽象类","date":"2016-12-31T17:11:00.000Z","path":"2017/01/01/深入了解java接口和抽象类/","text":"一、抽象类 在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为： abstract void fun(); 抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 下面要注意一个问题：在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。个人觉得这个属于钻牛角尖的问题吧，因为如果一个抽象类不包含任何抽象方法，为何还要设计为抽象类？所以暂且记住这个概念吧，不必去深究为什么。 [public] abstract class ClassName { abstract void fun(); } 从这里可以看出，抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。 包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别： 1.抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。 2.抽象类不能用来创建对象； 3.如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。 在其他方面，抽象类和普通的类并没有区别。 二、接口 接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。在Java中，定一个接口的形式如下： [public] interface InterfaceName { // } 接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 要让一个类遵循某组特地的接口需要使用implements关键字，具体格式如下： class ClassName implements Interface1,Interface2,[....]{ } 可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。 ##三、抽象类和接口的区别1.语法层面上的区别 1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的； 3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。 2.设计层面上的区别 1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念： abstract class Door { public abstract void open(); public abstract void close(); } 或者： interface Door { public abstract void open(); public abstract void close(); } 但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路： 1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能； 2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。 从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。 1234567891011121314151617181920interface Alram &#123; void alarm();&#125; abstract class Door &#123; void open(); void close();&#125; class AlarmDoor extends Door implements Alarm &#123; void oepn() &#123; //.... &#125; void close() &#123; //.... &#125; void alarm() &#123; //.... &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/itgoyo/tags/Java/"}]},{"title":"RxJava详解(下)","date":"2014-12-31T17:11:03.000Z","path":"2015/01/01/RxJava详解(下)/","text":"RxJava详解(下)变换的原理lift()这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在RxJava的内部，它们是基于同一个基础的变换方法：lift()。 首先看一下lift() 的内部实现（仅核心代码）： 1234567891011// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) &#123; return Observable.create(new OnSubscribe&lt;R&gt;() &#123; @Override public void call(Subscriber subscriber) &#123; Subscriber newSubscriber = operator.call(subscriber); newSubscriber.onStart(); onSubscribe.call(newSubscriber); &#125; &#125;);&#125; 这段代码很有意思：它生成了一个新的Observable并返回，而且创建新Observable所用的参数OnSubscribe的回调方法call()中的实现竟然看起来和前面讲过的Observable.subscribe()一样！然而它们并不一样哟~不一样的地方关键就在于第二行onSubscribe.call(subscriber)中的onSubscribe` 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适） subscribe()中这句话的onSubscribe指的是Observable中的onSubscribe对象，这个没有问题，但是lift()之后的情况就复杂了点。 当含有lift()时： lift()创建了一个Observable后，加上之前的原始Observable，已经有两个Observable了； 而同样地，新Observable里的新OnSubscribe加上之前的原始Observable中的原始OnSubscribe，也就有了两个OnSubscribe； 当用户调用经过lift()后的Observable的subscribe()的时候，使用的是lift()所返回的新的Observable，于是它所触发的onSubscribe.call(subscriber)，也是用的新Observable中的新OnSubscribe，即在lift()中生成的那个OnSubscribe； 而这个新OnSubscribe的call()方法中的onSubscribe，就是指的原始Observable中的原始OnSubscribe，在这个call()方法里，新OnSubscribe利用operator.call(subscriber)生成了一个新的Subscriber(Operator就是在这里，通过自己的call()方法将新Subscriber和原始Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新Subscriber向原始Observable进行订阅。这样就实现了lift()过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。 精简掉细节的话，也可以这么说：在Observable执行了lift(Operator)方法之后，会返回一个新的Observable，这个新的Observable会像一个代理一样，负责接收原始的Observable 发出的事件，并在处理后发送给Subscriber。 如果你更喜欢具象思维，可以看图： 举一个具体的Operator的实现。下面这是一个将事件中的Integer对象转换成String的例子，仅供参考： 12345678910111213141516171819202122observable.lift(new Observable.Operator&lt;String, Integer&gt;() &#123; @Override public Subscriber&lt;? super Integer&gt; call(final Subscriber&lt;? super String&gt; subscriber) &#123; // 将事件序列中的 Integer 对象转换为 String 对象 return new Subscriber&lt;Integer&gt;() &#123; @Override public void onNext(Integer integer) &#123; subscriber.onNext(\"\" + integer); &#125; @Override public void onCompleted() &#123; subscriber.onCompleted(); &#125; @Override public void onError(Throwable e) &#123; subscriber.onError(e); &#125; &#125;; &#125;&#125;); 讲述lift()的原理只是为了让你更好地了解RxJava ，从而可以更好地使用它。然而不管你是否理解了lift()的原理,RxJava都不建议开发者自定义Operator来直接使用lift()，而是建议尽量使用已有的lift()包装方法（如map()、flatMap()等）进行组合来实现需求，因为直接使用lift()非常容易发生一些难以发现的错误。 线程控制Scheduler在不指定线程的情况下，RxJava遵循的是线程不变的原则，即在哪个线程调用subscribe()方法就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。也就是说事件的发出和消费都是在同一个线程的。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于RxJava是至关重要的。而要实现异步，则需要用到RxJava的另一个概念：Scheduler。 ####Scheduler简介 在RxJava中,Scheduler相当于线程控制器，RxJava通过它来指定每一段代码应该运行在什么样的线程。RxJava已经内置了几个Scheduler，它们已经适合大多数的使用场景： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的Scheduler。这个计算指的是CPU密集型计算，即不会被I/O等操作限制性能的操作，例如图形的计算。这个Scheduler 使用的固定的线程池，大小为CPU核数。不要把I/O操作放在computation()中，否则I/O操作的等待时间会浪费CPU。 另外，Android还有一个专用的AndroidSchedulers.mainThread()，它指定的操作将在Android主线程运行。 有了这几个Scheduler，就可以使用subscribeOn()和observeOn()两个方法来对线程进行控制了。subscribeOn()指定subscribe()所发生的线程，即Observable.OnSubscribe()被激活时所处的线程或者叫做事件产生的线程。observeOn()指定Subscriber所运行在的线程或者叫做事件消费的线程。 123456789Observable.just(\"Hello \", \"World !\") .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程，可以理解成数据的获取是在io线程 .observeOn(AndroidSchedulers.mainThread())// 指定 Subscriber 的回调发生在主线程，可以理解成数据的消费时在主线程 .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(\"@@@\", s); &#125; &#125;); 上面这段代码中，subscribeOn(Schedulers.io())的指定会让创建的事件的内容Hello、World !将会在IO线程发出；而由于observeOn(AndroidScheculers.mainThread()) 的指定，因此subscriber()方法设置后的回调中内容的打印将发生在主线程中。事实上，这种在subscribe()之前写上两句subscribeOn(Scheduler.io())和observeOn(AndroidSchedulers.mainThread())的使用方式非常常见，它适用于多数的后台线程取数据，主线程显示的程序策略。 ####Scheduler的原理 RxJava的Scheduler API很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 subscribe() 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。 好吧这一节其实我屁也没说，只是为了让你安心，让你知道我不是忘了讲原理，而是把它放在了更合适的地方。 能不能多切换几次线程？答案是：能。因为observeOn()指定的是Subscriber的线程，而这个Subscriber并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的Subscriber，而是observeOn()执行时的当前Observable所对应的Subscriber，即它的直接下级Subscriber。换句话说observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次observeOn()即可。 上代码： 12345678Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定 .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .map(mapOperator) // 新线程，由 observeOn() 指定 .observeOn(Schedulers.io()) .map(mapOperator2) // IO 线程，由 observeOn() 指定 .observeOn(AndroidSchedulers.mainThread) .subscribe(subscriber); // Android 主线程，由 observeOn() 指定 如上，通过observeOn()的多次调用，程序实现了线程的多次切换。不过，不同于observeOn(),subscribeOn()的位置放在哪里都可以，但它是只能调用一次的。 其实，subscribeOn()和observeOn()的内部实现，也是用的lift()。 具体看图（不同颜色的箭头表示不同的线程,subscribeOn()原理图： observeOn()原理图: 从图中可以看出,subscribeOn()和observeOn()都做了线程切换的工作（图中的schedule...部位）。不同的是,subscribeOn()的线程切换发生在OnSubscribe中，即在它通知上一级 OnSubscribe时，这时事件还没有开始发送，因此subscribeOn()的线程控制可以从事件发出的开端就造成影响；而observeOn()的线程切换则发生在它内建的Subscriber中，即发生在它即将给下一级Subscriber发送事件时，因此observeOn()控制的是它后面的线程。 最后，我用一张图来解释当多个subscribeOn()和observeOn()混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）： 图中共有5处含有对事件的操作。由图中可以看出，①和②两处受第一个subscribeOn()影响，运行在红色线程；③和④处受第一个observeOn()的影响，运行在绿色线程；⑤处受第二个 onserveOn()影响，运行在紫色线程；而第二个subscribeOn()，由于在通知过程中线程就被第一个subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个subscribeOn()的时候，只有第一个subscribeOn()起作用。 在前面讲Subscriber的时候，提到过Subscriber的onStart()可以用作流程开始前的初始化。然而onStart()由于在subscribe()发生时就被调用了，因此不能指定线程，而是只能执行在subscribe()被调用时的线程。这就导致如果onStart()中含有对线程有要求的代码（例如在界面上显示一个ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测subscribe()将会在什么线程执行。 而与Subscriber.onStart()相对应的，有一个方法Observable.doOnSubscribe()。它和Subscriber.onStart()同样是在subscribe()调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下,doOnSubscribe()执行在subscribe()发生的线程；而如果在doOnSubscribe()之后有subscribeOn()的话，它将执行在离它最近的subscribeOn()所指定的线程。 示例代码： 1234567891011Observable.create(onSubscribe) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行 &#125; &#125;) .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); 如上，在doOnSubscribe()的后面跟一个subscribeOn()，就能指定准备工作的线程了。 ####总结 RxJava辣么好，难道他就没有缺点吗？当然有那就是使用越来越多的订阅，内存开销也会变得很大，稍不留神就会出现内存溢出的情况。我们可以用RxJava实现基本任何功能，但是你并不能这么做，你要明白什么时候需要用它，而什么时候没必要用它，不要一味的把功能都有RxJava来实现。 至于上面提到的2.0版本，有关它的区别请见:What’s different in 2.0 Agera 之前Google发布agera，它在Github上的介绍是:Reactive Programming for Android agera 既然是响应式编程框架，其核心思想肯定和RxJava也是类似的。Agera中核心也是关于事件流（数据流）的处理，可以转换数据、可以指定数据操作函数在那个线程执行。而Agera和RxJava不一样的地方在于，Agera提供了一个新的事件响应和数据请求的模型，被称之为Push event, pull data。也就是一个事件发生了，会通过回调来主动告诉你，你关心的事件发生了。然后你需要主动的去获取数据，根据获取到的数据做一些操作。而RxJava在事件发生的时候，已经带有数据了。为了支持 Push event pull data模型，Agera中有个新的概念 — Repository。Repository翻译过来也就是数据仓库,是用来提供数据的,当你收到事件的时候,通过Repository来获取需要的数据。 这样做的好处是，把事件分发和数据处理的逻辑给分开了，事件分发做的事情比较少，事件分发就比较高效，当你收到事件后，根据当前的状态如果发现这个时候，数据已经无效了，则你根本不用请求数据，这样数据也就不用去处理和转换了。这样可以避免无用的数据计算，而有用的数据计算也可以在你需要的时候才去计算。同样，在多线程环境下，使用push event pull data模型，可能当你收到事件通知的时候，你只能获取到最新的数据，无法去获取历史数据了。设计就是这样考虑的，因为在Android开发中大部分的数据都是用来更新UI的，这个时候你根本不需要旧的数据了，只要最新的就够了。 Agera相对比较简单，并且是一个专业为Android平台打造的响应式编程框架。但是如果你熟悉了RxJava你会发现其用起来会有点不舒服，特别是还要主动的获取数据略感不爽（虽然提高了事件分发的效率）。 总之，现在看来RxJava支持的比较全面，但是会略显笨重，而Agera是一个专门为Android平台设计的响应式编程框架，比较轻巧，当然支持的并不是很全面。可以根据自己的喜好来选择. 但是从个人观点来看Agera比起来RxJava还是相差几个版本。当然这是我的片面之词，有关更多信息请看Question: what’s the relation to RxJava? 参考: RxJava Wiki Grokking RxJava, Part 1: The Basics NotRxJava When Not to Use RxJava 给 Android 开发者的 RxJava 详解 Google Agera 从入门到放弃 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"RxJava详解(中)","date":"2014-12-31T17:11:01.000Z","path":"2015/01/01/RxJava详解(中)/","text":"RxJava详解(中)说好的简洁呢？上面这一部分，又是介绍、又是Hello World、又是数据变换，但是你会发现然而并没有什么卵用。说好的简洁一点也木有体现出来。 下面我们会通过一个简单的例子来进行说明。现在我们有这样一个需求: 有一个服务提供了一些API来搜索整个网络上的符合查询关键字的所有猫的图片。 每个图片包含一个可爱程度的参数(一个整数值表示其可爱程度)。 我们的任务就是下载所有猫的列表并选择最可爱的那个，把它的图片保存到本地。 ####Model和API 下面是猫的数据结构Cat: 123456789public class Cat implements Comparable&lt;Cat&gt;&#123; Bitmap image; int cuteness; @Override public int compareTo(Cat another) &#123; return Integer.compare(cuteness, another.cuteness); &#125;&#125; 我们的API会调用cat-sdk.jar中堵塞式的接口。1234public interface Api &#123; List&lt;Cat&gt; queryCats(String query); Uri store(Cat cat);&#125; 看起来很清晰吧？当然了，我们继续写客户端的业务逻辑.123456789101112131415public class CatsHelper &#123; Api api; public Uri saveTheCutestCat(String query)&#123; List&lt;Cat&gt; cats = api.queryCats(query); Cat cutest = findCutest(cats); Uri savedUri = api.store(cutest); return savedUri; &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 通俗易懂、简单明了，非常酷的代码。主要的函数saveTheCutestCat()只包含了3个方法。使用这些方法然后等待方法执行完并接受返回值就可以了。 非常简单、有效。接下来我们看一下这种方式的其他优点。 ####组合 可以看到我们的saveTheCutestCat由其他三个函数调用所组成的。我们通过函数来把一个大功能分割为每个容易理解的小功能。通过函数调用来组合使用这些小功能。使用和理解起来都相当简单 ####异常传递 另外一个使用函数的好处就是方便处理异常。每个函数都可以通过抛出异常来结束运行。该异常可以在抛出异常的函数里面处理，也可以在调用该函数的外面处理，所以我们无需每次都处理每个异常，我们可以在一个地方处理所有可能抛出的异常。 123456789try&#123; List&lt;Cat&gt; cats = api.queryCats(query); Cat cutest = findCutest(cats); Uri savedUri = api.store(cutest); return savedUri;&#125; catch (Exception e) &#123; e.printStackTrace() return someDefaultValue;&#125; 这样，我们就可以处理这三个函数中所抛出的任何异常了。如果没有try catch语句，我们也可以把异常继续传递下去。 向异步粗发但是，现实世界中我们往往没法等待。有些时候你没法只使用阻塞调用。在Android中你需要处理各种异步操作。就那Android的OnClickListener接口来说吧，如果你需要处理一个View的点击事件，你必须提供一个该Listener 的实现来处理用户的点击事件。下面来看看如何处理异步调用。 ####异步网络调用 假设我们的cats-sdk.jar使用了异步调用的API来访问网络资源，这样我们的新API接口就变为这样了： 1234567891011public interface Api &#123; interface CatsQueryCallback &#123; void onCatListReceived(List&lt;Cat&gt; cats); void onError(Exception e); &#125; void queryCats(String query, CatsQueryCallback catsQueryCallback); Uri store(Cat cat);&#125; 这样我们查询猫的操作就变为异步的了， 通过CatsQueryCallback回调接口来结束查询的数据和处理异常情况。我们的业务逻辑也需要跟着改变一下： 1234567891011121314151617181920212223242526272829public class CatsHelper &#123; public interface CutestCatCallback &#123; void onCutestCatSaved(Uri uri); void onQueryFailed(Exception e); &#125; Api api; public void saveTheCutestCat(String query, CutestCatCallback cutestCatCallback)&#123; api.queryCats(query, new Api.CatsQueryCallback() &#123; @Override public void onCatListReceived(List&lt;Cat&gt; cats) &#123; Cat cutest = findCutest(cats); Uri savedUri = api.store(cutest); cutestCatCallback.onCutestCatSaved(savedUri); &#125; @Override public void onError(Exception e) &#123; cutestCatCallback.onQueryFailed(e); &#125; &#125;); &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 我们没法让saveTheCutestCat函数返回一个值了， 我们需要一个回调接口来异步的处理结果。这里我们再进一步，使用两个异步操作来实现我们的功能,例如我们需要使用异步IO来写文件。 12345678910111213141516public interface Api &#123; interface CatsQueryCallback &#123; void onCatListReceived(List&lt;Cat&gt; cats); void onQueryFailed(Exception e); &#125; interface StoreCallback&#123; void onCatStored(Uri uri); void onStoreFailed(Exception e); &#125; void queryCats(String query, CatsQueryCallback catsQueryCallback); void store(Cat cat, StoreCallback storeCallback);&#125; 我们的helper会变成: 1234567891011121314151617181920212223242526272829303132333435363738public class CatsHelper &#123; public interface CutestCatCallback &#123; void onCutestCatSaved(Uri uri); void onError(Exception e); &#125; Api api; public void saveTheCutestCat(String query, CutestCatCallback cutestCatCallback)&#123; api.queryCats(query, new Api.CatsQueryCallback() &#123; @Override public void onCatListReceived(List&lt;Cat&gt; cats) &#123; Cat cutest = findCutest(cats); api.store(cutest, new Api.StoreCallback() &#123; @Override public void onCatStored(Uri uri) &#123; cutestCatCallback.onCutestCatSaved(uri); &#125; @Override public void onStoreFailed(Exception e) &#123; cutestCatCallback.onError(e); &#125; &#125;); &#125; @Override public void onQueryFailed(Exception e) &#123; cutestCatCallback.onError(e); &#125; &#125;); &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 现在我们再来看看这部分代码？还是之前那样简单暴力？现在有太多的干扰代码、匿名类，这简直是太恐怖了，但是他们的业务逻辑其实是一样的，都是查询猫的列表数据，然后找出最可爱的猫并保存它的图片。 上面说好的组合功能没有了，现在你没法像阻塞操作一样来组合调用每个功能了，异步操作中，每次你都必须通过回调接口来手工的处理结果。 上面说好的异常处理也没有了，异步代码中的异常不会自动传递，我们需要手动的去重新传递。(onStoreFailed()和onQueryFailed()就是干这事的) ####结果？ 然后呢？我们可以怎么做？我们能不能使用无回调的模式？我们试着修复一下。 ####奔向更好的世界 ####通用的回调 如果我们仔细的观察下回调接口，我们会发现它们的共性: 它们都有一个分发结果的方法(onCutestCatSaved(),onCatListReceived(),onCatStored()) 它们中的绝大部分都有一个处理操作过程中异常的方法(onError(), onQueryFailed(), onStoreFailed()) 所以我们可以创建一个通用的回调来取代它们。但是我们无法修改api的调用结构，我们只能创建一个包裹层的调用。 我们通用的回调如下: 1234public interface Callback&lt;T&gt; &#123; void onResult(T result); void onError(Exception e);&#125; 我们创建一个ApiWrapper类来改变我们调用的结构: 12345678910111213141516171819202122232425262728293031public class ApiWrapper &#123; Api api; public void queryCats(String query, Callback&lt;List&lt;Cat&gt;&gt; catsCallback)&#123; api.queryCats(query, new Api.CatsQueryCallback() &#123; @Override public void onCatListReceived(List&lt;Cat&gt; cats) &#123; catsCallback.onResult(cats); &#125; @Override public void onQueryFailed(Exception e) &#123; catsCallback.onError(e); &#125; &#125;); &#125; public void store(Cat cat, Callback&lt;Uri&gt; uriCallback)&#123; api.store(cat, new Api.StoreCallback() &#123; @Override public void onCatStored(Uri uri) &#123; uriCallback.onResult(uri); &#125; @Override public void onStoreFailed(Exception e) &#123; uriCallback.onError(e); &#125; &#125;); &#125;&#125; 这样通过新的回调我们可以减少一次处理结果和异常的逻辑。最终，我们的CatsHelper如下:1234567891011121314151617181920212223public class CatsHelper&#123; ApiWrapper apiWrapper; public void saveTheCutestCat(String query, Callback&lt;Uri&gt; cutestCatCallback)&#123; apiWrapper.queryCats(query, new Callback&lt;List&lt;Cat&gt;&gt;() &#123; @Override public void onResult(List&lt;Cat&gt; cats) &#123; Cat cutest = findCutest(cats); apiWrapper.store(cutest, cutestCatCallback); &#125; @Override public void onError(Exception e) &#123; cutestCatCallback.onError(e); &#125; &#125;); &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 好了，现在比之前的代码稍微简单点了。但是我们能不能做的更好？ 当然可以！ ####保持参数和回调的分离性 看看这些新的异步操作(queryCats,store和saveTheCutestCat)。这些函数都有同样的模式。使用一些参数来调用这些函数(query,cat)，同时还有一个回调接口作为参数。甚至，所有的异步操作都带有一些常规参数和一个额外的回调接口参数。如果我们把他们分离开会如何，让每个异步操作只有一些常规参数而把返回一个临时的对象来操作回调接口。下面来试试看看这种方式能否有效。如果我们返回一个临时的对象作为异步操作的回调接口处理方式，我们需要先定义这个对象。由于对象遵守通用的行为(有一个回调接口参数)，我们定义一个能用于所有操作的对象。我们称之为AsyncJob。 注意： 我非常想把这个名字称之为AsyncTask。但是由于Android系统已经有个AsyncTask类了， 为了避免混淆，所以就用AsyncJob了。 该对象如下:123public abstract class AsyncJob&lt;T&gt; &#123; public abstract void start(Callback&lt;T&gt; callback);&#125; start()函数有个Callback回调接口参数，并开始执行该操作。ApiWrapper修改为：1234567891011121314151617181920212223242526272829303132333435363738394041public class ApiWrapper &#123; Api api; public AsyncJob&lt;List&lt;Cat&gt;&gt; queryCats(String query) &#123; return new AsyncJob&lt;List&lt;Cat&gt;&gt;() &#123; @Override public void start(Callback&lt;List&lt;Cat&gt;&gt; catsCallback) &#123; api.queryCats(query, new Api.CatsQueryCallback() &#123; @Override public void onCatListReceived(List&lt;Cat&gt; cats) &#123; catsCallback.onResult(cats); &#125; @Override public void onQueryFailed(Exception e) &#123; catsCallback.onError(e); &#125; &#125;); &#125; &#125;; &#125; public AsyncJob&lt;Uri&gt; store(Cat cat) &#123; return new AsyncJob&lt;Uri&gt;() &#123; @Override public void start(Callback&lt;Uri&gt; uriCallback) &#123; api.store(cat, new Api.StoreCallback() &#123; @Override public void onCatStored(Uri uri) &#123; uriCallback.onResult(uri); &#125; @Override public void onStoreFailed(Exception e) &#123; uriCallback.onError(e); &#125; &#125;); &#125; &#125;; &#125;&#125; 目前看起来还不错。现在可以使用AsyncJob.start()来启动每个操作了。接下来我们修改CatsHelper类： 12345678910111213141516171819202122232425262728293031323334353637383940public class CatsHelper &#123; ApiWrapper apiWrapper; public AsyncJob&lt;Uri&gt; saveTheCutestCat(String query) &#123; return new AsyncJob&lt;Uri&gt;() &#123; @Override public void start(Callback&lt;Uri&gt; cutestCatCallback) &#123; apiWrapper.queryCats(query) .start(new Callback&lt;List&lt;Cat&gt;&gt;() &#123; @Override public void onResult(List&lt;Cat&gt; cats) &#123; Cat cutest = findCutest(cats); apiWrapper.store(cutest) .start(new Callback&lt;Uri&gt;() &#123; @Override public void onResult(Uri result) &#123; cutestCatCallback.onResult(result); &#125; @Override public void onError(Exception e) &#123; cutestCatCallback.onError(e); &#125; &#125;); &#125; @Override public void onError(Exception e) &#123; cutestCatCallback.onError(e); &#125; &#125;); &#125; &#125;; &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 看起来比前面一个版本更加复杂啊，这样有啥好处啊？这里其实我们返回的是一个AsyncJob对象，该对象和客户端代码组合使用，这样在Activity或者Fragment客户端代码中就可以操作这个返回的对象了。代码虽然目前看起来比较复杂，下面我们就来改进一下。 ####分解 下面是流程图:123 (async) (sync) (async)query ===========&gt; List&lt;Cat&gt; -------------&gt; Cat ==========&gt; Uri queryCats findCutest store 为了让代码具有可读性，我们把这个流程分解为每个操作。同时我们再进一步假设，如果一个操作是异步的，则每个调用该异步操作的函数也是异步的。例如：如果查询猫是个异步操作，则找到最可爱的猫操作也是异步的。 因此，我们可以使用AsyncJob来把这些操作分解为一些小的操作中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class CatsHelper &#123; ApiWrapper apiWrapper; public AsyncJob&lt;Uri&gt; saveTheCutestCat(String query) &#123; AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query); AsyncJob&lt;Cat&gt; cutestCatAsyncJob = new AsyncJob&lt;Cat&gt;() &#123; @Override public void start(Callback&lt;Cat&gt; callback) &#123; catsListAsyncJob.start(new Callback&lt;List&lt;Cat&gt;&gt;() &#123; @Override public void onResult(List&lt;Cat&gt; result) &#123; callback.onResult(findCutest(result)); &#125; @Override public void onError(Exception e) &#123; callback.onError(e); &#125; &#125;); &#125; &#125;; AsyncJob&lt;Uri&gt; storedUriAsyncJob = new AsyncJob&lt;Uri&gt;() &#123; @Override public void start(Callback&lt;Uri&gt; cutestCatCallback) &#123; cutestCatAsyncJob.start(new Callback&lt;Cat&gt;() &#123; @Override public void onResult(Cat cutest) &#123; apiWrapper.store(cutest) .start(new Callback&lt;Uri&gt;() &#123; @Override public void onResult(Uri result) &#123; cutestCatCallback.onResult(result); &#125; @Override public void onError(Exception e) &#123; cutestCatCallback.onError(e); &#125; &#125;); &#125; @Override public void onError(Exception e) &#123; cutestCatCallback.onError(e); &#125; &#125;); &#125; &#125;; return storedUriAsyncJob; &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 虽然代码量多了，但是看起来更加清晰了。 嵌套的回调函数没那么多层级了，异步操作的名字也更容易理解了(catsListAsyncJob,cutestCatAsyncJob, storedUriAsyncJob)。看起来还不错，但是还可以更好。 ####简单的映射 先来看看我们创建 AsyncJob cutestCatAsyncJob 的代码： 12345678910111213141516AsyncJob&lt;Cat&gt; cutestCatAsyncJob = new AsyncJob&lt;Cat&gt;() &#123; @Override public void start(Callback&lt;Cat&gt; callback) &#123; catsListAsyncJob.start(new Callback&lt;List&lt;Cat&gt;&gt;() &#123; @Override public void onResult(List&lt;Cat&gt; result) &#123; callback.onResult(findCutest(result)); &#125; @Override public void onError(Exception e) &#123; callback.onError(e); &#125; &#125;); &#125; &#125;; 这 16 行代码中，只有一行代码是我们的业务逻辑代码：1findCutest(result) 其他的代码只是为了启动AsyncJob并接收结果和处理异常的干扰代码。 但是这些代码是通用的，我们可以把他们放到其他地方来让我们更加专注业务逻辑代码。那么如何实现呢？需要做两件事情： 通过AsyncJob获取需要转换的结果 转换的函数 但是由于Java的限制，无法把函数作为参数，所以需要用一个接口（或者类）并在里面定义一个转换函数： 123public interface Func&lt;T, R&gt; &#123; R call(T t);&#125; 灰常简单。 有两个泛型类型定义，T代表参数的类型；R代表返回值的类型。 当我们把AsyncJob的结果转换为其他类型的时候，我们需要把一个结果值映射为另外一种类型，这个操作我们称之为map。 把该函数定义到AsyncJob类中比较方便，这样就可以通过this来访问AsyncJob对象了。 123456789101112131415161718192021222324public abstract class AsyncJob&lt;T&gt; &#123; public abstract void start(Callback&lt;T&gt; callback); public &lt;R&gt; AsyncJob&lt;R&gt; map(Func&lt;T, R&gt; func)&#123; final AsyncJob&lt;T&gt; source = this; return new AsyncJob&lt;R&gt;() &#123; @Override public void start(Callback&lt;R&gt; callback) &#123; source.start(new Callback&lt;T&gt;() &#123; @Override public void onResult(T result) &#123; R mapped = func.call(result); callback.onResult(mapped); &#125; @Override public void onError(Exception e) &#123; callback.onError(e); &#125; &#125;); &#125; &#125;; &#125;&#125; 看起来不错， 现在的CatsHelper如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CatsHelper &#123; ApiWrapper apiWrapper; public AsyncJob&lt;Uri&gt; saveTheCutestCat(String query) &#123; AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query); AsyncJob&lt;Cat&gt; cutestCatAsyncJob = catsListAsyncJob.map(new Func&lt;List&lt;Cat&gt;, Cat&gt;() &#123; @Override public Cat call(List&lt;Cat&gt; cats) &#123; return findCutest(cats); &#125; &#125;); AsyncJob&lt;Uri&gt; storedUriAsyncJob = new AsyncJob&lt;Uri&gt;() &#123; @Override public void start(Callback&lt;Uri&gt; cutestCatCallback) &#123; cutestCatAsyncJob.start(new Callback&lt;Cat&gt;() &#123; @Override public void onResult(Cat cutest) &#123; apiWrapper.store(cutest) .start(new Callback&lt;Uri&gt;() &#123; @Override public void onResult(Uri result) &#123; cutestCatCallback.onResult(result); &#125; @Override public void onError(Exception e) &#123; cutestCatCallback.onError(e); &#125; &#125;); &#125; @Override public void onError(Exception e) &#123; cutestCatCallback.onError(e); &#125; &#125;); &#125; &#125;; return storedUriAsyncJob; &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 新创建的AsyncJob cutestCatAsyncJob()的代码只有6行，并且只有一层嵌套。 ####高级映射 但是AsyncJob storedUriAsyncJob()看起来还是非常糟糕。 这里也能使用映射吗？ 下面就来试试吧！ 123456789101112131415161718192021222324252627282930public class CatsHelper &#123; ApiWrapper apiWrapper; public AsyncJob&lt;Uri&gt; saveTheCutestCat(String query) &#123; AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query); AsyncJob&lt;Cat&gt; cutestCatAsyncJob = catsListAsyncJob.map(new Func&lt;List&lt;Cat&gt;, Cat&gt;() &#123; @Override public Cat call(List&lt;Cat&gt; cats) &#123; return findCutest(cats); &#125; &#125;); AsyncJob&lt;Uri&gt; storedUriAsyncJob = cutestCatAsyncJob.map(new Func&lt;Cat, Uri&gt;() &#123; @Override public Uri call(Cat cat) &#123; return apiWrapper.store(cat); // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 将会导致无法编译 // Incompatible types: // Required: Uri // Found: AsyncJob&lt;Uri&gt; &#125; &#125;); return storedUriAsyncJob; &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 哎。。。 看起来没这么简单啊， 下面修复返回的类型再试一次： 123456789101112131415161718192021222324252627282930public class CatsHelper &#123; ApiWrapper apiWrapper; public AsyncJob&lt;Uri&gt; saveTheCutestCat(String query) &#123; AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query); AsyncJob&lt;Cat&gt; cutestCatAsyncJob = catsListAsyncJob.map(new Func&lt;List&lt;Cat&gt;, Cat&gt;() &#123; @Override public Cat call(List&lt;Cat&gt; cats) &#123; return findCutest(cats); &#125; &#125;); AsyncJob&lt;AsyncJob&lt;Uri&gt;&gt; storedUriAsyncJob = cutestCatAsyncJob.map(new Func&lt;Cat, AsyncJob&lt;Uri&gt;&gt;() &#123; @Override public AsyncJob&lt;Uri&gt; call(Cat cat) &#123; return apiWrapper.store(cat); &#125; &#125;); return storedUriAsyncJob; //^^^^^^^^^^^^^^^^^^^^^^^ 将会导致无法编译 // Incompatible types: // Required: AsyncJob&lt;Uri&gt; // Found: AsyncJob&lt;AsyncJob&lt;Uri&gt;&gt; &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 这里我们只能拿到AsyncJob&lt;AsyncJob&gt; 。看来还需要更进一步。我们需要压缩一层AsyncJob，把两个异步操作当做一个单一的异步操作来对待。现在我们需要一个参数为AsyncJob的map转换操作而不是R。该操作类似于map，但是该操作会把嵌套的AsyncJob压缩为flatten一层AsyncJob. 我们称之为flatMap，实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class AsyncJob&lt;T&gt; &#123; public abstract void start(Callback&lt;T&gt; callback); public &lt;R&gt; AsyncJob&lt;R&gt; map(Func&lt;T, R&gt; func)&#123; final AsyncJob&lt;T&gt; source = this; return new AsyncJob&lt;R&gt;() &#123; @Override public void start(Callback&lt;R&gt; callback) &#123; source.start(new Callback&lt;T&gt;() &#123; @Override public void onResult(T result) &#123; R mapped = func.call(result); callback.onResult(mapped); &#125; @Override public void onError(Exception e) &#123; callback.onError(e); &#125; &#125;); &#125; &#125;; &#125; public &lt;R&gt; AsyncJob&lt;R&gt; flatMap(Func&lt;T, AsyncJob&lt;R&gt;&gt; func)&#123; final AsyncJob&lt;T&gt; source = this; return new AsyncJob&lt;R&gt;() &#123; @Override public void start(Callback&lt;R&gt; callback) &#123; source.start(new Callback&lt;T&gt;() &#123; @Override public void onResult(T result) &#123; AsyncJob&lt;R&gt; mapped = func.call(result); mapped.start(new Callback&lt;R&gt;() &#123; @Override public void onResult(R result) &#123; callback.onResult(result); &#125; @Override public void onError(Exception e) &#123; callback.onError(e); &#125; &#125;); &#125; @Override public void onError(Exception e) &#123; callback.onError(e); &#125; &#125;); &#125; &#125;; &#125;&#125; 看起来有很多干扰代码，但是还好这些代码在客户端代码中并不会出现。 现在我们的CatsHelper如下： 1234567891011121314151617181920212223242526public class CatsHelper &#123; ApiWrapper apiWrapper; public AsyncJob&lt;Uri&gt; saveTheCutestCat(String query) &#123; AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query); AsyncJob&lt;Cat&gt; cutestCatAsyncJob = catsListAsyncJob.map(new Func&lt;List&lt;Cat&gt;, Cat&gt;() &#123; @Override public Cat call(List&lt;Cat&gt; cats) &#123; return findCutest(cats); &#125; &#125;); AsyncJob&lt;Uri&gt; storedUriAsyncJob = cutestCatAsyncJob.flatMap(new Func&lt;Cat, AsyncJob&lt;Uri&gt;&gt;() &#123; @Override public AsyncJob&lt;Uri&gt; call(Cat cat) &#123; return apiWrapper.store(cat); &#125; &#125;); return storedUriAsyncJob; &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 如果把匿名类修改为Java 8的lambdas表达式（逻辑是一样的，只是让代码看起来更清晰点）就很容易发现了。 123456789101112131415public class CatsHelper &#123; ApiWrapper apiWrapper; public AsyncJob&lt;Uri&gt; saveTheCutestCat(String query) &#123; AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query); AsyncJob&lt;Cat&gt; cutestCatAsyncJob = catsListAsyncJob.map(cats -&gt; findCutest(cats)); AsyncJob&lt;Uri&gt; storedUriAsyncJob = cutestCatAsyncJob.flatMap(cat -&gt; apiWrapper.store(cat)); return storedUriAsyncJob; &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 这样看起来是不是就很清晰了。 这个代码和刚刚开头的阻塞式代码是不是非常相似： 123456789101112131415public class CatsHelper &#123; Api api; public Uri saveTheCutestCat(String query)&#123; List&lt;Cat&gt; cats = api.queryCats(query); Cat cutest = findCutest(cats); Uri savedUri = api.store(cutest); return savedUri; &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 现在他们不仅逻辑是一样的，语义上也是一样的。 太棒了！同时我们还可以使用组合操作，现在把两个异步操作组合一起并返还另外一个异步操作。异常处理也会传递到最终的回调接口中。下面来看看RxJava吧。你没必要把上面代码应用到您的项目中去， 这些简单的、线程不安全的代码只是 RxJava的一部分。只有一些名字上的不同： AsyncJob等同于Observable，不仅仅可以返回一个结果，还可以返回一系列的结果，当然也可能没有结果返回。 Callback等同于Observer，除了onNext(T t), onError(Throwable t)以外，还有一个onCompleted()函数，该函数在结束继续返回结果的时候通知Observable。 abstract void start(Callback callback)和Subscription subscribe(final Observer observer)类似，返回一个Subscription，如果你不再需要后面的结果了，可以取消该任务。 下面是RxJava版本的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ApiWrapper &#123; Api api; public Observable&lt;List&lt;Cat&gt;&gt; queryCats(final String query) &#123; return Observable.create(new Observable.OnSubscribe&lt;List&lt;Cat&gt;&gt;() &#123; @Override public void call(final Subscriber&lt;? super List&lt;Cat&gt;&gt; subscriber) &#123; api.queryCats(query, new Api.CatsQueryCallback() &#123; @Override public void onCatListReceived(List&lt;Cat&gt; cats) &#123; subscriber.onNext(cats); &#125; @Override public void onQueryFailed(Exception e) &#123; subscriber.onError(e); &#125; &#125;); &#125; &#125;); &#125; public Observable&lt;Uri&gt; store(final Cat cat) &#123; return Observable.create(new Observable.OnSubscribe&lt;Uri&gt;() &#123; @Override public void call(final Subscriber&lt;? super Uri&gt; subscriber) &#123; api.store(cat, new Api.StoreCallback() &#123; @Override public void onCatStored(Uri uri) &#123; subscriber.onNext(uri); &#125; @Override public void onStoreFailed(Exception e) &#123; subscriber.onError(e); &#125; &#125;); &#125; &#125;); &#125;&#125; public class CatsHelper &#123; ApiWrapper apiWrapper; public Observable&lt;Uri&gt; saveTheCutestCat(String query) &#123; Observable&lt;List&lt;Cat&gt;&gt; catsListObservable = apiWrapper.queryCats(query); Observable&lt;Cat&gt; cutestCatObservable = catsListObservable.map(new Func1&lt;List&lt;Cat&gt;, Cat&gt;() &#123; @Override public Cat call(List&lt;Cat&gt; cats) &#123; return CatsHelper.this.findCutest(cats); &#125; &#125;); Observable&lt;Uri&gt; storedUriObservable = cutestCatObservable.flatMap(new Func1&lt;Cat, Observable&lt;? extends Uri&gt;&gt;() &#123; @Override public Observable&lt;? extends Uri&gt; call(Cat cat) &#123; return apiWrapper.store(cat); &#125; &#125;); return storedUriObservable; &#125; private Cat findCutest(List&lt;Cat&gt; cats) &#123; return Collections.max(cats); &#125;&#125; 把 Observable 替换为 AsyncJob 后 他们的代码是一样的。 ####结论 通过简单的转换操作，我们可以把异步操作抽象出来。这种抽象的结果可以像操作简单的阻塞函数一样来操作异步操作并组合异步操作。这样我们就可以摆脱层层嵌套的回调接口了，并且不用手工的去处理每次异步操作的异常。 上面这个例子非常好，建议多看几遍，加深理解，可能把这个例子放在这里并不太好，把它放到开始讲之前可能更容易理解，但是我觉得，介绍完概念、使用方法和基本的操作符后，我们可能并不能理解操作符的原理和作用。之前看完操作符原理后迷迷糊糊的状态再来看这个例子会豁然开朗。 这里也感谢牛逼的作者Yaroslav(也是RxAndroid项目的一个重要参与者)能用这么牛逼的例子，讲解的如此透彻。 如果嫌上面的代码麻烦，可以通过下面的例子看: 假设有这样一个需求：界面上有一个自定义的视图imageCollectorView，它的作用是显示多张图片，并能使用addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组File[] folders中每个目录下的png图片都加载出来并显示在imageCollectorView中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在UI线程执行。常用的实现方式有多种，我这里贴出其中一种： 1234567891011121314151617181920new Thread() &#123; @Override public void run() &#123; super.run(); for (File folder : folders) &#123; File[] files = folder.listFiles(); for (File file : files) &#123; if (file.getName().endsWith(\".png\")) &#123; final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;.start(); 而如果使用 RxJava ，实现方式是这样的： 123456789101112131415161718192021222324252627Observable.from(folders) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; return file.getName().endsWith(\".png\"); &#125; &#125;) .map(new Func1&lt;File, Bitmap&gt;() &#123; @Override public Bitmap call(File file) &#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); 那位说话了：『你这代码明明变多了啊！简洁个毛啊！』大兄弟你消消气，我说的是逻辑的简洁，不是单纯的代码量少（逻辑简洁才是提升读写代码速度的必杀技对不？）。观察一下你会发现， RxJava的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显（试想如果还要求只选取前10张图片，常规方式要怎么办？如果有更多这样那样的要求呢？再试想，在这一大堆需求实现完两个月之后需要改功能，当你翻回这里看到自己当初写下的那一片迷之缩进，你能保证自己将迅速看懂，而不是对着代码重新捋一遍思路？）。 更多内容请看下一篇文章RxJava详解(下).md) 参考: RxJava Wiki Grokking RxJava, Part 1: The Basics NotRxJava When Not to Use RxJava 给 Android 开发者的 RxJava 详解 Google Agera 从入门到放弃 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"MaterialDesign使用","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/MaterialDesign使用/","text":"MaterialDesign使用 Material Design是Google在2014年的I/O大会上推出的全新设计语言。 Material Design是基于Android 5.0``(API level 21)的，兼容5.0以下的设备时需要使用版本号v21.0.0以上的support v7包中的appcpmpat，不过遗憾的是support包只支持Material Design的部分特性。使用eclipse或Android Studio进行开发时，直接在Android SDK Manager中将Extras-&gt;Android Support Library升级至最新版即可。 下面我就简单讲解一下如何通过support v7包来使用Material Design进行开发。 Material Design ThemeMaterial主题: @android:style/Theme.Material (dark version) – Theme.AppCompat @android:style/Theme.Material.Light (light version) – Theme.AppCompat.Light @android:style/Theme.Material.Light.DarkActionBar – Theme.AppCompat.Light.DarkActionBar 对应的效果分别如下: 使用ToolBar 禁止Action Bar 可以通过使用Material theme来让应用使用Material Design。想要使用ToolBar需要先禁用ActionBar。 可以通过自定义theme继承Theme.AppCompat.Light.NoActionBar或者在theme中通过以下配置来进行。 12&lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt;&lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; 下面我通过第二种方式来看一下具体的实现: 在`style.xml`中自定义`AppTheme`: 1234567891011121314151617&lt;!-- Base application theme. --&gt;&lt;style name=\"AppTheme\" parent=\"AppTheme.Base\"/&gt;&lt;style name=\"AppTheme.Base\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Tell Android System that we will use ToolBar instead of ActionBar --&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt; &lt;!-- colorPrimary is used for the default action bar background --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;!-- colorPrimaryDark is used for the status bar --&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;!-- colorAccent is used as the default value for colorControlActivated which is used to tint widgets --&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 配置的这几种颜色分别如下图所示: ![Image](https://raw.githubusercontent.com/CharonChui/Pictures/master/material_color.png?raw=true) 里面没有`colorAccent`的颜色，这个颜色是设置`Checkbox`等控件选中时的颜色。 在`values-v21`中的`style.xml`中同样自定义`AppTheme`主题: 12345678&lt;style name=\"AppTheme\" parent=\"AppTheme.Base\"&gt; &lt;!-- Customize your theme using Material Design here. --&gt; &lt;item name=\"android:windowContentTransitions\" &gt;true&lt;/item&gt; &lt;item name=\"android:windowAllowEnterTransitionOverlap\" &gt;true&lt;/item&gt; &lt;item name=\"android:windowAllowReturnTransitionOverlap\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowSharedElementEnterTransition\"&gt;@android:transition/move&lt;/item&gt; &lt;item name=\"android:windowSharedElementExitTransition\"&gt;@android:transition/move&lt;/item&gt;&lt;/style&gt; 在Manifest文件中设置AppTheme主题: 12345678910&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\" &gt; &lt;activity ... &lt;/activity&gt; &lt;activity android:name=\"com.charon.materialsample.FriendsActivity\"&gt;&lt;/activity&gt;&lt;/application&gt; 这里说一下为什么要在values-v21中也自定义个主题，这是为了能让在21以上的版本能更好的使用Material Design，在21以上的版本中会有更多的动画、特效等。 让Activity继承AppCompatActivity 123public class MainActivity extends AppCompatActivity &#123; ...&#125; 在布局文件中进行声明 声明toolbar.xml，我们把他单独放到一个文件中，方便多布局使用: 123456789&lt;android.support.v7.widget.Toolbar xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:local=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimary\" android:minHeight=\"?attr/actionBarSize\" local:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" local:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" /&gt; 在Activity的布局中使用ToolBar: 123456789101112131415161718192021&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;include android:id=\"@+id/toolbar\" layout=\"@layout/toolbar\" /&gt; &lt;com.charon.materialsample.view.PagerSlidingTabStrip android:id=\"@+id/psts_main\" android:layout_width=\"match_parent\" android:layout_height=\"48dip\" android:background=\"@color/colorPrimary\" /&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/vp_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;/LinearLayout&gt; 在Activity中设置ToolBar 1234567891011121314151617public class MainActivity extends AppCompatActivity&#123; private Context mContext; private Toolbar mToolbar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mContext = this; mToolbar = (Toolbar) findViewById(R.id.toolbar); mToolbar.setTitle(R.string.app_name); // 将ToolBar设置为ActionBar，这样一设置后他就能像ActionBar一样直接显示menu目录中的菜单资源 // 如果不用该方法，那ToolBar就只是一个普通的View，对menu要用inflateMenu去加载布局。 setSupportActionBar(mToolbar); getSupportActionBar().setDisplayShowHomeEnabled(true); &#125;&#125; 到这里运行项目就可以了，就可以看到一个简单的ToolBar实现。 接下来我们看一下ToolBar中具体有哪些内容: 我们可以通过对应的方法来修改他们的属性: 对于ToolBar中的Menu部分我们可以通过一下方法来设置:12toolbar.inflateMenu(R.menu.menu_main);toolbar.setOnMenuItemClickListener(); 或者也可以直接在Activity的onCreateOptionsMenu及onOptionsItemSelected来处理:123456789101112131415161718192021222324@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true;&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; if (id == R.id.action_search) &#123; Toast.makeText(getApplicationContext(), \"Search action is selected!\", Toast.LENGTH_SHORT).show(); return true; &#125; return super.onOptionsItemSelected(item);&#125; menu的实现如下:123456789101112131415161718&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" tools:context=\".MainActivity\"&gt; &lt;item android:id=\"@+id/action_search\" android:title=\"@string/action_search\" android:orderInCategory=\"100\" android:icon=\"@drawable/ic_action_search\" app:showAsAction=\"ifRoom\" /&gt; &lt;item android:id=\"@+id/action_settings\" android:title=\"@string/action_settings\" android:orderInCategory=\"100\" app:showAsAction=\"never\" /&gt;&lt;/menu&gt; 如果想要对NavigationIcon添加点击实现:123456toolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onBackPressed(); &#125;&#125;); 运行后发现我们强大的Activity切换动画怎么在5.0一下系统上实现呢？support v7包也帮我们考虑到了。使用ActivityOptionsCompat及ActivityCompat.startActivity，但是悲剧了，他对4.0一下基本都无效，而且就算在4.0上很多动画也不行，具体还是用其他大神在github写的开源项目吧。 动态取色Palette Palette这个类中可以提取一下集中颜色： Vibrant （有活力） Vibrant dark（有活力 暗色） Vibrant light（有活力 亮色） Muted （柔和） Muted dark（柔和 暗色） Muted light（柔和 亮色） 1234567891011//目标bitmap，代码片段Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.kale);Palette palette = Palette.generate(bm);if (palette.getLightVibrantSwatch() != null) &#123; //得到不同的样本，设置给imageview进行显示 iv.setBackgroundColor(palette.getLightVibrantSwatch().getRgb()); iv1.setBackgroundColor(palette.getDarkVibrantSwatch().getRgb()); iv2.setBackgroundColor(palette.getLightMutedSwatch().getRgb()); iv3.setBackgroundColor(palette.getDarkMutedSwatch().getRgb());&#125; 使用DrawerLayout 布局中的使用 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!--主页面--&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;include android:id=\"@+id/toolbar\" layout=\"@layout/toolbar\" /&gt; &lt;com.charon.materialsample.view.PagerSlidingTabStrip android:id=\"@+id/psts_main\" android:layout_width=\"match_parent\" android:layout_height=\"48dip\" android:background=\"@color/colorPrimary\" /&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/vp_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v4.view.ViewPager&gt; &lt;/LinearLayout&gt; &lt;!--侧边栏部分--&gt; &lt;fragment android:id=\"@+id/fragment_navigation_drawer\" android:name=\"com.charon.materialsample.fragment.FragmentDrawer\" android:layout_width=\"@dimen/nav_drawer_width\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" app:layout=\"@layout/fragment_navigation_drawer\" tools:layout=\"@layout/fragment_navigation_drawer\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 使用DrawerLayout后可以实现类似SlidingMenu的效果。但是怎么将DrawerLayout与ToolBar结合起来呢？ 还有再结合Navigation Tabs以及ViewPager。下面我就直接上代码了。 先看布局： activity_main.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!--主页面--&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;include android:id=\"@+id/toolbar\" layout=\"@layout/toolbar\" /&gt; &lt;com.charon.materialsample.view.PagerSlidingTabStrip android:id=\"@+id/psts_main\" android:layout_width=\"match_parent\" android:layout_height=\"48dip\" android:background=\"@color/colorPrimary\" /&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/vp_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; &lt;/LinearLayout&gt; &lt;!--侧边栏部分--&gt; &lt;fragment android:id=\"@+id/fragment_navigation_drawer\" android:name=\"com.charon.materialsample.fragment.DrawerFragment\" android:layout_width=\"wrap_content\" android:layout_marginRight=\"56dp\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" app:layout=\"@layout/fragment_navigation_drawer\" tools:layout=\"@layout/fragment_navigation_drawer\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; MainActivity的代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class MainActivity extends AppCompatActivity &#123; private Context mContext; private Toolbar mToolbar; private PagerSlidingTabStrip mScrollingTabs; private ViewPager mViewPager; private MainPagerAdapter mPagerAdapter; private ActionBarDrawerToggle mDrawerToggle; private DrawerLayout mDrawerLayout; private List&lt;String&gt; mTitles; private List&lt;Fragment&gt; mFragments; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mContext = this; findView(); setToolBar(); initView(); initDrawerFragment(); &#125; private void findView() &#123; mToolbar = (Toolbar) findViewById(R.id.toolbar); mScrollingTabs = (PagerSlidingTabStrip) findViewById(R.id.psts_main); mViewPager = (ViewPager) findViewById(R.id.vp_main); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); &#125; private void setToolBar() &#123; mToolbar.setTitle(R.string.app_name); setSupportActionBar(mToolbar); getSupportActionBar().setDisplayShowHomeEnabled(true); &#125; private void initView() &#123; mFragments = new ArrayList&lt;&gt;(); for (int xxx = 0; xxx &lt; 5; xxx++) &#123; mFragments.add(new FriendsFragment()); &#125; mTitles = new ArrayList&lt;&gt;(); for (int xxx = 0; xxx &lt; 5; xxx++) &#123; mTitles.add(\"Tab : \" + xxx); &#125; mPagerAdapter = new MainPagerAdapter(getSupportFragmentManager(), mFragments, mTitles); mViewPager.setAdapter(mPagerAdapter); mScrollingTabs.setDividerColor(Color.TRANSPARENT); mScrollingTabs.setIndicatorHeight(10); mScrollingTabs.setUnderlineHeight(0); mScrollingTabs.setTextSize(50); mScrollingTabs.setTextColor(Color.BLACK); mScrollingTabs.setSelectedTextColor(Color.WHITE); mScrollingTabs.setViewPager(mViewPager); &#125; private void initDrawerFragment() &#123; mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, mToolbar, R.string.drawer_open, R.string.drawer_close) &#123; @Override public void onDrawerOpened(View drawerView) &#123; super.onDrawerOpened(drawerView); MainActivity.this.invalidateOptionsMenu(); &#125; @Override public void onDrawerClosed(View drawerView) &#123; super.onDrawerClosed(drawerView); MainActivity.this.invalidateOptionsMenu(); &#125; @Override public void onDrawerSlide(View drawerView, float slideOffset) &#123; super.onDrawerSlide(drawerView, slideOffset); mToolbar.setAlpha(1 - slideOffset / 2); &#125; &#125;; mDrawerLayout.setDrawerListener(mDrawerToggle); mDrawerToggle.syncState(); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; if (id == R.id.action_search) &#123; Toast.makeText(getApplicationContext(), \"Search action is selected!\", Toast.LENGTH_SHORT).show(); return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 最后再看一下DrawerFragment的代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class DrawerFragment extends Fragment &#123; private Context mContext; private RecyclerView mRecyclerView; private NavigationDrawerAdapter mAdapter; private static String[] titles = null; public DrawerFragment() &#123; &#125; public static List&lt;NavDrawerItem&gt; getData() &#123; List&lt;NavDrawerItem&gt; data = new ArrayList&lt;&gt;(); // preparing navigation drawer items for (int i = 0; i &lt; titles.length; i++) &#123; NavDrawerItem navItem = new NavDrawerItem(); navItem.setTitle(titles[i]); data.add(navItem); &#125; return data; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mContext = getActivity(); // drawer labels titles = getActivity().getResources().getStringArray(R.array.nav_drawer_labels); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflating view layout View layout = inflater.inflate(R.layout.fragment_navigation_drawer, container, false); mRecyclerView = (RecyclerView) layout.findViewById(R.id.drawerList); mRecyclerView.setHasFixedSize(true); mAdapter = new NavigationDrawerAdapter(getActivity(), getData()); mRecyclerView.setAdapter(mAdapter); mRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); mAdapter.setOnRecyclerViewListener(new NavigationDrawerAdapter.OnRecyclerViewListener() &#123; @Override public void onItemClick(int position) &#123; Toast.makeText(mContext, getData().get(position).getTitle(), Toast.LENGTH_SHORT).show(); startActivity(new Intent(getActivity(), FriendsActivity.class)); &#125; @Override public boolean onItemLongClick(int position) &#123; return false; &#125; &#125;); return layout; &#125;&#125; 上面的PagerSlidingTabStrip是开源项目，我改了下，添加了一个选中时的文字颜色改变。 Demo地址 Ripple效果个人非常喜欢的效果。相当于给点击事件加上了动态的赶脚。。。 假设现在有一个Button的selector，我们想给这个Button加上Ripple效果，肿么办？新建一个xml文件，用ripple包裹selector，然后在Button的backgroud直接引用这个xml就好了。12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ripple xmlns:android=\"http://schemas.android.com/apk/res/android\"android:color=\"@color/whatever\"&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&lt;item android:state_pressed=\"false\" android:state_focused=\"true\"android:drawable=\"@drawable/some_focused_blah\"/&gt;&lt;item android:state_pressed=\"true\" android:drawable=\"@drawable/some_pressed_blah\"/&gt;&lt;item android:drawable=\"@android:color/whatever\"/&gt;&lt;/selector&gt;&lt;/ripple&gt; 但是很遗憾，ripple是5.0才有的，而且support包中没有实现该功能的扩展。5.0的这些效果还是无法在低版本上实现，包括一些TextView等样式，现在可以用大神的开源项目MaterialDesignLibrary RecyclerViewListView的升级版，还有什么理由不去用呢？ 同样他也在support v7包中。1compile &apos;com.android.support:recyclerview-v7:21.+&apos; 通过mRecyclerView.setLayoutManager(new LinearLayoutManager(this));设置为LinearLayoutManager来实现水平或者竖直方向的ListView。 阴影通过对View设置backgroud后再添加android:elevation=&quot;2dp&quot;来实现背景大小。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android启动模式详解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Android启动模式详解/","text":"Android启动模式详解 standard 默认模式。在该模式下，Activity可以拥有多个实例，并且这些实例既可以位于同一个task，也可以位于不同的task。每次都会新创建。 singleTop 该模式下，在同一个task中，如果存在该Activity的实例，并且该Activity实例位于栈顶则不会创建该Activity的示例,而仅仅只是调用Activity的onNewIntent()。否则的话，则新建该Activity的实例，并将其置于栈顶。 singleTask 顾名思义，只容许有一个包含该Activity实例的task存在！ 在android浏览器browser中，BrowserActivity的launcherMode=&quot;singleTask&quot;，因为browser不断地启动自己，所以要求这个栈中保持只能有一个自己的实例，browser上网的时候， 遇到播放视频的链接，就会通过隐式intent方式跳转找Gallery3D中的MovieView这个类来播放视频，这时候如果你点击home键，再点击browser，你会发现MovieView这个类已经销毁不存在了， 而不会像保存这个MovieView的类对象，给客户带来的用户体验特别的不好。就像别人总结的singleTask模式的Activity不管是位于栈顶还是栈底，再次运行这个Activity时，都会destory掉它上面的Activity来保证整个栈中只有一个自己。 下面是官方文档中的介绍: The system creates a new task and instantiates the activity at the root of the new task. However, if an instance of the activity already exists in a separate task, the system routes the intent to the existing instance through a call to its onNewIntent() method, rather than creating a new instance. Only one instance of the activity can exist at a time. 以singleTask方式启动的Activity，全局只有唯一个实例存在，因此，当我们第一次启动这个Activity时，系统便会创建一个新的任务栈，并且初始化一个Activity实例，放在新任务栈的底部，如果下次再启动这个Activity时， 系统发现已经存在这样的Activity实例，就会调用这个Activity实例的onNewIntent方法，从而把它激活起来。从这句话就可以推断出，以singleTask方式启动的Activity总是属于一个任务栈的根Activity。 下面我们看一下示例图: 坑爹啊！有木有！前面刚说singleTask会在新的任务中运行，并且位于任务堆栈的底部，这里在Task B中，一个赤裸裸的带着singleTask标签的箭头无情地指向Task B堆栈顶端的Activity Y，什么鬼？这其实是和taskAffinity有关，在将要启动时，系统会根据要启动的Activity的taskAffinity属性值在系统中查找这样的一个Task：Task的affinity属性值与即将要启动的Activity的taskAffinity属性值一致。如果存在，就返回这个Task堆栈顶端的Activity回去，不重新创建任务栈了，再去启动另外一个singletask的activity时就会在跟它有相同taskAffinity的任务中启动，并且位于这个任务的堆栈顶端，于是，前面那个图中，就会出现一个带着singleTask标签的箭头指向一个任务堆栈顶端的Activity Y了。在上面的AndroidManifest.xml文件中，没有配置MainActivity和SubActivity的taskAffinity属性，于是它们的taskAffinity属性值就默认为父标签application的taskAffinity属性值，这里，标签application的taskAffinity也没有配置，于是它们就默认为包名。总的来说：singleTask的结论与android:taskAffinity相关： 设置了singleTask启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的任务栈的存在；如果存在这样的任务栈，它就会在这个任务栈中启动，否则就会在新任务栈中启动。因此，如果我们想要设置了singleTask启动模式的Activity在新的任务栈中启动，就要为它设置一个独立的taskAffinity属性值。以A启动B来说当A和B的taskAffinity相同时：第一次创建B的实例时，并不会启动新的task，而是直接将B添加到A所在的task；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。 如果设置了singleTask启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。以A启动B来说,当A和B的taskAffinity不同时：第一次创建B的实例时，会启动新的task，然后将B添加到新建的task中；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。 singleInstance顾名思义，是单一实例的意思，即任意时刻只允许存在唯一的Activity实例，而且该Activity所在的task不能容纳除该Activity之外的其他Activity实例！它与singleTask有相同之处，也有不同之处。相同之处：任意时刻，最多只允许存在一个实例。不同之处： singleTask受android:taskAffinity属性的影响，而singleInstance不受android:taskAffinity的影响。 singleTask所在的task中能有其它的Activity，而singleInstance的task中不能有其他Activity。 当跳转到singleTask类型的Activity，并且该Activity实例已经存在时，会删除该Activity所在task中位于该Activity之上的全部Activity实例；而跳转到singleInstance类型的Activity，并且该Activity已经存在时，不需要删除其他Activity，因为它所在的task只有该Activity唯一一个Activity实例。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android应用发布","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Android应用发布/","text":"Android应用发布需要身份证扫描件、手持身份证正面照、图标(96x96、512x512)、应用截图(一般480x800,6张)进行每个网站的开发者注册(需要审核，有的比较慢，尽量提前审核) GooglePlay自动审核，速度很快，但是要上缴25刀 腾讯开发平台史上最好，没有之一、快、大，腾讯帝国根深蒂固 淘宝手机助手很快，每次他都是首发…，但是需要jpg格式的截图和图标，十八罗汉速度非凡 360应用开发平台实力不容小视,但是对广告审核很严，感觉不是很好 百度开发者中心(关联安卓及91)这个不多说了，都是泪，各种麻烦、各种慢、各种不合理，众里寻他千百度，他想几度就几度 安卓市场特别慢，百度上了，他各种理由不给上。 91慢，不说了，三家市场不如别人一家 豌豆荚开发者中心还不错,账号用了手机号 安智市场账号不是邮箱，而是账号名,不支持广告 机锋必须用机锋的广告，太霸道了 木蚂蚁需要在有米广告中加入木蚂蚁的渠道号 小米 优亿市场账号是用户名不是邮箱 10086密码最后一位是* 魅族风格独特要做适配 易用汇 天翼开发平台 易优市场 安极市场 3G安卓市场 N多市场 安卓星空 搜狐应用市场账号为搜狐邮箱 沃商城 做死系列 应用汇貌似已经不收录个人应用，也不说明一下，等你提交后就说不收录该类内容 网讯安卓应用市场(要软件著作权，不然通过不了) 联想很难发布，他会把你定位成劣质应用，好吧，劣质公司，你看你吧ThinkPad弄成什么样了 华为不收录个人应用 网易灰常垃圾，等你全部弄好后还要加他QQ让他审核，完了他会告诉你我们不接受个人应用，不做死就不会死 京东不好好卖东西，整个应用市场，又没人管理 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android开发不申请权限来使用对应功能","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Android开发不申请权限来使用对应功能/","text":"Android开发不申请权限来使用对应功能从用户角度来说很难获取到正确的android权限。通常你只需要做一些很基础的事(例如编辑一个联系人)但实际你申请的权限却远远比这更强大(例如可以获取到所有的联系人明细等)。 这样能很容易的理解到用户会怀疑到你的应用。如果你的应用不是开源的，那他们就没有方法来验证你会不会下载所有的联系人数据并上传到服务器。及时你去解释为什么需要这个权限，但是人们不会相信你。原来我会选择不去使用这些敏感的权限来防止用户产生不信任。(当然很多应用他们申请权限只是为了后台获取你的联系人数据上传- -!以及之前被爆的某宝使用摄像头拍照的问题) 这就是说，有一件事在困扰着我，如何能在做一些操作时不去申请权限。 打个比方说:android.permission.CALL_PHONE这个权限。你需要它来在应用中拨打电话，是吗？这就是你怎么去实现拨号的吗？123Intent intent = new Intent(Intent.ACTION_CALL);intent.setData(Uri.parse(\"tel:1234567890\"))startActivity(intent); 错！，你通过这段代码需要该权限的原因是因为你可以在任何时间在不需要用户操作的情况下打电话。也就是说如果我的应用申请了这个权限，我可以在你不知情的情况下每天凌晨三点去拨打骚扰电话。 正确的方式是使用ACTION_VIEW或者ACTION_DIAL:123Intent intent = new Intent(Intent.ACTION_DIAL);intent.setData(Uri.parse(\"tel:1234567890\"))startActivity(intent); 这个问题的完美解决方案就是不需要申请权限了。原因就是你不是直接拨号，而是用指定的号码调起拨号器，仍然需要用户点击”拨号”来开始打电话。老实的说，这样让人感觉更好。 简单的说就是如果我想要的操作不是让用户在应用内点击某个按钮就直接开始拨打电话，而是让用户点击在应用内点击某个按钮是我们去调起拨号程序，并且显示指定号码，让用户在拨号器中点击拨号后再开始拨打电话。这样的话我们就完全不用申请拨号权限了。 另一个例子: 我想获取某一个联系人的号码，你可能会想这需要申请获取所有联系人的权限。这是错的！。123Intent intent = new Intent(Intent.ACTION_PICK);intent.setType(StructuredPostal.CONTENT_TYPE);startActivityForResult(intent, 1); 我们可以使用上面的代码，来启动联系人管理器，让用户来选择某一个联系人。这样不仅是不需要申请任何权限，也不需要提供任何联系人相关的UI。这样也能完全保证你选择联系人时的体验。 Android系统最酷的部分之一就是Intent系统，这意味着我不需要自己来实现所有的东西。应用可以注册处理它所擅长的指定数据，像电话号码、短信或者联系人。如果这些都要自己在一个应用中去实现，那这将会是很大的工作量，也会让应用变得臃肿。 Android系统的另一个优势就是你可以使用其他应用申请的权限，而不用自己申请。这样才保证了上面的情况。拨号器需要申请拨打电话的权限，我只需要一个能调起拨号器的Intent就好了。用户信任拨号器拨打电话，而不是我们的应用。他们无论如何都宁愿使用系统的拨号器。 写这篇文章的意义是在你想要申请一个权限的时候，你需要至少看看Intent的官方文档看能否请求另外一个应用来帮我们做这些操作。如果想要深入的研究，可以学习下关于权限的详细介绍，这里面包含了很多精细的权限。 使用更少的权限可以不但可以让用户更加信任你，而且可以让用户有一个更好的体验，因为他们仍然在使用他们所期望的应用。 遗憾的是，不是一个真实的号码。 不幸的是，Intent系统的属性也建立了可能会被滥用的漏洞，但你也不会写一个滥用的应用，是吗？ (译)感谢Dan Lew 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android开发中的MVP模式详解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Android开发中的MVP模式详解/","text":"Android开发中的MVP模式详解MVC、MVP、MVVM介绍 在Android开发中，如果不注重架构的话，Activity类就会变得愈发庞大。这是因为在Android开发中View和其他的线程可以共存于Activity内。那最大的问题是什么呢？ 其实就是Activity中同时存在业务逻辑和UI逻辑。这导致增加了单元测试和维护的成本。 这就是为什么要清晰架构的原因之一。不仅是因为Activity类变得臃肿，也是其他的一些问题，例如Activity和Fragment相结合时的生命周期、数据绑定等等。 ###MVP简介 MVP(Model,View,Presenter) View：负责处理用户时间和视图展现。在Android中就可能是Activity或者Fragment。 Model： 负责数据访问。数据可以是从接口或者本地数据库中获取。 Presenter: 负责连接View和Model。 用一句话来说:MVP其实就是面向接口编程，V实现接口，P使用接口。 清晰的架构: 举个栗子:在Android Studio中新建一个Activity，系统提供了LoginActivity，直接用它是极好的。 不得不说，Material Design的效果真是美美哒！ 好，那我们就用用户登录页来按照MVP的模式实现一下: M: 很显然Model应该是User类。 V: View就是LoginActivity。 P: P那我们一会就创建一个LoginPresenter类。 齐了，那接下来就详细分析下他们这三部分: User: 应该有email, password, boolean login(email, password)。 LoginActivity:点击登录应该要出loading页。登录成功后要进入下一个页面。如果登录失败应该弹toast提示。那就需要void showLoading()，void hideLoading()，void showErrorTip(),void doLoginSuccess()这四个方法。 LoginPresenter:这是Model和View的桥梁。他需要做的处理业务逻辑，直接与Model打交道，然后将UI的逻辑交给LoginActivity处理。那怎么做呢？ 按照我上面总结的那一句话，、MVP其实就是面向接口编程，V实现接口，P使用接口。很显然我们需要提供一个接口。那就新建一个ILoginView的接口。这里面有哪些方法呢？ 当然是上面我们在分析LoginActiity时提出的那四个方法。这样LoginActivity直接实现ILoginView接口就好。 开始做: 先把Model做好吧，创建User类。 1234567891011121314public class User &#123; private String email; private String password; public User(String email, String password) &#123; this.email = email; this.password = password; &#125; public boolean login() &#123; // do login request.. return true; &#125;&#125; 创建ILoginView接口，定义登录所需要的ui逻辑。 123456public interface ILoginView &#123; void showLoading(); void hideLoading(); void showErrorTip(); void doLoginSuccess();&#125; 创建LoginPresenter类，使用ILoginView接口，那该类主要有什么功能呢？ 它主要是处理业务逻辑的， 对于登录的话，当然是用户在UI页面输入邮箱和密码，然后Presenter去开线程、请求接口。然后得到登录结果再去让UI显示对应的视图。那自然就是有一个void login(String email, String passowrd)的方法了 12345678910111213141516171819202122232425262728293031323334public class LoginPresenter &#123; private ILoginView mLoginView; public LoginPresenter(ILoginView loginView) &#123; mLoginView = loginView; &#125; public void login(String email, String password) &#123; if (TextUtils.isEmpty(email) || TextUtils.isEmpty(password)) &#123; // mLoginView.showErrorTip(); return; &#125; mLoginView.showLoading(); User user = new User(email, password); // do network request.... // .... onSuccess() &#123; boolean login = user.login(); if (login) &#123; mLoginView.doLoginSuccess(); &#125; else &#123; mLoginView.showErrorTip(); &#125; mLoginView.hideLoading(); &#125; onFailde() &#123; mLoginView.showErrorTip(); mLoginView.hideLoading(); &#125; &#125;&#125; 创建LoginActivity，实现ILoginView的接口，然后内部调用LoginPresenter来处理业务逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class LoginActivity extends AppCompatActivity implements ILoginView &#123; private LoginPresenter mLoginPresenter; private AutoCompleteTextView mEmailView; private EditText mPasswordView; private View mProgressView; private View mLoginButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); mEmailView = (AutoCompleteTextView) findViewById(R.id.email); mPasswordView = (EditText) findViewById(R.id.password); mLoginButton = findViewById(R.id.email_sign_in_button); mProgressView = findViewById(R.id.login_progress); mLoginPresenter = new LoginPresenter(this); mLoginButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mLoginPresenter.login(mEmailView.getText().toString().trim(), mPasswordView.getText().toString().trim()); &#125; &#125;); &#125; @Override public void showLoading() &#123; mProgressView.setVisibility(View.VISIBLE); &#125; @Override public void hideLoading() &#123; mProgressView.setVisibility(View.GONE); &#125; @Override public void showErrorTip() &#123; Toast.makeText(this, \"login faled\", Toast.LENGTH_SHORT).show(); &#125; @Override public void doLoginSuccess() &#123; Toast.makeText(this, \"login success\", Toast.LENGTH_SHORT).show(); &#125;&#125; 上面只是抛砖引玉。MVP的有点十分明显，就是代码解耦、可以让逻辑清晰，但是同样它也会有缺点，它的缺点就是项目的复杂程度会增加，项目中会多出很多类。之前很多人都在讨论该如何去正确的设计使用MVP来避免它的缺点，众说纷纭，很多人讨论的你死我活。直到Google发布了MVP架构蓝图，大家才意识到这才是规范。 项目地址:android-architectureGoogle将该项目命名为Android的架构蓝图，我想从名字上已可以看穿一切。 在它的官方介绍中是这样说的: The Android framework offers a lot of flexibility when it comes to defining how to organize and architect an Android app. This freedom, whilst very valuable, can also result in apps with large classes, inconsistent naming and architectures (or lack of) that can make testing, maintaining and extending difficult. Android Architecture Blueprints is meant to demonstrate possible ways to help with these common problems. In this project we offer the same application implemented using different architectural concepts and tools. You can use these samples as a reference or as a starting point for creating your own apps. The focus here is on code structure, architecture, testing and maintainability. However, bear in mind that there are many ways to build apps with these architectures and tools, depending on your priorities, so these shouldn’t be considered canonical examples. The UI is deliberately kept simple. 已完成的示例: todo-mvp/ - Basic Model-View-Presenter architecture. todo-mvp-loaders/ - Based on todo-mvp, fetches data using Loaders. todo-mvp-databinding/ - Based on todo-mvp, uses the Data Binding Library. todo-mvp-clean/ - Based on todo-mvp, uses concepts from Clean Architecture. todo-mvp-dagger/ - Based on todo-mvp, uses Dagger2 for Dependency Injection todo-mvp-contentproviders/ - Based on todo-mvp-loaders, fetches data using Loaders and uses Content Providers todo-mvp-rxjava/ - Based on todo-mvp, uses RxJava for concurrency and data layer abstraction. 我们接下来就用todo-mvp来进行分析，这个应用非常简单，主要有以下几个功能: 列表页:展示所有的todo项 添加页:添加todo项 详情页:查看todo项的详情 统计页:查看当前所有已完成todo及未完成项的统计数据 代码并不多: 功能也比较简单: 我们先从两个Base类开始看，分别是BaseView以及BasePresenter类。 BaseView类: 12345public interface BaseView&lt;T&gt; &#123; void setPresenter(T presenter);&#125; BaseView中的setPresenter()是将Presenter的实例传入到View中。BasePresenter类:12345public interface BasePresenter &#123; void start();&#125; BasePresenter中只有一个start()方法，从名字上我们就能看出他的作用。 接下来继续看一下项目的入口Activity，TaskDetailActivity的实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TaskDetailActivity extends AppCompatActivity &#123; public static final String EXTRA_TASK_ID = \"TASK_ID\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.taskdetail_act); // Set up the toolbar. Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); ActionBar ab = getSupportActionBar(); ab.setDisplayHomeAsUpEnabled(true); ab.setDisplayShowHomeEnabled(true); // Get the requested task id String taskId = getIntent().getStringExtra(EXTRA_TASK_ID); TaskDetailFragment taskDetailFragment = (TaskDetailFragment) getSupportFragmentManager() .findFragmentById(R.id.contentFrame); if (taskDetailFragment == null) &#123; // 创建对应的Fragment taskDetailFragment = TaskDetailFragment.newInstance(taskId); ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), taskDetailFragment, R.id.contentFrame); &#125; // Create the presenter，因为Presenter是M和V的连接桥，所以在第二个参数中会传入TasksRepository new TaskDetailPresenter( taskId, Injection.provideTasksRepository(getApplicationContext()), taskDetailFragment); &#125; @Override public boolean onSupportNavigateUp() &#123; onBackPressed(); return true; &#125;&#125; 可以看到这里Activity相当于一个管理类，里面控制着MVP中的V和P,上面的代码主要做了两部分: 创建对应的Fragment 创建对应的Presenter 这里分别看一下TaskDetailFragment和TaskDetailPresenter的源码:123456789101112131415161718192021222324252627282930313233public class TaskDetailFragment extends Fragment implements TaskDetailContract.View &#123; private TaskDetailContract.Presenter mPresenter; public static TaskDetailFragment newInstance(@Nullable String taskId) &#123; Bundle arguments = new Bundle(); arguments.putString(ARGUMENT_TASK_ID, taskId); TaskDetailFragment fragment = new TaskDetailFragment(); fragment.setArguments(arguments); return fragment; &#125; @Override public void onResume() &#123; super.onResume(); // 调用Presenter.start()方法 mPresenter.start(); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; .... &#125; @Override public void setPresenter(@NonNull TaskDetailContract.Presenter presenter) &#123; // 将Prsenter传递给V中 mPresenter = checkNotNull(presenter); &#125; ....&#125; 及1234567891011121314151617181920212223242526public class TaskDetailPresenter implements TaskDetailContract.Presenter &#123; private final TasksRepository mTasksRepository; private final TaskDetailContract.View mTaskDetailView; @Nullable private String mTaskId; // 把M和V传递进来 public TaskDetailPresenter(@Nullable String taskId, @NonNull TasksRepository tasksRepository, @NonNull TaskDetailContract.View taskDetailView) &#123; mTaskId = taskId; mTasksRepository = checkNotNull(tasksRepository, \"tasksRepository cannot be null!\"); mTaskDetailView = checkNotNull(taskDetailView, \"taskDetailView cannot be null!\"); // 将该Presenter设置给V mTaskDetailView.setPresenter(this); &#125; @Override public void start() &#123; // 调用获取数据的方法 openTask(); &#125; ....&#125; 可以看到上面分别实现了TaskDetailContract类中的Presenter和View接口，而不是BasePresenter和BaseView中的接口，那这个TaskDetailContract类是什么呢？12345678910111213141516171819202122232425262728293031323334353637383940414243/** * This specifies the contract between the view and the presenter. */public interface TaskDetailContract &#123; interface View extends BaseView&lt;Presenter&gt; &#123; void setLoadingIndicator(boolean active); void showMissingTask(); void hideTitle(); void showTitle(String title); void hideDescription(); void showDescription(String description); void showCompletionStatus(boolean complete); void showEditTask(String taskId); void showTaskDeleted(); void showTaskMarkedComplete(); void showTaskMarkedActive(); boolean isActive(); &#125; interface Presenter extends BasePresenter &#123; void editTask(); void deleteTask(); void completeTask(); void activateTask(); &#125;&#125; 按照上面描述的介绍可以看出通过这个连接类将VP联系到了一起，它统一管理view和presenter中的所有接口，这样比起分开写会更加清晰。 分析完VP之后我们继续看一下TaskDetailPresenter类，因为Presenter是MV的桥梁。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public TaskDetailPresenter(@Nullable String taskId, @NonNull TasksRepository tasksRepository, @NonNull TaskDetailContract.View taskDetailView) &#123; mTaskId = taskId; mTasksRepository = checkNotNull(tasksRepository, \"tasksRepository cannot be null!\"); mTaskDetailView = checkNotNull(taskDetailView, \"taskDetailView cannot be null!\"); mTaskDetailView.setPresenter(this); &#125; @Override public void start() &#123; openTask(); &#125; private void openTask() &#123; if (Strings.isNullOrEmpty(mTaskId)) &#123; mTaskDetailView.showMissingTask(); return; &#125; // 控制V显示UI mTaskDetailView.setLoadingIndicator(true); // 通过M去获取数据 mTasksRepository.getTask(mTaskId, new TasksDataSource.GetTaskCallback() &#123; @Override public void onTaskLoaded(Task task) &#123; // The view may not be able to handle UI updates anymore if (!mTaskDetailView.isActive()) &#123; return; &#125; mTaskDetailView.setLoadingIndicator(false); if (null == task) &#123; mTaskDetailView.showMissingTask(); &#125; else &#123; showTask(task); &#125; &#125; @Override public void onDataNotAvailable() &#123; // The view may not be able to handle UI updates anymore if (!mTaskDetailView.isActive()) &#123; return; &#125; mTaskDetailView.showMissingTask(); &#125; &#125;); &#125; 在它的构造函数中传入了一个TasksRepository，这个就是Model层。而在该Presenter中的start()方法回去调用获取数据的方法。 我们继续看一下M层TasksRepository的实现:12345678910/** * Concrete implementation to load tasks from the data sources into a cache. * &lt;p&gt; * For simplicity, this implements a dumb synchronisation between locally persisted data and data * obtained from the server, by using the remote data source only if the local database doesn't * exist or is empty. */public class TasksRepository implements TasksDataSource &#123; ....&#125; 先看一下TasksDataSource接口: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Main entry point for accessing tasks data. * &lt;p&gt; * For simplicity, only getTasks() and getTask() have callbacks. Consider adding callbacks to other * methods to inform the user of network/database errors or successful operations. * For example, when a new task is created, it's synchronously stored in cache but usually every * operation on database or network should be executed in a different thread. */public interface TasksDataSource &#123; interface LoadTasksCallback &#123; void onTasksLoaded(List&lt;Task&gt; tasks); void onDataNotAvailable(); &#125; interface GetTaskCallback &#123; void onTaskLoaded(Task task); void onDataNotAvailable(); &#125; void getTasks(@NonNull LoadTasksCallback callback); void getTask(@NonNull String taskId, @NonNull GetTaskCallback callback); void saveTask(@NonNull Task task); void completeTask(@NonNull Task task); void completeTask(@NonNull String taskId); void activateTask(@NonNull Task task); void activateTask(@NonNull String taskId); void clearCompletedTasks(); void refreshTasks(); void deleteAllTasks(); void deleteTask(@NonNull String taskId);&#125; 可以看出M层被赋予了数据获取的功能，与之前我们写的M层只定义实体对象截然不同，数据的增删改查都是M层实现的。Presenter只需要调用M层的方法即可。这样model、presenter、view都只处理各自的任务，此种实现确实是单一职责最好的诠释。 这里我们就以上面用到的getTasks()方法为例来介绍一下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void getTask(@NonNull final String taskId, @NonNull final GetTaskCallback callback) &#123; checkNotNull(taskId); checkNotNull(callback); // 从缓存中获取数据 Task cachedTask = getTaskWithId(taskId); // Respond immediately with cache if available if (cachedTask != null) &#123; callback.onTaskLoaded(cachedTask); return; &#125; // Load from server/persisted if needed. // Is the task in the local data source? If not, query the network. mTasksLocalDataSource.getTask(taskId, new GetTaskCallback() &#123; @Override public void onTaskLoaded(Task task) &#123; // Do in memory cache update to keep the app UI up to date if (mCachedTasks == null) &#123; mCachedTasks = new LinkedHashMap&lt;&gt;(); &#125; mCachedTasks.put(task.getId(), task); callback.onTaskLoaded(task); &#125; @Override public void onDataNotAvailable() &#123; // 服务器的数据源 mTasksRemoteDataSource.getTask(taskId, new GetTaskCallback() &#123; @Override public void onTaskLoaded(Task task) &#123; // Do in memory cache update to keep the app UI up to date if (mCachedTasks == null) &#123; mCachedTasks = new LinkedHashMap&lt;&gt;(); &#125; mCachedTasks.put(task.getId(), task); callback.onTaskLoaded(task); &#125; @Override public void onDataNotAvailable() &#123; callback.onDataNotAvailable(); &#125; &#125;); &#125; &#125;); &#125; 上面的注释说的非常明白了，这里就不去仔细看了。 下面用一张图来总结一下: 由于架构的引入，虽然代码量有了一定的上升，但是功能分离的非常清晰明确，而且每个部分都可以进行单独的测试，对于后期的扩展维护会更加简单容易。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android开发工具及类库","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Android开发工具及类库/","text":"Android开发工具及类库在项目开发过程中，总有一些必要的工具和类库。下面就简单介绍下我常用的一些(还在用Eclipse的请无视)。 volley在Google I/0 2013中发布了Volley.Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮。这是Volley名称的由来:a burst or emission of many things or a large amount at once.Volley特别适合数据量不大但是通信频繁的场景。Github上面已经有大神做了镜像，使用更方便有木有。Volley On Github GsonJson转换神器。 GsonFormat既然用了Gson怎么能少了该神器呢？ android-butterknife-zelezny使用butterknife制作的Android Studio/IDEA插件。非常方便有木有。 android-selector-chapekselector写起来是不是很麻烦？以后让UI规范化命名，然后就没有然后了。接下来你就会在drawable目录发现对应的selector文件。 leakcanary内存泄漏你怕不怕？ fresco怎么能少了对图片的处理呢？Fracebook出品。更快、更强、更方便。 android-resource-remover 开发过程中可能会经常遇到需求的变更，时间长了，项目中的无用资源就会越来越多。 虽然在Gradle中支持相应的配置来去除无用资源: 12345678910111213141516buildTypes &#123; debug &#123; minifyEnabled false zipAlignEnabled false shrinkResources false &#125; release &#123; zipAlignEnabled true // remove unused resources shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release &#125; &#125; 但是这只是在打包的时候不会打进去无用的资源，但是这些资源还是会在工程中。 那我们怎么能快速的移除掉这些无用资源呢？答案也很简单，就是使用`lint`检查出无用的资源后用工具删除，这个工具就是`android-resource-remover`。 因为它是一个`python`脚本，所以如果不懂`python`的话使用起来会比较麻烦，下面就介绍一下具体的使用方法: - 下载并安装`Python 2.x`版本 去[Python](https://www.python.org/)下载后即可，这里要下载2.x版本，因为3.x版本对语法做了很多改动，可能会不兼容，下载完成后安装就可。安装完成后将安装路径加入到`Path`中。如`D:\\Python;`。 - 安装`android-resource-remover` 在命令行输入下面的命令`pip install android-resource-remover`。 这里有些电脑可能会提示错误，是因为没有安装`pip`导致的，具体可以看[pip](https://pip.pypa.io/en/latest/installing.html)找到安装的方法。上面介绍了要下载`get-pip.py`后执行`python get-pip.py`就能安装了。 - 将`D:\\Python\\Scripts`添加到`Path`中。 - 将`lint`命令添加到`Path`中，`D:\\android-sdk-windows\\tools`. - 在`Studio`右侧的`Gradle`窗口中执行`lint`任务。 这样就会在`app/build/outputs`下生成`lint-results.xml`文件。下一步清理的时候需要使用`lint-results.xml`文件。 ![Image](https://raw.githubusercontent.com/CharonChui/Pictures/master/lint.png?raw=true) - 进入到`Android Studio`中的具体项目中执行`./gradlew clean`后再执行`./gradlew lint &amp;&amp; android-resource-remover --xml app/build/outputs/lint-results.xml` stetho facebook出品。快速查看布局、数据库、网络请求。实在不能再方便了。 RxJava用了后你会爱上它。 RetrofiltSquare出品。大神JakeWharton主导出品的网络请求框架。内部结合OkHttp。结合RxJava使用非常方便。 android-architecture放到这里可能不太合适，因为它并不是工具和类库，而是Google官方发布的Android架构示例。非常值得参考。 AndroidWiFiADB还在为数据线不够用而烦恼嘛? 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"ApplicationId vs PackageName","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/ApplicationId vs PackageName/","text":"ApplicationId vs PackageName曾几何时，自从转入Studio阵营后就发现多了个applicationId &quot;com.xx.xxx&quot;，虽然知道肯定会有区别，但是我却没有仔细去看，只想着把它和packageName设置成相同即可(原谅我的懒惰- -!)。 直到今天在官网看Gradle使用时，终于忍不住要搞明白它俩的区别。 在Android官方文档中有一句是这样描述applicationId的:applicationId : the effective packageName，真是言简意赅，那既然applicationId是有效的包明了，packageName算啥？ 所有Android应用都有一个包名。包名在设备上能唯一的标示一个应用，它在Google Play应用商店中也是唯一的。这就意味着一旦你使用一个包名发布应用后，你就永 远不能改变它的包名；如果你改了包名就会导致你的应用被认为是一个新的应用，并且已经使用你之前应用的用户将不会看到作为更新的新应用包。 之前的Android Gradle构建系统中，应用的包名是由你的manifest文件中的根元素中的package属性定义的: AndroidManifest.xml: 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.my.app&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; &gt; 然而，这里定义的包也有第二个目的：就是被用来命名你的R资源类(以及解析任何与Activities相关的类名)的包。在上面的示例中，生成的R类就是com.example.my.app.R，所以如果你在其他的包中想引用资源，就需要导入com.example.my.app.R。 伴随着新的Android Gradle构建系统，你可以很简单的为你的应用构建多个不同的版本；例如，你可以同时为你的应用构建一个免费版本和一个专业版(使用flavors)，并且他们应该在Google Play商店中有不同的包，这样才能让他们可以被单独安装和购买，同时安装两个，等等。同样的你也可能同时为你的应用构建debug版、alpha版和beta版(使用build types)，这些也可以同样使用不同的包名。 在这同时，你在代码中导入的R类必须一直保持一直；在为应用构建不同的版本时.java源文件都不应该发生变化。 因此,我们解耦了package name的两种用法: 在生成的.apk中的manifest文件中使用的最终的包名以及在你的设备和Google Play商店中用来标示你的包名叫做application id的值。 在源代码中指向R类的包名以及在解析任何与activity/service注册相关的包名继续叫做package name。 可以在gradle文件中像如下指定application id: app/build.gradle: 1234567891011121314apply plugin: &apos;com.android.application&apos;android &#123; compileSdkVersion 19 buildToolsVersion &quot;19.1&quot; defaultConfig &#123; applicationId &quot;com.example.my.app&quot; minSdkVersion 15 targetSdkVersion 19 versionCode 1 versionName &quot;1.0&quot; &#125; ... 像之前一样，你需要在Manifest文件中指定你在代码中使用的’package name’，像上面AndroidManifest.xml的例子。下面进入关键部分了：当你按照上面的方式做完后，这两个包就是相互独立的了。你现在可以很简单的重构你的代码-通过修改Manifest中的包名来修改在你的activitise和services中使用的包和在重构你在代码中的引用声明。这不会影响你应用的最终id，也就是在Gradle文件中的applicationId。 你可以通过以下Gradle DSL方法为应用的flavors和build types指定不同的applicationId: app/buid.gradle: 123456789101112131415productFlavors &#123; pro &#123; applicationId = &quot;com.example.my.pkg.pro&quot; &#125; free &#123; applicationId = &quot;com.example.my.pkg.free&quot; &#125;&#125;buildTypes &#123; debug &#123; applicationIdSuffix &quot;.debug&quot; &#125;&#125;.... (在Android Studio中你也可以通过图形化的Project Structure的对话框来更改上面所有的配置) 注意:为了兼容性，如果你在build.gradle文件中没有定义applicationId ，那applicationId就是与AndroidManifest.xml中配置的包名相同的默认值。在这种情况下，这两者显然脱不了干系，如果你试图重构代码中的包就将会导致同时会改变你应用程序的id！在Android Studio中新创建的项目都是同时指定他们俩。 注意2:package name必须在默认的AndroidManifest.xml文件中指定。如果有多个manifest文件(例如对每个flavor制定一个manifest或者每个build type制定一个manifest)时，package name是可选的，但是如果你指定的话，它必须与主manifest中指定的pakcage相同。 邮箱 ：charon.chui@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"BroadcastReceiver安全问题","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/BroadcastReceiver安全问题/","text":"BroadcastReceiver安全问题BroadcastReceiver设计的初衷是从全局考虑可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的(恶意程序脚本不断的去发送你所接收的广播) 保证发送的广播要发送给指定的对象 当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission或通过Intent.setPackage设置广播仅对某个程序有效。 保证我接收到的广播室指定对象发送过来的 当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=&quot;false&quot;属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。 android.support.v4.content.LocalBroadcastManager工具类，可以实现在自己的进程内进行局部广播发送与注册，使用它比直接通过sendBroadcast(Intent)发送系统全局广播有以下几个好处： 因广播数据在本应用范围内传播，你不用担心隐私数据泄露的问题。 不用担心别的应用伪造广播，造成安全隐患。 相比在系统内发送全局广播，它更高效。 123456789101112131415161718192021222324252627 LocalBroadcastManager mLocalBroadcastManager; BroadcastReceiver mReceiver; @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); IntentFilter filter = new IntentFilter(); filter.addAction(\"test\"); mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(\"test\")) &#123; //Do Something &#125; &#125; &#125;; mLocalBroadcastManager = LocalBroadcastManager.getInstance(this); mLocalBroadcastManager.registerReceiver(mReceiver, filter);&#125;@Overrideprotected void onDestroy() &#123; mLocalBroadcastManager.unregisterReceiver(mReceiver); super.onDestroy();&#125; 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Gradle专题","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Gradle专题/","text":"Gradle专题随着Google对Eclipse的无情抛弃以及Studio的不断壮大，Android开发者逐渐拜倒在Studio的石榴裙下。而作为Studio的默认编译方式，Gradle已逐渐普及。我最开始是被它的多渠道打包所吸引。关于多渠道打包，请看之前我写的文章AndroidStudio使用教程(第七弹).md) 接下来我们就系统的学习一下Gradle。 简介Gradle是以Groovy语言为基础，面向Java应用为主。基于DSL(Domain Specific Language)语法的自动化构建工具。 Gradle集合了Ant的灵活性和强大功能，同时也集合了Maven的依赖管理和约定，从而创造了一个更有效的构建方式。凭借Groovy的DSL和创新打包方式，Gradle提供了一个可声明的方式，并在合理默认值的基础上描述所有类型的构建。 Gradle目前已被选作许多开源项目的构建系统。 因为Gradle是基于DSL语法的，如果想看到build.gradle文件中全部可以选项的配置，可以看这里DSL Reference 基本的项目设置一个Gradle项目通过一个在项目根目录中的build.gradle文件来描述它的构建。 ###简单的Build文件 最简单的Android应用中的build.gradle都会包含以下几个配置：Project根目录的build.gradle: 1234567891011buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.5.0&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; Module中的build.gradle: 1234567apply plugin: &apos;com.android.application&apos;android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.3&quot; ...&#125; buildscript { ... }配置了编译时的代码驱动. 这种情况下，它声明所使用的是jCenter仓库。还有一个声明所依赖的在Maven文件的路径。这里声明的包含了Android插件所使用的1.5.0版本的Gradle. 注意:这只会影响build中运行的代码，不是项目中。项目中需要声明它自己所需要仓库和依赖关系。 apply plugin : com.android.application，声明使用com.androdi.application插件。这是构建Android应用所需要的插件。 android{...}配置了所有Android构建时的参数。默认情况下，只有编译的目标版本以及编译工具的版本是需要的。 重要: 这里只能使用com.android.application插件。如果使用java插件将会报错。 ###目录结构module/src/main下的目录结构，因为有时候很多人把so放到libs目录就会报错: java/ res/ AndroidManifest.xml assets/ aidl/ jniLibs/ jni/ rs/ ###配置目录结构如果项目的结构不标准的时候，可能就需要去配置它。Android插件使用了相似的语法，但是因为它有自己的sourceSets，所以要在android代码块中进行配置。下面就是一个从Eclipse的老项目结构中配置主要代码并且将androidTest的sourceSet设置给tests目录的例子: 123456789101112131415android &#123; sourceSets &#123; main &#123; manifest.srcFile &apos;AndroidManifest.xml&apos; java.srcDirs = [&apos;src&apos;] resources.srcDirs = [&apos;src&apos;] aidl.srcDirs = [&apos;src&apos;] renderscript.srcDirs = [&apos;src&apos;] res.srcDirs = [&apos;res&apos;] assets.srcDirs = [&apos;assets&apos;] &#125; androidTest.setRoot(&apos;tests&apos;) &#125;&#125; 就像有些人就是要把so放到libs目录中(这类人有点犟)，那就需要这样进行修改。注意:因为在旧的项目结构中所有的源文件(Java,AIDL和RenderScript)都放到同一个目录中，我们需要将sourceSet中的这些新部件都设置给src目录。 Build Tasks对构建文件声明插件时通常或自动创建一些列的构建任务去执行。不管Java插件还是Android插件都是这样。Android常规的任务如下： assemble生成项目output目录中的内容的任务。 check执行所有的检查的任务。 build执行assemble和check的任务。 clean清理项目output目录的任务。 在Android项目中至少会有两种output输出:一个debug apk和一个release apk。他们都有自己的主任务来分别执行构建: assemble assembleDebug assembleRelease 提示:Gradle支持通过命令行执行任务首字母缩写的方式。例如:在没有其他任务符合aR的前提下，gradle aR与gradle assembleRelease是相同的。 最后，构建插件创建了为所有build type(debug, release, test)类型安装和卸载的任务，只要他们能被安装(需要签名)。 installDebug installRelease uninstallAll uninstallDebug uninstallRelease uninstallDebugAndroidTest ###基本的Build定制 Android插件提供了一些列的DSL来让直接从构建系统中做大部分的定制。 #####Manifest整体部分DSL提供了很多重要的配置manifest文件的参数，例如: minSdkVersion targetSdkVersion versionCode versionName applicationId testApplicationId testInstrumentationRunnder Android Plugin DSL Reference提供了一个完整的构建参数列表。 把这些manifest属性放到build文件中的一个重要功能就是它可以被动态的设置。例如，可以通过读取一个文件或者其他逻辑来获取版本名称。 12345678910111213141516def computeVersionName() &#123; ...&#125;android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.1&quot; defaultConfig &#123; versionCode 12 versionName computeVersionName() minSdkVersion 16 targetSdkVersion 23 &#125;&#125; 注意:不要使用可能与现有给定冲突的方法名。例如defaultConfig{...}中使用getVersionName()方法将会自动使用defaultConfig.getVersionName()来带起自定义的方法。 #####Build Types 默认情况下Android插件会自动将应用程序设置成有一个debug版本和一个release版本。这就是通过调用BuildType对象完成。默认情况下会创建两个实例，一个debug实例和一个release实例。Android插件同样允许通过其他的Build Types来定制其他的实例。这就是通过buildTypes来设置的: 1234567891011121314android &#123; buildTypes &#123; debug &#123; applicationIdSuffix &quot;.debug&quot; &#125; jnidebug &#123; initWith(buildTypes.debug) applicationIdSuffix &quot;.jnidebug&quot; jniDebuggable true &#125; &#125;&#125; 上面的代码执行了以下操作: 配置了默认debug的Build Type: 设置了它的applicationId。这样debug模式就能与release模式的apk同时安装在同一手机上。 创建了一个新的jnidebug的Build Type，并且把它设置为debug的拷贝。 通过允许JNI组件的debug和增加一个新的包名后缀来继续定制该Build Type。 不管使用initWith()还是使用其他的代码块，创建一个新的Build Types都是非常简单的在buildTypes代码块中创建一个新的元素就可以了。 #####签名配置 为应用签名需要使用如下几个部分: A keystore A keystore password A key alias name A key password The store type 默认情况下有一个debug的配置，设置了一个debug的keystore，有一个已知的密码。debug keystore的位置是在$HOME/.android/debug.keystore，如果没有的话他会被默认创建。Debug的Build Type会默认使用该debug的签名设置。 当然也可以通过使用DSL语法中的signingconfigs部分来创建其他的配置来进行定制: 12345678910111213141516171819202122android &#123; signingConfigs &#123; debug &#123; storeFile file(&quot;debug.keystore&quot;) &#125; myConfig &#123; storeFile file(&quot;other.keystore&quot;) storePassword &quot;android&quot; keyAlias &quot;androiddebugkey&quot; keyPassword &quot;android&quot; &#125; &#125; buildTypes &#123; foo &#123; signingConfig signingConfigs.myConfig &#125; &#125;&#125; 上面的设置将把debug keystore的位置改为项目的根目录。同样也创建了一个新的签名配置，并且有一个新的Build Type使用它。 ###Dependencies, Android Libraries and Multi-project setup Gradle项目可以依赖其他的外部二进制包、或者其他的Gradle项目。 本地包想要配置依赖一个外部jar包，需要在compile的配置中添加一个dependency。下面的配置是添加了所有在libs目录的jar包: 12345678dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])&#125;android &#123; ...&#125; 注意:DSL元素中的dependencies是Gradle API中的标准元素。不属于andorid元素。compile配置是用来编译主应用的。它配置的所有部分都会被打包到apk中。当然也有一些其他的配置: compile: main application androidTestCompile:test application debugCompile:debug Build Type release Compile:release Build Type 当然我们可以使用compile和&lt;buildtype&gt;.compile这两种配置。创建一个新的Build Type通常会自动基于它的名字创建一个新的配置部分。这样在像debug版本而release版本不适用的一些特别的library时非常有用。 #####远程仓库 Gradle只是使用Maven和Ivy仓库。但是仓库必须要添加到列表中，并且必须声明所依赖仓库的Maven或者Ivy定义。 12345678910111213repositories &#123; jcenter()&#125;dependencies &#123; compile &apos;com.google.guava:guava:18.0&apos;&#125;android &#123; ...&#125; 注意: jcenter()是指定仓库URL的快捷设置。Gradle支持远程和本地仓库。注意: Gradle会直接识别所有的依赖关系。这就意味着如果一个依赖库自身又依赖别的库时，他们会被一起下下来。 #####本地AAR库 123dependencies &#123; compile(name:&apos;本地aar库的名字，不用加后缀&apos;, ext:&apos;aar&apos;)&#125; #####多项目设置 Gradle项目通常使用多项目设置来依赖其他的gradle项目。例如: MyProject/ app/ libraries/ lib1/ lib2/ Gradle会通过下面的名字来引用他们：:app:libraries:lib1:libraries:lib2 每个项目都会有一个单独的build文件，并且在项目的根目录还会有一个setting.gradle文件： MyProject/ settings.gradle app/ build.gradle libraries/ lib1/ build.gradle lib2/ build.gradle setting.gradle文件中的内容非常简单。它指定了哪个目录是Gralde项目:1include &apos;:app&apos;, &apos;:libraries:lib1&apos;, &apos;:libraries:lib2&apos; ：app这个项目可能会依赖其他的libraries，这样可以通过如下进行声明:123dependencies &#123; compile project(&apos;:libraries:lib1&apos;)&#125; ###Library项目 上面用到了:libraries:lib1和:libraries:lib2可以是Java项目，:app项目会使用他们俩的输出的jar包。但是如果你需要使用android资源等，这些libraries就不能是普通的Java项目了，他们必须是Android Library项目。 #####创建一个Library项目 Library项目和普通的Android项目的区别比较少，由于libraries的构建类型与应用程序的构建不同，所有它会使用一个别的构建插件。但是他们所使用的插件内部有很多相同的代码，他们都是由com.android.tools.build.gradle这个jar包提供的。 12345678910111213141516171819buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.3.1&apos; &#125;&#125;apply plugin: &apos;com.android.library&apos;android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.1&quot;&#125; #####普通项目与Library项目的区别 Library项目的主要输出我.aar包。它结合了代码(例如jar包或者本地.so文件)和资源(manifest,res,assets)。每个library也可以单独设置Build Type等来指定生成不同版本的aar。 ###Lint Support 你可以通过指定对应的变量来设置lint的运行。可以通过添加lintOptions来进行配置: 123456789101112android &#123; lintOptions &#123; // turn off checking the given issue id&apos;s disable &apos;TypographyFractions&apos;,&apos;TypographyQuotes&apos; // turn on the given issue id&apos;s enable &apos;RtlHardcoded&apos;,&apos;RtlCompat&apos;, &apos;RtlEnabled&apos; // check *only* the given issue id&apos;s check &apos;NewApi&apos;, &apos;InlinedApi&apos; &#125;&#125; ###Build变量 构建系统的一个目标就是能对同一个应用创建多个不同的版本。 #####Product flavors 一个product flavor可以针对一个项目制定不同的构建版本。一个应用可以有多个不同的falvors来改变生成的应用。Product flavors是通过DSL语法中的productFlavors来声明的: 123456789101112131415android &#123; .... productFlavors &#123; flavor1 &#123; ... &#125; flavor2 &#123; ... &#125; &#125;&#125; #####Build Type + Product Flavor = Build Variant 像我们之前看到的，每个Build Type都会生成一个apk.Product Flavors也是同样的：项目的输出僵尸所有Build Types与Product Flavors的结合。每种结合方式称之为Build Variant。例如，如果有debug和release版本的Build Types，上面的例子就会生成4种Build Variants： Flavor1 - debug Flavor1 - release Flavor2 - debug Flavor2 - release 没有配置flavors的项目仍然有Build Variants，它只是用了一个默认的flavor/config，没有名字，这导致variants的列表和Build Types的列表比较相同。 #####Product Flavor配置 1234567891011121314151617181920212223android &#123; ... defaultConfig &#123; minSdkVersion 8 versionCode 10 &#125; productFlavors &#123; flavor1 &#123; applicationId &quot;com.example.flavor1&quot; versionCode 20 &#125; flavor2 &#123; applicationId &quot;com.example.flavor2&quot; minSdkVersion 14 &#125; &#125;&#125; 注意android.productFlavors.*对象ProductFlavor有android.defaultConfig是相同的类型。这就意味着他们有相同的属性。defaultConfig为所有的flavors提供了一些基本的配置，每个flavor都已重写他们。在上面的例子中，这些配置有: flavor1 applicationId: com.example.flavor1 minSdkVersion: 8 versionCode: 20 flavor2 applicationId: com.example.flavor2 minSdkVersion: 14 versionCode: 10 通常，Build Type配置会覆盖其他的配置。例如，Build Type的applicationIdSuffix会添加到Product Flavor的applicationId上。 最后，就像Build Types一样，Product Flavors也可以有他们自己的依赖关系。例如，如果有一个单独的flavors会使用一些广告或者支付，那这个flavors生成的apk就会使用广告的依赖，而其他的flavors就不需要使用。123dependencies &#123; flavor1Compile &quot;...&quot;&#125; ###BuildConfig 在编译阶段，Android Studio会生成一个叫做BuildConfig的类，该类包含了编译时使用的一些变量的值。你可以观看这些值来改变不同变量的行为: 1234567private void javaCode() &#123; if (BuildConfig.FLAVOR.equals(&quot;paidapp&quot;)) &#123; doIt(); else &#123; showOnlyInPaidAppDialog(); &#125;&#125; 下面是BuildConfig中包含的一些值: boolean DEBUG - if the build is debuggable int VERSION_CODE String VERSION_NAME String APPLICATION_ID String BUILD_TYPE- Build Type的名字，例如release String FLAVOR - flavor的名字，例如flavor1 ###ProGuard配置 Android插件默认会使用ProGuard插件，并且如果Build Type中使用ProGuard的minifyEnabled属性开启的话，会默认创建对应的task。 12345678910111213141516android &#123; buildTypes &#123; release &#123; minifyEnabled true proguardFile getDefaultProguardFile(&apos;proguard-android.txt&apos;) &#125; &#125; productFlavors &#123; flavor1 &#123; &#125; flavor2 &#123; proguardFile &apos;some-other-rules.txt&apos; &#125; &#125;&#125; ###Tasks控制 基本的Java项目有一系列的tasks一起制作输出文件。classes task就是编译Java源码的任务。 我们可以在build.gradle中通过使用classes很简单的获取到它。就是project.tasks.classes. 在Android项目中，更多的编译task，因为他们的名字通过Build Types和Product Flavors生成。 为了解决这个问题，android对象有两种属性: applicationVariants - only for the app plugin libraryVariants - only for the library plugin testVariants - for both plugins这些都会返回一个ApplicationVariant, LibraryVariant,TestVariant的DomainObjectCollection接口的实现类对象。DomainObjectCollection提供了直接获取或者很方便的间接获取所有对象的方法。 123android.applicationVariants.all &#123; variant -&gt; ....&#125; ###设置编译语言版本 可以使用compileOptions代码块来设置编译时使用的语言版本。默认是基于compileSdkVersion的值。123456android &#123; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_6 targetCompatibility JavaVersion.VERSION_1_6 &#125;&#125; ###Resource Shrinking Gradle构建系统支持资源清理：对构建的应用会自动移除无用的资源。不仅会移除项目中未使用的资源，而且还会移除项目所以来的类库中的资源。注意，资源清理只能在与代码清理结合使用(例如ProGuad)。这就是为什么它能移除所依赖类库的无用资源。通常，类库中的所有资源都是使用的，只有类库中无用代码被移除后这些资源才会变成没有代码引用的无用资源。 1234567891011android &#123; ... buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125; 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Github个人主页绑定域名","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Github个人主页绑定域名/","text":"Github个人主页绑定域名Github虽然很好，可毕竟是免费的，还是有不少限制的。写到这里，特意去看了下Github对免费用户究竟有什么限制。发现除了300M的空间限制（还是所谓软限制），没有其他限制。所以用它来作为博客平台，真是再理想不过了。 创建步骤 建立一个博客repository 建立一个命名为username.github.io的repository, username就是你在Github上的用户名或机构名 增加主页 clone该repository到本地，增加index.html 提交 commit并且push该次修改。 OK 打开浏览器输入 username.github.io 即可。注意提交之后可能需要一小段时间的延迟。 绑定域名 在repository根目录新建CNAME文件, 内容为xxx.com(要绑定的域名),然后commit、push. 在自己的域名管理页面中,进入域名解析. 注意记录值 username.github.io. (最后面有一个.) 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Github","slug":"Github","permalink":"https://github.com/itgoyo/tags/Github/"}]},{"title":"3D旋转动画","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/3D旋转动画/","text":"3D旋转动画终于切切实实弄明白matrix那几个方法的使用了，比如preTranslate, setTranslate, postTranslate这些。以前对它们都是一知半解，以为这几个方法没什么区别，其实还是有很大不同的，最紧要是这几个方法的调用顺序对坐标变换的影响。抽象的说pre方法是向前”生长”, post方法是向后”生长”，具体拿个例子来说，比如一个matrix调用了下列一系列的方法： matrix.preScale(0.5f, 1); matrix.preTranslate(10, 0); matrix.postScale(0.7f, 1); matrix.postTranslate(15, 0); 则坐标变换经过的4个变换过程依次是：translate(10, 0) -&gt; scale(0.5f, 1) -&gt; scale(0.7f, 1) -&gt; translate(15, 0), 所以对matrix方法的调用顺序是很重要的，不同的顺序往往会产生不同的变换效果。pre方法的调用顺序和post方法的互不影响，即以下的方法调用和前者在真实坐标变换顺序里是一致的， matrix.postScale(0.7f, 1); matrix.preScale(0.5f, 1); matrix.preTranslate(10, 0); matrix.postTranslate(15, 0); 而matrix的set方法则会对先前的pre和post操作进行刷除，而后再设置它的值，比如下列的方法调用: matrix.preScale(0.5f, 1); matrix.postTranslate(10, 0); matrix.setScale(1, 0.6f); matrix.postScale(0.7f, 1); matrix.preTranslate(15, 0); 其坐标变换顺序是translate(15, 0) -&gt; scale(1, 0.6f) -&gt; scale(0.7f, 1). 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Handler导致内存泄露分析","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Handler导致内存泄露分析/","text":"Handler导致内存泄露分析有关内存泄露请猛戳内存泄露 123456Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // do something. &#125;&#125; 当我们这样创建Handler的时候Android Lint会提示我们这样一个warning： In Android, Handler classes should be static or leaks might occur.。 一直以来没有仔细的去分析泄露的原因，先把主要原因列一下： Android程序第一次创建的时候，默认会创建一个Looper对象，Looper去处理Message Queue中的每个Message,主线程的Looper存在整个应用程序的生命周期. Hanlder在主线程创建时会关联到Looper的Message Queue,Message添加到消息队列中的时候Message(排队的Message)会持有当前Handler引用，当Looper处理到当前消息的时候，会调用Handler#handleMessage(Message).就是说在Looper处理这个Message之前，会有一条链MessageQueue -&gt; Message -&gt; Handler -&gt; Activity，由于它的引用导致你的Activity被持有引用而无法被回收` 在java中，no-static的内部类会隐式的持有当前类的一个引用。static的内部类则没有。 ##具体分析123456789101112131415161718192021public class SampleActivity extends Activity &#123; private final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // do something &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 发送一个10分钟后执行的一个消息 mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;, 600000); // 结束当前的Activity finish();&#125; 在finish()的时候，该Message还没有被处理，Message持有Handler,Handler持有Activity,这样会导致该Activity不会被回收，就发生了内存泄露. ##解决方法 通过程序逻辑来进行保护。 如果Handler中执行的是耗时的操作，在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。 如果Handler是被delay的Message持有了引用，那么在Activity的onDestroy()方法要调用Handler的remove*方法，把消息对象从消息队列移除就行了。 关于Handler.remove*方法 removeCallbacks(Runnable r) ——清除r匹配上的Message。 removeC4allbacks(Runnable r, Object token) ——清除r匹配且匹配token（Message.obj）的Message，token为空时，只匹配r。 removeCallbacksAndMessages(Object token) ——清除token匹配上的Message。 removeMessages(int what) ——按what来匹配 removeMessages(int what, Object object) ——按what来匹配我们更多需要的是清除以该Handler为target的所有Message(Callback)就调用如下方法即可handler.removeCallbacksAndMessages(null); 将Handler声明为静态类。 静态类不持有外部类的对象，所以你的Activity可以随意被回收。但是不持有Activity的引用，如何去操作Activity中的一些对象？ 这里要用到弱引用 123456789101112131415161718192021222324252627282930313233public class MyActivity extends Activity &#123; private MyHandler mHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mHandler = new MyHandler(this); &#125; @Override protected void onDestroy() &#123; // Remove all Runnable and Message. mHandler.removeCallbacksAndMessages(null); super.onDestroy(); &#125; static class MyHandler extends Handler &#123; // WeakReference to the outer class's instance. private WeakReference&lt;MyActivity&gt; mOuter; public MyHandler(MyActivity activity) &#123; mOuter = new WeakReference&lt;MyActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; MyActivity outer = mOuter.get(); if (outer != null) &#123; // Do something with outer as your wish. &#125; &#125; &#125;&#125; 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"AsyncTask详解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/AsyncTask详解/","text":"AsyncTask详解AsyncTask简单的说其实就是Handler和Thread的结合，就想下面自己写的MyAsyncTask一样，这就是它的基本远离，当然它并不止这么简单。 经典版异步任务 1234567891011121314151617181920212223242526272829303132333435public abstract class MyAsyncTask &#123; private Handler handler = new Handler()&#123; public void handleMessage(android.os.Message msg) &#123; onPostExecute(); &#125;; &#125;; /** * 后台任务执行之前 提示用户的界面操作. */ public abstract void onPreExecute(); /** * 后台任务执行之后 更新界面的操作. */ public abstract void onPostExecute(); /** * 在后台执行的一个耗时的操作. */ public abstract void doInBackground(); public void execute()&#123; //1. 耗时任务执行之前通知界面更新 onPreExecute(); new Thread()&#123; public void run() &#123; doInBackground(); handler.sendEmptyMessage(0); &#125;; &#125;.start(); &#125; &#125; AsyncTask 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... params) &#123; blackNumberInfos = dao.findByPage(startIndex, maxNumber); return null; &#125; @Override protected void onPreExecute() &#123; loading.setVisibility(View.VISIBLE); super.onPreExecute(); &#125; @Override protected void onPostExecute(Void result) &#123; loading.setVisibility(View.INVISIBLE); if (adapter == null) &#123;// 第一次加载数据 数据适配器还不存在 adapter = new CallSmsAdapter(); lv_callsms_safe.setAdapter(adapter); &#125; else &#123;// 有新的数据被添加进来. adapter.notifyDataSetChanged();// 通知数据适配器 数据变化了. &#125; super.onPostExecute(result); &#125; &#125;.execute(); 类的构造方法中接收三个参数，这里我们不用参数就都给它传Void，new出来AsyncTask类之后然后重写这三个方法，最后别忘了执行execute方法，其实它的内部和我们写的经典版的异步任务相同，也是里面写了一个在新的线程中去执行耗时的操作，然后用handler发送Message对象，主线程收到这个Message之后去执行onPostExecute中的内容。//AsyncTask&lt;Params, Progress, Result&gt; ,params 异步任务执行(doBackgroud方法)需要的参数这个参数的实参可以由execute()方法的参数传入,// Progess 执行的进度,result是(doBackground方法)执行后的结果 new AsyncTask&lt;String, Void, Boolean&gt;() &#123; ProgressDialog pd; @Override protected Boolean doInBackground(String... params) &#123; //这里返回的就是执行的接口，这个返回的结果会传递给onPostExecute的参数 try &#123; String filename = params[0];//得到execute传入的参数 File file = new File(Environment.getExternalStorageDirectory(),filename); FileOutputStream fos = new FileOutputStream(file); SmsUtils.backUp(getApplicationContext(), fos, new BackUpStatusListener() &#123; public void onBackUpProcess(int process) &#123; pd.setProgress(process); &#125; public void beforeBackup(int max) &#123; pd.setMax(max); &#125; &#125;); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; @Override protected void onPreExecute() &#123; pd = new ProgressDialog(AtoolsActivity.this); pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); pd.setMessage(\"正在备份短信\"); pd.show(); super.onPreExecute(); &#125; @Override protected void onPostExecute(Boolean result) &#123; pd.dismiss(); if(result)&#123; Toast.makeText(getApplicationContext(), \"备份成功\", 0).show(); &#125;else&#123; Toast.makeText(getApplicationContext(), \"备份失败\", 0).show(); &#125; super.onPostExecute(result); &#125; &#125;.execute(\"backup.xml\"); //这里传入的参数就是doInBackgound中的参数，会传入到doInBackground中 ProgressDialog有个方法incrementProgressBy(int num);方法，这个方法能够让进度条自动增加，如果参数为1就是进度条累加1。 可以给ProgressDialog添加一个监听dismiss的监听器。pd.setOnDismisListener(DismisListener listener);让其在取消显示后做什么事 经过上面两部分，我们会发现AsyncTask太好了，他帮我们封装了Handler和Thread，当然他内部肯定会有线程池的管理，所以以后我们在开发中对于耗时的操作可以都用AsyncTask来搞定的。其实这种做法是错误的。今天发现公司项目中的网络请求都是用AsyncTask来做的(刚换的工作)。这样会有严重的问题。 AsyncTask存在的问题: AsyncTask虽然有cancel方法，但是一旦执行了doInBackground方法，就算调用取消方法，也会执行完doInBackground方法中的内容才会停止。 串行还是并行的问题。 在1.6之前，AsyncTask是串行执行任务的。1.6的时候开始采用线程池并行处理。但是从3.0开始为了解决AsyncTask的并发问题，AsyncTask又采用一个现成来串行执行任务。(串行啊，每个任务10秒，五个任务，最后一个就要到50秒的时候才执行完) 线程池的问题。 先从源码的角度分析下:打开源码后先看下他的注释，注释把我们所关心的内容说的很明白了。AsyncTask并不是设计来处理耗时操作的，耗时的上限最多为几秒钟。 12345678910111213141516171819202122AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. ***AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as Executor, ThreadPoolExecutor and FutureTask. *** There are a few threading rules that must be followed for this class to work properly: - The AsyncTask class must be loaded on the UI thread. This is done automatically as of android.os.Build.VERSION_CODES.JELLY_BEAN. - The task instance must be created on the UI thread. - execute must be invoked on the UI thread. - Do not call onPreExecute(), onPostExecute, doInBackground, onProgressUpdate manually. - The task can be executed only once (an exception will be thrown if a second execution is attempted.) Memory observability When first introduced, AsyncTasks were executed serially on a single background thread. Starting with android.os.Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with android.os.Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR. 拿到源码我们应该从哪里入手: 使用的时候我们都是 new AsyncTask&lt;&gt;.execute()所以我们可以先从构造方法和execute方法入手: 123456789101112131415161718192021222324252627282930313233343536/** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */public AsyncTask() &#123; // 初始化mWorker mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; // 修改该变量值 mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // 熟悉的doInBackground方法，并且返回该方法的返回值。 //noinspection unchecked return postResult(doInBackground(mParams)); &#125; &#125;; // 初始化mFuture并且将mWorker作为参数。这个FutureTask是什么...我也不知道，放狗查了一下。FutureTask是一种可以取消的异步的计算任务实现了Runnable接口， // 它可以让程序员准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果。其实就是FutureTask就是个子线程，会去执行mWorker回调中的耗时的操作 // 然后在执行完后执行done回调方法。 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; // 执行完成后的操作 postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occured while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; WorkerRunnable是Callable接口的抽象实现类: 123private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams;&#125; 下面上postResultIfNotInvoked()源码:123456789101112131415private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; postResult(result); &#125;&#125;// 通过Handler和Message将结果发布出去private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") // 调用getHandler去发送Message Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 那我们再看一下getHandler()方法得到的是哪个Handler:12345678private static Handler getHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(); &#125; return sHandler; &#125;&#125; 那接下来再看一下InternalHandler的实现:1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 我们看到如果判断消息类型为MESSAGE_POST_RESULT时，回去执行finish()方法，接着看一下result.mTask.finish()方法的源码:12345678910private void finish(Result result) &#123; if (isCancelled()) &#123; // 如果被取消了就执行onCancelled方法，这就是为什么虽然AsyncTask可以取消，但是doInBackground方法还是会执行完的原因。 onCancelled(result); &#125; else &#123; // 没被取消就执行oPostExecute方法 onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 到这里我们会发现已经分析完了doInBackground方法执行完后的一系列操作。那onPreExecute方法是在哪里? 好了，接着看execute()方法 :123public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 里面调用了executeOnExecutor()，我们看一下executeOnExecutor()方法:123456789101112131415161718192021222324public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; // 看到我们熟悉的onPreExecute()方法。 onPreExecute(); // 将参数设置给mWorker变量 mWorker.mParams = params; // 执行了Executor的execute方法并用mFuture为参数，这个exec就是上面的sDefaultExecutor exec.execute(mFuture); return this;&#125; 我们看一下sDefaultExecutor是什么:12345678910/** * An &#123;@link Executor&#125; that executes tasks one at a time in serial * order. This serialization is global to a particular process. */public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static final int MESSAGE_POST_RESULT = 0x1;private static final int MESSAGE_POST_PROGRESS = 0x2;private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 从上面的部分能够看出sDefaultExecutor是一个SerialExecutor对象，好了，接下来看一下SerialExecutor类:1234567891011121314151617181920212223242526272829private static class SerialExecutor implements Executor &#123; // 用一个队列来管理所有的runnable。offer是把要执行的添加进来，在scheduleNext中取出来去执行。 final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; // 终于找到了sDefaultExecutor.execute()所真正执行的部分。 mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; // 就是mFuture的run方法，他会去调用mWorker.call方法，这样就会执行doInBackground方法，执行完后会把返回值用Handler发送出去 r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; // 去取队列中的runnable去执行，这个mActive其实就是mFuture对象。 THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 所以从SerialExecutor中我们能看到这就是为什么会串行的去执行了。因为他只会取队列的第一个去执行，其他的都在队列中等待。 但是这里THREAD_POOL_EXECUTOR是什么呢？ 123456/** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 静态常量，也就是所不管你用多少个AsyncTask都会用这同一个线程池。 接着我们重点看一下THREAD_POOL_EXECUTOR.execute(mActive):因为mActive就是mFuture = new FutureTask&lt;Result&gt;(mWorker)。所以在执行execute方法时会执行FutureTask的run方法:12345678910111213141516171819202122232425262728293031323334public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; // 他会去调用 Callable的call()方法，而上面传入的Callable参数是mWorker。所以这里就会调用mWorker的call方法。 // 通过这里就和之前我们讲的doInBackground方法联系上了. result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 到这里就分析完了。 下面把完整的代码粘贴上(5.1.1):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; private static final String LOG_TAG = \"AsyncTask\"; private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); private static final int CORE_POOL_SIZE = CPU_COUNT + 1; private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; private static final int KEEP_ALIVE = 1; private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); &#125; &#125;; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128); /** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */ public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); /** * An &#123;@link Executor&#125; that executes tasks one at a time in serial * order. This serialization is global to a particular process. */ public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static final int MESSAGE_POST_RESULT = 0x1; private static final int MESSAGE_POST_PROGRESS = 0x2; private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; private static InternalHandler sHandler; private final WorkerRunnable&lt;Params, Result&gt; mWorker; private final FutureTask&lt;Result&gt; mFuture; private volatile Status mStatus = Status.PENDING; private final AtomicBoolean mCancelled = new AtomicBoolean(); private final AtomicBoolean mTaskInvoked = new AtomicBoolean(); private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; /** * Indicates the current status of the task. Each status will be set only once * during the lifetime of a task. */ public enum Status &#123; /** * Indicates that the task has not been executed yet. */ PENDING, /** * Indicates that the task is running. */ RUNNING, /** * Indicates that &#123;@link AsyncTask#onPostExecute&#125; has finished. */ FINISHED, &#125; private static Handler getHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(); &#125; return sHandler; &#125; &#125; /** @hide */ public static void setDefaultExecutor(Executor exec) &#123; sDefaultExecutor = exec; &#125; /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occured while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; postResult(result); &#125; &#125; private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; /** * Returns the current status of this task. * * @return The current status. */ public final Status getStatus() &#123; return mStatus; &#125; /** * Override this method to perform a computation on a background thread. The * specified parameters are the parameters passed to &#123;@link #execute&#125; * by the caller of this task. * * This method can call &#123;@link #publishProgress&#125; to publish updates * on the UI thread. * * @param params The parameters of the task. * * @return A result, defined by the subclass of this task. * * @see #onPreExecute() * @see #onPostExecute * @see #publishProgress */ protected abstract Result doInBackground(Params... params); /** * Runs on the UI thread before &#123;@link #doInBackground&#125;. * * @see #onPostExecute * @see #doInBackground */ protected void onPreExecute() &#123; &#125; /** * &lt;p&gt;Runs on the UI thread after &#123;@link #doInBackground&#125;. The * specified result is the value returned by &#123;@link #doInBackground&#125;.&lt;/p&gt; * * &lt;p&gt;This method won't be invoked if the task was cancelled.&lt;/p&gt; * * @param result The result of the operation computed by &#123;@link #doInBackground&#125;. * * @see #onPreExecute * @see #doInBackground * @see #onCancelled(Object) */ @SuppressWarnings(&#123;\"UnusedDeclaration\"&#125;) protected void onPostExecute(Result result) &#123; &#125; /** * Runs on the UI thread after &#123;@link #publishProgress&#125; is invoked. * The specified values are the values passed to &#123;@link #publishProgress&#125;. * * @param values The values indicating progress. * * @see #publishProgress * @see #doInBackground */ @SuppressWarnings(&#123;\"UnusedDeclaration\"&#125;) protected void onProgressUpdate(Progress... values) &#123; &#125; /** * &lt;p&gt;Runs on the UI thread after &#123;@link #cancel(boolean)&#125; is invoked and * &#123;@link #doInBackground(Object[])&#125; has finished.&lt;/p&gt; * * &lt;p&gt;The default implementation simply invokes &#123;@link #onCancelled()&#125; and * ignores the result. If you write your own implementation, do not call * &lt;code&gt;super.onCancelled(result)&lt;/code&gt;.&lt;/p&gt; * * @param result The result, if any, computed in * &#123;@link #doInBackground(Object[])&#125;, can be null * * @see #cancel(boolean) * @see #isCancelled() */ @SuppressWarnings(&#123;\"UnusedParameters\"&#125;) protected void onCancelled(Result result) &#123; onCancelled(); &#125; /** * &lt;p&gt;Applications should preferably override &#123;@link #onCancelled(Object)&#125;. * This method is invoked by the default implementation of * &#123;@link #onCancelled(Object)&#125;.&lt;/p&gt; * * &lt;p&gt;Runs on the UI thread after &#123;@link #cancel(boolean)&#125; is invoked and * &#123;@link #doInBackground(Object[])&#125; has finished.&lt;/p&gt; * * @see #onCancelled(Object) * @see #cancel(boolean) * @see #isCancelled() */ protected void onCancelled() &#123; &#125; /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this task was cancelled before it completed * normally. If you are calling &#123;@link #cancel(boolean)&#125; on the task, * the value returned by this method should be checked periodically from * &#123;@link #doInBackground(Object[])&#125; to end the task as soon as possible. * * @return &lt;tt&gt;true&lt;/tt&gt; if task was cancelled before it completed * * @see #cancel(boolean) */ public final boolean isCancelled() &#123; return mCancelled.get(); &#125; /** * &lt;p&gt;Attempts to cancel execution of this task. This attempt will * fail if the task has already completed, already been cancelled, * or could not be cancelled for some other reason. If successful, * and this task has not started when &lt;tt&gt;cancel&lt;/tt&gt; is called, * this task should never run. If the task has already started, * then the &lt;tt&gt;mayInterruptIfRunning&lt;/tt&gt; parameter determines * whether the thread executing this task should be interrupted in * an attempt to stop the task.&lt;/p&gt; * * &lt;p&gt;Calling this method will result in &#123;@link #onCancelled(Object)&#125; being * invoked on the UI thread after &#123;@link #doInBackground(Object[])&#125; * returns. Calling this method guarantees that &#123;@link #onPostExecute(Object)&#125; * is never invoked. After invoking this method, you should check the * value returned by &#123;@link #isCancelled()&#125; periodically from * &#123;@link #doInBackground(Object[])&#125; to finish the task as early as * possible.&lt;/p&gt; * * @param mayInterruptIfRunning &lt;tt&gt;true&lt;/tt&gt; if the thread executing this * task should be interrupted; otherwise, in-progress tasks are allowed * to complete. * * @return &lt;tt&gt;false&lt;/tt&gt; if the task could not be cancelled, * typically because it has already completed normally; * &lt;tt&gt;true&lt;/tt&gt; otherwise * * @see #isCancelled() * @see #onCancelled(Object) */ public final boolean cancel(boolean mayInterruptIfRunning) &#123; mCancelled.set(true); return mFuture.cancel(mayInterruptIfRunning); &#125; /** * Waits if necessary for the computation to complete, and then * retrieves its result. * * @return The computed result. * * @throws CancellationException If the computation was cancelled. * @throws ExecutionException If the computation threw an exception. * @throws InterruptedException If the current thread was interrupted * while waiting. */ public final Result get() throws InterruptedException, ExecutionException &#123; return mFuture.get(); &#125; /** * Waits if necessary for at most the given time for the computation * to complete, and then retrieves its result. * * @param timeout Time to wait before cancelling the operation. * @param unit The time unit for the timeout. * * @return The computed result. * * @throws CancellationException If the computation was cancelled. * @throws ExecutionException If the computation threw an exception. * @throws InterruptedException If the current thread was interrupted * while waiting. * @throws TimeoutException If the wait timed out. */ public final Result get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; return mFuture.get(timeout, unit); &#125; /** * Executes the task with the specified parameters. The task returns * itself (this) so that the caller can keep a reference to it. * * &lt;p&gt;Note: this function schedules the task on a queue for a single background * thread or pool of threads depending on the platform version. When first * introduced, AsyncTasks were executed serially on a single background thread. * Starting with &#123;@link android.os.Build.VERSION_CODES#DONUT&#125;, this was changed * to a pool of threads allowing multiple tasks to operate in parallel. Starting * &#123;@link android.os.Build.VERSION_CODES#HONEYCOMB&#125;, tasks are back to being * executed on a single thread to avoid common application errors caused * by parallel execution. If you truly want parallel execution, you can use * the &#123;@link #executeOnExecutor&#125; version of this method * with &#123;@link #THREAD_POOL_EXECUTOR&#125;; however, see commentary there for warnings * on its use. * * &lt;p&gt;This method must be invoked on the UI thread. * * @param params The parameters of the task. * * @return This instance of AsyncTask. * * @throws IllegalStateException If &#123;@link #getStatus()&#125; returns either * &#123;@link AsyncTask.Status#RUNNING&#125; or &#123;@link AsyncTask.Status#FINISHED&#125;. * * @see #executeOnExecutor(java.util.concurrent.Executor, Object[]) * @see #execute(Runnable) */ public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); // 这里就多插一嘴了。 sDefaultExecutor在上面我们分析过了，就是一个队列来保证串行进行。从3.0开始都是这样。 // 那在1.6到3.0之间是怎么并行执行的呢？ 按照下面的方式改就可以了 // return executeOnExecutor(THREAD_POOL_EXECUTOR, params); // 就是将sDefaultExecutor改成THREAD_POOL_EXECUTOR， THREAD_POOL_EXECUTOR就是线程池。 // new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); // 原来的CORE_POOL_SIZE是5, KEEP_ALIVE是10, MAXIMUM_POOL_SIZE是128 // 也就是说可以同时执行的线程是5个，如果超过5个后，超过的部分就会放到缓存队列中，如果超过了128那就挂了 &#125; /** * Executes the task with the specified parameters. The task returns * itself (this) so that the caller can keep a reference to it. * * &lt;p&gt;This method is typically used with &#123;@link #THREAD_POOL_EXECUTOR&#125; to * allow multiple tasks to run in parallel on a pool of threads managed by * AsyncTask, however you can also use your own &#123;@link Executor&#125; for custom * behavior. * * &lt;p&gt;&lt;em&gt;Warning:&lt;/em&gt; Allowing multiple tasks to run in parallel from * a thread pool is generally &lt;em&gt;not&lt;/em&gt; what one wants, because the order * of their operation is not defined. For example, if these tasks are used * to modify any state in common (such as writing a file due to a button click), * there are no guarantees on the order of the modifications. * Without careful work it is possible in rare cases for the newer version * of the data to be over-written by an older one, leading to obscure data * loss and stability issues. Such changes are best * executed in serial; to guarantee such work is serialized regardless of * platform version you can use this function with &#123;@link #SERIAL_EXECUTOR&#125;. * * &lt;p&gt;This method must be invoked on the UI thread. * * @param exec The executor to use. &#123;@link #THREAD_POOL_EXECUTOR&#125; is available as a * convenient process-wide thread pool for tasks that are loosely coupled. * @param params The parameters of the task. * * @return This instance of AsyncTask. * * @throws IllegalStateException If &#123;@link #getStatus()&#125; returns either * &#123;@link AsyncTask.Status#RUNNING&#125; or &#123;@link AsyncTask.Status#FINISHED&#125;. * * @see #execute(Object[]) */ public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125; /** * Convenience version of &#123;@link #execute(Object...)&#125; for use with * a simple Runnable object. See &#123;@link #execute(Object[])&#125; for more * information on the order of execution. * * @see #execute(Object[]) * @see #executeOnExecutor(java.util.concurrent.Executor, Object[]) */ public static void execute(Runnable runnable) &#123; sDefaultExecutor.execute(runnable); &#125; /** * This method can be invoked from &#123;@link #doInBackground&#125; to * publish updates on the UI thread while the background computation is * still running. Each call to this method will trigger the execution of * &#123;@link #onProgressUpdate&#125; on the UI thread. * * &#123;@link #onProgressUpdate&#125; will not be called if the task has been * canceled. * * @param values The progress values to update the UI with. * * @see #onProgressUpdate * @see #doInBackground */ protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125; &#125; private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED; &#125; private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams; &#125; @SuppressWarnings(&#123;\"RawUseOfParameterizedType\"&#125;) private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125; &#125;&#125; 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android Studio你可能不知道的操作","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Android Studio你可能不知道的操作/","text":"Android Studio你可能不知道的操作今天看在Youtube看视频，看到Reto Meier在讲解Studio，一查才知道他现在是Studio的开发人员。想起刚开始学Android时买的他写的书Professional Android 4 Application Development，当时很多内容没看懂。不过看了这个视频才发现大神写代码如此之快… 现在天天用着大神开发的工具，没有理由不去好好学习下。 工欲善其事必先利其器，一个好的开发工具可以让你事半功倍。Android Studio是一个非常好的开发工具，但是虽然都在用，你可能还是了解的不全面，今天就来说一下一些你可能不知道的功能。 熟练使用快捷键是非常有必要的: 自动导入经常听到同事抱怨，Studio怎么没有Eclipse那种批量导包啊，那么多类要到，费劲了。其实不用一个个导的。使用Command+Shift+A(Windows或Linux是Ctrl+Shift+A)快速的查找设置命令。我们输入auto import后将Add unambiguous imports on fly选项开启就好了，很爽有木有？你的是不是也没开啊？你可以快速打开一些设置，例如你想在finder中查看该文件，直接输入find就好了。 在自动完成代码时使用Tab键来替换已存在的方法和参数。经常如我们想要修改一个已经存在的方法时，我们移动到对象的.的提示区域，如果使用Command+Space来补充代码选择后按enter的话，会把之前已经存在的代码往后移动，这样还要再去删除，很不方便。但是如果我们直接使用Tag键，那就会直接替换当前已经存在的方法。 内容选择技巧使用Control+↑或↓能在方法间移动。使用Shift+↑或↓来选择至上一行或者至下一行代码的代码？那么使用option++↑或↓(Windows或Linux是alt++↑或↓)呢？它能选择或者取消选择和你鼠标所在位置的代码区域。同时使用`option+shift++↑或↓(Windows或Linux是alt+shift++↑或↓)可以交换选中代码块与上一行的位置。这样我们就不需要剪切和粘贴了。 使用模板补全代码你可以在代码后加用后缀的方式补充代码块，也可以用Command+J(Windows是Ctrl+J)来提示。对于一些更多的模式，在代码自动完成时也支持生成对应的模板，例如使用Toast的快捷键可以很方便的生成一个新的toast对象，你只需要指定文字就可以了。用Command+Shift+A然后输入live template然后打开对应的页面，可以看到目前已经存在的模板。当然你也可以添加新的模板。 在Evaluating Expressions中为Object对象指定显示内容如果我们在debug的时候查看断点处的变量值或者evaluating expressions，你会发现objects会显示他们的toString()值。如果你的变量是String类型或者基础类型那不会有问题，但是大多数其他对象，这样没有什么意义。尤其是在集合对象时，你看的是一个CallsName:HashValue的列表。而为了需要看清数据，我们需要知道每个对象的内容。你当然可以去对每个对象类型指定索要显示的内容。在对应的对象上邮件View as然后创建你想要显示的内容就可以了。 结构性的搜索、替换、和检查Command+shift+A然后输入structural后选择search structurally或者replace structurally，然后可以对应的结构性搜索的模板，完成之后所有符合该模板的代码都会提示warning。更有用的是可以使用快速修复来替换一些代码，例如一些废弃的代码或者你在review时发现的其他团队成员提交的一些普遍的错误。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"HttpURLConnection与HttpClient","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/HttpURLConnection与HttpClient/","text":"HttpURLConnection与HttpClient Java的HttpURLConnection 请求默认带Gzip压缩。 Apache的HttpClient 请求默认不带Gzip压缩。 一般对于API请求返回的数据大多是Json类的字符串，Gzip压缩可以使数据大小大幅降低。Retrofit及Volley框架默认在Android Gingerbread(API 9)及以上都是用HttpURLConnection，9以下用HttpClient。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"InstantRun详解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/InstantRun详解/","text":"InstantRun详解之前在写AndroidStudio提高Build速度这篇文章的时候写到，想要快，就用Instant Run。最近有朋友发来邮件讨论它的原理，最近项目不忙，索性就来系统的学习下。 Android Studio2.0开始引入了Instant Run，它主要是在Run和Debug的时候可以去减少更新应用的时间。虽然第一次Build的时候可能会消耗稍长的时间来完成，但是Instant Run可以把更新内容推送到设备上，而无需重新build一个新的apk，这样就会很快速的让我们观察到改变。 Instant Run只支持在build.gralde文件中配置的Gradle版本是2.0.0以上并且minSdkVersion是15以上才可以。为了能更好的使用，请将minSdkVrsion设置到21以上。 部署完应用后，会在Run(或者(Debug))图标上面出现一个小黄色的闪电符号，这就意味着Instant Run已经准备就绪，在你下次点击按钮的时候可以推送更新内容。它不需要重新构建一个新的APK,它只推送那些新改变的地方，有些情况下app都不需要重启就可以直接显示新改变的下效果。 ###配置你的应用来使用Instant Run Android Stuido中项目使用Gralde2.0.0及以上版本会默认使用Instant Run。让项目更新到最新的版本: 点击Settings中的Preferences按钮。 找到Build,Execution,Deployment中的Instant Run然后点击Update Project，如果Update Project部分没有显示，那说明你当前已经是最新版本了. ###修复类型 Instant Run通过热修复、暖修复或者冷修复来推送改变的代码和资源到你的设备或者模拟器上。它会根据你更改的内容来自动选择对应的修复类型。 热修复: 更改的内容不需要重启应用甚至不需要重启当前的activity就可以让显示内容的改变，对于大部分通过方法内容改变的更改都可以通过这种方式来修改。 暖修复: 需要重启activity才能让改变生效，在改变资源时会通过该方式。 冷修复: 应用需要重启(不是重新安装)。对于一些方法方法结构和实现等结构性的改变需要通过该方式。 那具体更改内容和修复方式是怎么对应的呢？ 改变现在已经存在的方法 这将通过热修复来执行，这是最快的一种修复方式。你的应用会在运行的过程中，在下次调用该方法时直接使用新实现的方法。 热修复不需要重新初始化对象。在看到具体的更改之前，你可能会需要重启当前的activity或者应用。默认情况下Android Studio在执行热修复后会自动重启当前的activity。如果你不想要它自动重启activity你也可以在设置中禁用。 更改或者移除已经存在的资源 这将通过暖修复来执行:这也是非常快的，但是Instant Run在推送这些更新内容时必须要重启当前的activity。你的应用仍然会继续运行，但是在重启activity时屏幕可能会闪动-这是正常滴。 结构性的改变例如: 增删或者改变: 一个注解 一个变量 一个静态变量 一个方法结构 一个静态方法结构 更改该类集成的父类 更改接口的实现列表 更改类的静态修饰符 使用动态资源id重新布局 上面的这些改变都将通过冷修复(API 21以上才支持)来执行.冷修复会稍微有些慢，因为虽然不需要构建一个新的APK但是必须要重启整个app才能推送这些结构性的代码改变。对于API 20及以下的版本，Android Studio将重新部署APK。 更改manifest文件或者更改manifest文件中引用的资源或者更改Android桌面widget的UI实现(需要Clean and Rerun) 在更改清单文件或者清单文件中引用的资源时，Android Studio会自动的重新部署引用来实现这些内容的改变。这是因为例如应用名称、图标和intent filters这些东西是要在应用安装到设备时根据清单文件来决定的。 在更新Android UI widget时，你需要执行Clean and Rerun才能看到更改的内容，因为在使用Instant Run时执行clean会需要很长的时间，所以你在更新UI widget时可以禁用Instant Run。 #####使用Rerun 如果修改了一些会影响到初始化的内容时，例如修改了应用的onCreate()方法，你需要重启你的应用来让这些改变生效，你可以点击Rerun图标。它将会停止应用运行，并且执行clean操作后重新部署一个新的APK到你的设备。 ###实现原理 正常情况下，我们修改了内容，想让让它生效，那就需要如下的步骤: 那Instant Run的目标也非常简单: 尽可能多的移除上面的步骤，来让剩下的部分尽可能更快。 这就意味着: 只构建和部署新更改的部分。 不去重新安装应用。 不去重启应用。 甚至不去重启activity。 普通情况下在你点击Run或者Debug按钮时，会执行如下的操作: 清单文件会被整合然后与你应用的资源重启打包成APK.同样的，.java的源代码会被编译成二进制，然后转换成.dex文件，他们也会被包含到APK中。 在使用Instant Run的情况下，第一次点击Run和Debug时Gradle会执行一些额外的操作:instrumentation相关的二进制内容会被增加到.class文件中，并且一个新的App Server类会被注入到应用中。同时也会增加一个新的Application类，来注入一些自定义的class loader并且能启动App Server。因此minifest文件会被修改来保证使用该新加的Application类(如果你已经创建了自己的Application类，Instant Run的版本将会用你定义的来进行代理扩展) 经过上面的操作Instant Run就开始执行了，以后如果你改变了代码部分，在重新点击Run或者Debug时，Instant Run将会通过热、暖、冷修复来尽可能的减少上面的构建过程。 在Instant Run更改内容前，Android Studio会你的应用版本是否支持Instant Run并且App Server是否运行在对其有用的端口(内部使用了Socket)。 这样来确定你的应用是否在前台运行，并且找到Studio所需要的构建ID. 总结一下，其实就是内部会对每个class文件注入instant run相关的代码，然后自定义一个application内部指定自定义的classLoader(也就是说不使用默认的classLoader了，只要用了Instant Run就需要使用它自定义的classLoader)，然后在应用程序里面开启一个服务器，Studio将修改的代码发送到该服务器，然后再通过自定义的classLoader加载代码的时候会去请求该服务器判断代码是否有更新，如果有更新就会通过委托机制加载新更新的代码然后注入到应用程序中，这样就完成了替换的操作。 ###热修复过程 Android Studio会监听在开发过程中哪个文件发生了改变，并且通过一个自定义的Gralde task来只对修改的class文件生成对应的.dex文件。这些新的.dex文件会通过Studio传递发布给应用中运行的App Server。 因为开始时这些文件的class已经存在到运行中的应用中-Gralde需要保证更新的版本来保证他们能覆盖之前已经存在的文件。这些更新文件的转换是由App Server通过自定义的class loader来完成的。 从现在开始，每次一个方法被调用时(不管在应用中的任何地方)，被注入到最初的class文件中的instrumentation都讲去连接App Server来检查它们是否有更新了。 如果有更新，执行操作将被指派到新的充在的class文件，这样就会执行新修改的方法。 如果你设置断点，你会发现你调用的是override名字的类中的方法。 这种重新指定方法的方式在改变方法实现时非常有效，但是对于那种需要在Activity启动时加载的改变呢？ ###暖修复 暖修复会重启Activity。资源文件会在Activity启动时被加载，所以修改它们需要activity重新启动来进行加载。 现在，更改任何资源都会导致所有的资源都被重新打包病转移到应用中-但是以后会支持增量包的功能来让只打包和部署那些新修改的资源。 注意，暖修复在更改manifest件或者manifest文件中引用的内容时无效，因为manifest文件中的内容需要在apk安装时读取。更改Manifest文件(或者它所引用的内容)需要被全部构建和部署。 非常不幸的是，重启activity在做一些结构性的改变时无效。对于这些改变需要使用冷修复。 ###冷修复 在部署时，你的应用和他的子项目会被分派到10个不同的部分，每个都在自己单独的dex文件。不同部分的类会通过包名来分配。在使用冷修复时，修改的类需要其他所有相关的class文件都被重新打包后才能被部署到设备上。这就需要依赖Android Runtime能支持加载多个.dex文件,这是一个在ART中新增的功能，它只有在Android 5.0(API 21)以上的设备总才支持。对于API 20一下的设备，他们仍在使用Dalvik虚拟机，Android Studio需要部署整个APK。 有些时候通过热修复来改变的代码，但是它会被应用首次运行时的初始化所影响，这时你就需要restart你的应用来让其生效(快捷键是Command + Ctrl + R)。 ###Instant Run使用技巧及提示 Instant Run是由Android Studio控制的，所以你只能通过IDE来start/restart你的debug实例，不要直接在设备中start/restart你的应用，不然的话就会发生错乱。 #####Instant Run限制条件 部署到多个设备 Instant Run针对设备的不同API Level使用不同的技术来进行热、暖、冷修复。因此，如果同时部署一个应用到多个设备时，Studio会暂时关闭Instant Run功能。 Multidex 如果你的项目支持传统的Multidex-也就是在build.gradle中配置了multiDexEnabled true和minSdkVersion 20及以下-当你部署应用到4.4以下的设备上时，Android Studio将会禁用Instant Run。 如果minSdkVersion设置为21或者更高时，Instant Run将自动配置来支持multidex，因为Instant Run只支持debug版本，有需要在发布release版的时候配置你的build变量来支持multidex。 使用第三方插件 Android Studio在使用Instant Run时会暂时禁用Java Code Coverage Library和ProGuard。因为Instant Run只支持debug版本，这样也不会影响release版的构建。 只能在主进程中运行 目前热修复只能在主进程中进行，如果在其他进程中热、暖修复将无法使用，只能用冷修复来替代。 参考: 官网 Instant Run: How Does it Work?! 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Activity界面绘制过程详解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Activity界面绘制过程详解/","text":"Activity界面绘制过程详解设置界面首先就是Activity.setContentView()方法：我们先看一下他的源码：12345678910111213/** * Set the activity content from a layout resource. The resource will be * inflated, adding all top-level views to the activity. * * @param layoutResID Resource ID to be inflated. * * @see #setContentView(android.view.View) * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams) */public void setContentView(int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; getWindow()就是获取该页面的窗体Window，该类是一个抽象类，他有一个唯一的子类PhoneWindow.1234567891011/** * Retrieve the current &#123;@link android.view.Window&#125; for the activity. * This can be used to directly access parts of the Window API that * are not available through Activity/Screen. * * @return Window The current window, or null if the activity is not * visual. */public Window getWindow() &#123; return mWindow;&#125; 接下来，我们看一下PhoneWindow.setContentView()方法。(简单的理解是PhoneWindow把DectorView(FrameLayout的子类)进行包装，将它作为窗口的根View`)1234567891011121314151617181920212223242526272829@Overridepublic void setContentView(int layoutResID) &#123; // mContentParent 是当前window显示内容的父布局，它只能是mDecor或mDecor的子View,如果mContentParent为null，说明是第一次调用setContentView方法 // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; // 内部会创建mContentParent, 如果mDecor为null就创建，然后如果mContentParent为null，就根据当前要显示的主题去添加对应的布局， // 并把该布局中id为content的ViewGroup赋值给mContentParent。 installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; // 多次调用setContentView，可能是第二次、第三次，先把之前的页面内容移除 mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; // 把布局inflate后添加到mContentParent中 mLayoutInflater.inflate(layoutResID, mContentParent); &#125; final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125; 上面简单的说明了installDecor()的作用，这里我们在源码中仔细说明一下, 通过这个源码我们知道设置主题要在setContentView之前去调用，如用代码设置requestWindowFeature()设置主题时要在setContentView()之前设置才有用.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138private void installDecor() &#123; if (mDecor == null) &#123; // 内部就是new 一个 DecorView mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; if (mContentParent == null) &#123; // 根据当前主题去选择对应的布局文件，然后把布局中的id=content(一般为FrameLayout)部分赋值给mContentParent. mContentParent = generateLayout(mDecor); // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById( R.id.decor_content_parent); if (decorContentParent != null) &#123; mDecorContentParent = decorContentParent; mDecorContentParent.setWindowCallback(getCallback()); if (mDecorContentParent.getTitle() == null) &#123; mDecorContentParent.setWindowTitle(mTitle); &#125; final int localFeatures = getLocalFeatures(); for (int i = 0; i &lt; FEATURE_MAX; i++) &#123; if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123; mDecorContentParent.initFeature(i); &#125; &#125; mDecorContentParent.setUiOptions(mUiOptions); if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != 0 || (mIconRes != 0 &amp;&amp; !mDecorContentParent.hasIcon())) &#123; mDecorContentParent.setIcon(mIconRes); &#125; else if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == 0 &amp;&amp; mIconRes == 0 &amp;&amp; !mDecorContentParent.hasIcon()) &#123; mDecorContentParent.setIcon( getContext().getPackageManager().getDefaultActivityIcon()); mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK; &#125; if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != 0 || (mLogoRes != 0 &amp;&amp; !mDecorContentParent.hasLogo())) &#123; mDecorContentParent.setLogo(mLogoRes); &#125; // Invalidate if the panel menu hasn't been created before this. // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu // being called in the middle of onCreate or similar. // A pending invalidation will typically be resolved before the posted message // would run normally in order to satisfy instance state restoration. PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false); if (!isDestroyed() &amp;&amp; (st == null || st.menu == null)) &#123; invalidatePanelMenu(FEATURE_ACTION_BAR); &#125; &#125; else &#123; mTitleView = (TextView)findViewById(R.id.title); if (mTitleView != null) &#123; mTitleView.setLayoutDirection(mDecor.getLayoutDirection()); if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123; View titleContainer = findViewById( R.id.title_container); if (titleContainer != null) &#123; titleContainer.setVisibility(View.GONE); &#125; else &#123; mTitleView.setVisibility(View.GONE); &#125; if (mContentParent instanceof FrameLayout) &#123; ((FrameLayout)mContentParent).setForeground(null); &#125; &#125; else &#123; mTitleView.setText(mTitle); &#125; &#125; &#125; if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123; mDecor.setBackgroundFallback(mBackgroundFallbackResource); &#125; // Only inflate or create a new TransitionManager if the caller hasn't // already set a custom one. if (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) &#123; if (mTransitionManager == null) &#123; final int transitionRes = getWindowStyle().getResourceId( R.styleable.Window_windowContentTransitionManager, 0); if (transitionRes != 0) &#123; final TransitionInflater inflater = TransitionInflater.from(getContext()); mTransitionManager = inflater.inflateTransitionManager(transitionRes, mContentParent); &#125; else &#123; mTransitionManager = new TransitionManager(); &#125; &#125; mEnterTransition = getTransition(mEnterTransition, null, R.styleable.Window_windowEnterTransition); mReturnTransition = getTransition(mReturnTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowReturnTransition); mExitTransition = getTransition(mExitTransition, null, R.styleable.Window_windowExitTransition); mReenterTransition = getTransition(mReenterTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowReenterTransition); mSharedElementEnterTransition = getTransition(mSharedElementEnterTransition, null, R.styleable.Window_windowSharedElementEnterTransition); mSharedElementReturnTransition = getTransition(mSharedElementReturnTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowSharedElementReturnTransition); mSharedElementExitTransition = getTransition(mSharedElementExitTransition, null, R.styleable.Window_windowSharedElementExitTransition); mSharedElementReenterTransition = getTransition(mSharedElementReenterTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowSharedElementReenterTransition); if (mAllowEnterTransitionOverlap == null) &#123; mAllowEnterTransitionOverlap = getWindowStyle().getBoolean( R.styleable.Window_windowAllowEnterTransitionOverlap, true); &#125; if (mAllowReturnTransitionOverlap == null) &#123; mAllowReturnTransitionOverlap = getWindowStyle().getBoolean( R.styleable.Window_windowAllowReturnTransitionOverlap, true); &#125; if (mBackgroundFadeDurationMillis &lt; 0) &#123; mBackgroundFadeDurationMillis = getWindowStyle().getInteger( R.styleable.Window_windowTransitionBackgroundFadeDuration, DEFAULT_BACKGROUND_FADE_DURATION_MS); &#125; if (mSharedElementsUseOverlay == null) &#123; mSharedElementsUseOverlay = getWindowStyle().getBoolean( R.styleable.Window_windowSharedElementsUseOverlay, true); &#125; &#125; &#125;&#125; 我们先看一下generateLayout的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. TypedArray a = getWindowStyle(); if (false) &#123; System.out.println(\"From style:\"); String s = \"Attrs:\"; for (int i = 0; i &lt; R.styleable.Window.length; i++) &#123; s = s + \" \" + Integer.toHexString(R.styleable.Window[i]) + \"=\" + a.getString(i); &#125; System.out.println(s); &#125; mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false); int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR) &amp; (~getForcedWindowFlags()); if (mIsFloating) &#123; setLayout(WRAP_CONTENT, WRAP_CONTENT); setFlags(0, flagsToUpdate); &#125; else &#123; setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate); &#125; if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123; requestFeature(FEATURE_NO_TITLE); &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123; // Don't allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); &#125; if (a.getBoolean(R.styleable.Window_windowActionBarOverlay, false)) &#123; requestFeature(FEATURE_ACTION_BAR_OVERLAY); &#125; if (a.getBoolean(R.styleable.Window_windowActionModeOverlay, false)) &#123; requestFeature(FEATURE_ACTION_MODE_OVERLAY); &#125; if (a.getBoolean(R.styleable.Window_windowSwipeToDismiss, false)) &#123; requestFeature(FEATURE_SWIPE_TO_DISMISS); &#125; if (a.getBoolean(R.styleable.Window_windowFullscreen, false)) &#123; setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags())); &#125; if (a.getBoolean(R.styleable.Window_windowTranslucentStatus, false)) &#123; setFlags(FLAG_TRANSLUCENT_STATUS, FLAG_TRANSLUCENT_STATUS &amp; (~getForcedWindowFlags())); &#125; if (a.getBoolean(R.styleable.Window_windowTranslucentNavigation, false)) &#123; setFlags(FLAG_TRANSLUCENT_NAVIGATION, FLAG_TRANSLUCENT_NAVIGATION &amp; (~getForcedWindowFlags())); &#125; if (a.getBoolean(R.styleable.Window_windowOverscan, false)) &#123; setFlags(FLAG_LAYOUT_IN_OVERSCAN, FLAG_LAYOUT_IN_OVERSCAN&amp;(~getForcedWindowFlags())); &#125; if (a.getBoolean(R.styleable.Window_windowShowWallpaper, false)) &#123; setFlags(FLAG_SHOW_WALLPAPER, FLAG_SHOW_WALLPAPER&amp;(~getForcedWindowFlags())); &#125; if (a.getBoolean(R.styleable.Window_windowEnableSplitTouch, getContext().getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.HONEYCOMB)) &#123; setFlags(FLAG_SPLIT_TOUCH, FLAG_SPLIT_TOUCH&amp;(~getForcedWindowFlags())); &#125; a.getValue(R.styleable.Window_windowMinWidthMajor, mMinWidthMajor); a.getValue(R.styleable.Window_windowMinWidthMinor, mMinWidthMinor); if (a.hasValue(R.styleable.Window_windowFixedWidthMajor)) &#123; if (mFixedWidthMajor == null) mFixedWidthMajor = new TypedValue(); a.getValue(R.styleable.Window_windowFixedWidthMajor, mFixedWidthMajor); &#125; if (a.hasValue(R.styleable.Window_windowFixedWidthMinor)) &#123; if (mFixedWidthMinor == null) mFixedWidthMinor = new TypedValue(); a.getValue(R.styleable.Window_windowFixedWidthMinor, mFixedWidthMinor); &#125; if (a.hasValue(R.styleable.Window_windowFixedHeightMajor)) &#123; if (mFixedHeightMajor == null) mFixedHeightMajor = new TypedValue(); a.getValue(R.styleable.Window_windowFixedHeightMajor, mFixedHeightMajor); &#125; if (a.hasValue(R.styleable.Window_windowFixedHeightMinor)) &#123; if (mFixedHeightMinor == null) mFixedHeightMinor = new TypedValue(); a.getValue(R.styleable.Window_windowFixedHeightMinor, mFixedHeightMinor); &#125; if (a.getBoolean(R.styleable.Window_windowContentTransitions, false)) &#123; requestFeature(FEATURE_CONTENT_TRANSITIONS); &#125; if (a.getBoolean(R.styleable.Window_windowActivityTransitions, false)) &#123; requestFeature(FEATURE_ACTIVITY_TRANSITIONS); &#125; final WindowManager windowService = (WindowManager) getContext().getSystemService( Context.WINDOW_SERVICE); if (windowService != null) &#123; final Display display = windowService.getDefaultDisplay(); final boolean shouldUseBottomOutset = display.getDisplayId() == Display.DEFAULT_DISPLAY || (getForcedWindowFlags() &amp; FLAG_FULLSCREEN) != 0; if (shouldUseBottomOutset &amp;&amp; a.hasValue(R.styleable.Window_windowOutsetBottom)) &#123; if (mOutsetBottom == null) mOutsetBottom = new TypedValue(); a.getValue(R.styleable.Window_windowOutsetBottom, mOutsetBottom); &#125; &#125; final Context context = getContext(); final int targetSdk = context.getApplicationInfo().targetSdkVersion; final boolean targetPreHoneycomb = targetSdk &lt; android.os.Build.VERSION_CODES.HONEYCOMB; final boolean targetPreIcs = targetSdk &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH; final boolean targetPreL = targetSdk &lt; android.os.Build.VERSION_CODES.LOLLIPOP; final boolean targetHcNeedsOptions = context.getResources().getBoolean( R.bool.target_honeycomb_needs_options_menu); final boolean noActionBar = !hasFeature(FEATURE_ACTION_BAR) || hasFeature(FEATURE_NO_TITLE); if (targetPreHoneycomb || (targetPreIcs &amp;&amp; targetHcNeedsOptions &amp;&amp; noActionBar)) &#123; addFlags(WindowManager.LayoutParams.FLAG_NEEDS_MENU_KEY); &#125; else &#123; clearFlags(WindowManager.LayoutParams.FLAG_NEEDS_MENU_KEY); &#125; // Non-floating windows on high end devices must put up decor beneath the system bars and // therefore must know about visibility changes of those. if (!mIsFloating &amp;&amp; ActivityManager.isHighEndGfx()) &#123; if (!targetPreL &amp;&amp; a.getBoolean( R.styleable.Window_windowDrawsSystemBarBackgrounds, false)) &#123; setFlags(FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS &amp; ~getForcedWindowFlags()); &#125; &#125; if (!mForcedStatusBarColor) &#123; mStatusBarColor = a.getColor(R.styleable.Window_statusBarColor, 0xFF000000); &#125; if (!mForcedNavigationBarColor) &#123; mNavigationBarColor = a.getColor(R.styleable.Window_navigationBarColor, 0xFF000000); &#125; if (mAlwaysReadCloseOnTouchAttr || getContext().getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.HONEYCOMB) &#123; if (a.getBoolean( R.styleable.Window_windowCloseOnTouchOutside, false)) &#123; setCloseOnTouchOutsideIfNotSet(true); &#125; &#125; WindowManager.LayoutParams params = getAttributes(); if (!hasSoftInputMode()) &#123; params.softInputMode = a.getInt( R.styleable.Window_windowSoftInputMode, params.softInputMode); &#125; if (a.getBoolean(R.styleable.Window_backgroundDimEnabled, mIsFloating)) &#123; /* All dialogs should have the window dimmed */ if ((getForcedWindowFlags()&amp;WindowManager.LayoutParams.FLAG_DIM_BEHIND) == 0) &#123; params.flags |= WindowManager.LayoutParams.FLAG_DIM_BEHIND; &#125; if (!haveDimAmount()) &#123; params.dimAmount = a.getFloat( android.R.styleable.Window_backgroundDimAmount, 0.5f); &#125; &#125; if (params.windowAnimations == 0) &#123; params.windowAnimations = a.getResourceId( R.styleable.Window_windowAnimationStyle, 0); &#125; // The rest are only done if this window is not embedded; otherwise, // the values are inherited from our container. if (getContainer() == null) &#123; if (mBackgroundDrawable == null) &#123; if (mBackgroundResource == 0) &#123; mBackgroundResource = a.getResourceId( R.styleable.Window_windowBackground, 0); &#125; if (mFrameResource == 0) &#123; mFrameResource = a.getResourceId(R.styleable.Window_windowFrame, 0); &#125; mBackgroundFallbackResource = a.getResourceId( R.styleable.Window_windowBackgroundFallback, 0); if (false) &#123; System.out.println(\"Background: \" + Integer.toHexString(mBackgroundResource) + \" Frame: \" + Integer.toHexString(mFrameResource)); &#125; &#125; mElevation = a.getDimension(R.styleable.Window_windowElevation, 0); mClipToOutline = a.getBoolean(R.styleable.Window_windowClipToOutline, false); mTextColor = a.getColor(R.styleable.Window_textColor, Color.TRANSPARENT); &#125; // 上面的那一块都是对Activity中设置的主题进行判断。下面就是根据不同的主题，选择不同的布局文件。 // Inflate the window decor. int layoutResource; int features = getLocalFeatures(); // System.out.println(\"Features: 0x\" + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); // System.out.println(\"Title Icons!\"); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; // Special case for a window with only a progress bar (and title). // XXX Need to have a no-title version of embedded windows. layoutResource = R.layout.screen_progress; // System.out.println(\"Progress!\"); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; // Special case for a window with a custom title. // If the window is floating, we need a dialog layout if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_custom_title; &#125; // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; // If no other features and not embedded, only need a title. // If the window is floating, we need a dialog layout if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); &#125; else &#123; layoutResource = R.layout.screen_title; &#125; // System.out.println(\"Title!\"); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; layoutResource = R.layout.screen_simple_overlay_action_mode; &#125; else &#123; // Embedded, so no decoration is needed. layoutResource = R.layout.screen_simple; // System.out.println(\"Simple!\"); &#125; mDecor.startChanging(); // inflate对应的布局文件，并添加到mDecor中。 View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; // 找到布局中android:id=\"@android:id/content\"。的ViewGroup赋值给contentParent,一般是FrameLayout ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(\"Window couldn't find content container view\"); &#125; if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) &#123; ProgressBar progress = getCircularProgressBar(false); if (progress != null) &#123; progress.setIndeterminate(true); &#125; &#125; if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; registerSwipeCallbacks(); &#125; // Remaining setup -- of background and title -- that only applies // to top-level windows. if (getContainer() == null) &#123; final Drawable background; if (mBackgroundResource != 0) &#123; background = getContext().getDrawable(mBackgroundResource); &#125; else &#123; background = mBackgroundDrawable; &#125; mDecor.setWindowBackground(background); final Drawable frame; if (mFrameResource != 0) &#123; frame = getContext().getDrawable(mFrameResource); &#125; else &#123; frame = null; &#125; mDecor.setWindowFrame(frame); mDecor.setElevation(mElevation); mDecor.setClipToOutline(mClipToOutline); if (mTitle != null) &#123; setTitle(mTitle); &#125; if (mTitleColor == 0) &#123; mTitleColor = mTextColor; &#125; setTitleColor(mTitleColor); &#125; mDecor.finishChanging(); return contentParent;&#125; 上面看到有很多相应主题的布局文件，我们就以典型的R.layout.screen_title为例看一下。12345678910111213141516171819202122232425262728293031&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:fitsSystemWindows=\"true\"&gt; &lt;!-- Popout bar for action modes --&gt; &lt;ViewStub android:id=\"@+id/action_mode_bar_stub\" android:inflatedId=\"@+id/action_mode_bar\" android:layout=\"@layout/action_mode_bar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"?attr/actionBarTheme\" /&gt; // 标题 &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"?android:attr/windowTitleSize\" style=\"?android:attr/windowTitleBackgroundStyle\"&gt; &lt;TextView android:id=\"@android:id/title\" style=\"?android:attr/windowTitleStyle\" android:background=\"@null\" android:fadingEdge=\"horizontal\" android:gravity=\"center_vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;/FrameLayout&gt; // 页面内容 &lt;FrameLayout android:id=\"@android:id/content\" android:layout_width=\"match_parent\" android:layout_height=\"0dip\" android:layout_weight=\"1\" android:foregroundGravity=\"fill_horizontal|top\" android:foreground=\"?android:attr/windowContentOverlay\" /&gt;&lt;/LinearLayout&gt; 看到这里基本差不多了，我们就以第一次调用setContentView方法为例总结一下整体的流程。 第一次调用setContentView()方法时会去创建一个DecorView，这就是整个窗口的根布局。 接着回去根据我们设置的对应主题，来加载与之对应的布局文件并将其添加到DecorView中，然后找到该布局中id=content的ViewGroup赋值给mContentParent。 将我们要设置的Activity对应的布局添加到mContentParent中。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Library项目中资源id使用case时报错","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Library项目中资源id使用case时报错/","text":"Library项目中资源id使用case时报错在平时开发的过程中对一些常量的判断，都是使用switch case语句，因为switch case比if else的效率稍高。但是也遇到了问题，就是在library中使用时会报错:1234567891011public void testClick(View view) &#123; int id = view.getId(); switch (id) &#123; case R.id.bt_pull: break; case R.id.bt_push: break; &#125;&#125; 我们来看一下错误提示: 意思就是在Android Library的Module中的switch语句不能使用资源ID.这是为什么呢？ 我们都知道R文件中都是常量啊，public static final的，为什么不能用在switch语句中，继续看下去:1Resource IDs are non final in th library projects since SDK tools r14, means that the library code cannot treat this IDs as constants. 说的灰常明白了，也就是说从14开始，library中的资源id就不是final类型的了，所以不是常量了。 在一个常规的Android项目中，资源R文件中的常量都是如下这样声明的:public static final int main=0x7f030004;然后，从ADT14开始，在library项目中，它们将被这样声明:public static int main=0x7f030004; 也就是说在library项目中这些常量不是final的了。为什么这样做的原因也非常简单：当多个library项目结合时，这些字段的实际值(必须唯一的值)可能会冲突。在ADT14之前，所有的字段都是final的，这样就导致了一个结果，就是所有的libraries不论何时在被使用时都必须把他们所有的资源和相关的Java代码都伴随着主项目一起重新编译。这样做是不合理的，因为它会导致编译非常慢。这也会阻碍一些没有源码的libraray项目进行发布，极大的限制了library项目的使用范围。 那些字段不再是final的原因就是意味着library jars可以被编译一次，然后在其他项目中直接被服用。也就是意味着允许发布二进制版本的library项目(r15中开始支持)，这让编译变的更快。 然而，这对library的源码会有一个影响。类似下面这样的代码就将无法编译:1234567891011public void testClick(View view) &#123; int id = view.getId(); switch (id) &#123; case R.id.bt_pull: break; case R.id.bt_push: break; &#125;&#125; 这是因为swtich语句要求所有case后的字段，例如R.di.bt_pull在编译的时候都应该是常量(就像可以直接把值拷贝进.class文件中) 当然针对这个问题的解决方法也很简单：就是把switch语句改成if-else语句。幸运的是，在eclise中这是非常简单的。只需要在switch的关键字上按Ctrl+1（Mac上是Cmd+1)。(eclipse都辣么方便了，Studio更不用说了啊，直接按修复的快捷键就阔以了)。上面的代码就将变成如下: 123456public void testClick(View view) &#123; int id = view.getId(); if (id == R.id.bt_pull) &#123; &#125; else if (id == R.id.bt_push) &#123; &#125;&#125; 这在UI代码和性能的影响通常是微不足道的 - -！。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"MAT内存分析","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/MAT内存分析/","text":"MAT内存分析Eclipse Memory Analyzer（MAT）是著名的跨平台集成开发环境Eclipse Galileo版本的33个组成项目中之一，它是一个功能丰富的JAVA 堆转储文件分析工具，可以帮助你发现内存漏洞和减少内存消耗。 [内存泄露介绍]{https://raw.githubusercontent.com/CharonChui/AndroidNote/blob/master/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.md} [MAT(Memory Analyzer)官网]{http://www.eclipse.org/mat/} 安装： 单机版，解压后直接使用 Eclipse插件，直接装一个插件,然后open perspective打开 Memory Analysis 使用 DDMS 进入DDMS页面，选择要分析的进程,然后点击Update Heap按钮。然后在右侧Heap页面点击一下Cause GC按钮，点击Cause GC按钮就是手动触发Java垃圾回收。 如果想要看某个Activity是否发生内存泄露，可以反复多次进入和退出该页面, 然后点击几次Cause GC触发垃圾回收， 看一下上图中data object这一栏中的Total Size的大小是保持稳定还是有明显的变大趋势，如果有明显的变大趋势就说明这个页面存在内存泄露的问题，需要进行具体分析。 很长时间之前学习的，一直想记录出来，总是忙，到现在才开始整理，但是现在已经很少用MAT了，因为它太费劲了。自从良心企业发布了leakCanary后，都已经转投到大神门下。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Mac下配置adb及Android命令","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Mac下配置adb及Android命令/","text":"Mac下配置adb及Android命令带着欣喜若狂的心情，买了一个Mac本，刚拿到它的时候感觉真的是一件艺术品，哈哈。废话不多说，里面配置Android开发环境。 找到android sdk的本地路径， 我的是： ADB /Android/adt-bundle-mac-x86_64-20131030/sdk/platform-tools Android /Android/adt-bundle-mac-x86_64-20131030/sdk/tools 打开终端输入 touch .bash_profile创建 open -e .bash_profile打开 添加路径 .bash_profile打开了，我们在这里添加路径， 如果打开的文档里面已经有内容,我们只要之后添加:XXXX(注意前面一定要用冒号隔开) 如果是一个空白文档的话，我们就输入一下内容 export PATH=${PATH}:XXXX我的是export PATH=${PATH}:/Android/adt-bundle-mac-x86_64-20131030/sdk/tools:${PATH}:/Android/adt-bundle-mac-x86_64-20131030/sdk/platform-tools;保存，关掉这个文档， 终端输入命令 source .bash_profile 大功告成 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Markdown学习手册","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Markdown学习手册/","text":"Markdown学习手册一. 简单功能 功能 效果 Markdown代码 备注 粗体 粗体 **粗体** 两边加** 斜体 斜体 _斜体_ 两边加_ 中划线 中划线 ~~中划线~~ 两边加~~ 单行代码 Log.i(&quot;Hello World!&quot;) `Log.i(“Hello World!”)` 两边加` 插入图片 ![Image](https://raw.githubusercontent.com/CharonChui/Pictures/master/rss.png?raw=true) [] 中间为占位符,() 中间为图片链接 链接 Visit Github [Visit Github](http://www.github.com) [] 中间为显示文字,() 中间为链接 二. 其他功能1. 换行在需要换行的地方敲击两次空格和一个回车键即可，如: 12这是第一行(空格)(空格)(回车)这是第二行 Tip: 多条新行都会被视为一行 2. 标题Markdown 提供了六种规格的标题，分别对应 Html 标签中的&lt;h1&gt;-&lt;h6&gt;，通过添加不同数量的#字符可以实现不同大小的标题，如:1234# 最大的标题(相当于一个&lt;h1&gt;标签)## 次大的标题(相当于一个&lt;h2&gt;标签)...###### 最小的标题(相当于一个&lt;h6&gt;标签) Tip: # 越多，标题越小 或者利用 = （最高阶标题）和 - （第二阶标题），任何数量的 = 和 - 都可以有效果。例如：12345678910111213141516H1===H2---``` 效果为:H1===H2---##### 3. 列表 ###### 3.1 有序列表数字 + . + 空格即可，以下代码： 项目1 项目2 项目3 1234567效果为： 1. 项目1 2. 项目2 3. 项目3 ###### 3.2 无序列表 以 * 和空格开头即可，以下代码: 项目1 项目2 项目3 1234567效果为： * 项目1* 项目2* 项目3###### 3.3 子项目表示： 子项目缩进一个 tab 并加 * 和 空格表示，以下代码： 项目1 子项目1 子项目2 项目2 子项目112345678910效果为： * 项目1 * 子项目1 * 子项目2* 项目2 * 子项目1##### 4. 代码块以 \\`\\`\\` 和 \\`\\`\\` 包含，以下代码： &lt;pre&gt;&lt;code&gt; def hello(): print ‘Hello World!’12&lt;/code&gt;&lt;/pre&gt;效果为： def hello(): print ‘Hello World!’1234567GFM 扩展了 Markdown 的代码块功能，通过在上面第一个 \\`\\`\\` 后添加语言名称，使不同语言展现不同的代码高亮风格，以下代码: &lt;pre&gt;&lt;code&gt;```javapublic static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;);&#125; 效果为：123public static void main(String[] args)&#123; System.out.println(\"Hello World!\");&#125; 以下代码： 12def hello(): print 'Hello World!' 效果为：12def hello(): print 'Hello World!' 5. 表格标准的 Markdown 中并不支持表格，但 GFM 可以，表头前空一行，以 --- 做为表头分隔，以 | 做为列分隔，以下代码：1234表头1|表头2---|---单元格1|单元格2单元格3|单元格4 效果为： 表头1 表头2 单元格1 单元格2 单元格3 单元格4 而且还可以通过在表头分隔符中添加 : 来决定单元格的对齐方向，以下代码：1234表头1|表头2|表头3:--|:--:|--:左1|中1|右1左2|中2|右2 效果为： 表头1 表头2 表头3 左1 中1 右1 左2 中2 右2 6. 特殊字符转义如果需要在正文里使用特殊字符的话，可以用 \\ 来转义 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"ART与Dalvik","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/ART与Dalvik/","text":"ART与DalvikARTAndroid 4.4提供了一种与Dalvik截然不同的运行环境ART支持,ART源于google收购的Flexycore的公司。ART模式与Dalvik模式最大的不同在于，启用ART模式后，系统在安装应用的时候会进行一次预编译，将字节码转换为机器语言存储在本地，这样在运行程序时就不会每次都进行一次编译了，执行效率也大大提升。ART代表Android Runtime，其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time (JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT）编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。总体的理念就是空间换时间。 DalvikDalvik是Google公司自己设计用于Android平台的Java虚拟机。它可以支持已转换为.dex（即Dalvik Executable）格式的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。 AOT的编译器分两种模式： 在开发机上编译预装应用； 在设备上编译新安装的应用,在应用安装时将dex字节码翻译成本地机器码。 ART优点: 系统性能的显著提升。 应用启动更快、运行更快、体验更流畅、触感反馈更及时。 更长的电池续航能力。 支持更低的硬件。 ART缺点: 更大的存储空间占用，可能会增加10%-20%。 更长的应用安装时间。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"RecyclerView专题","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/RecyclerView专题/","text":"RecyclerView专题简介RecyclerView是Android 5.0提供的新控件，已经用了很长时间了，但是一直没有时间去仔细的梳理一下。现在项目不太紧，决定来整理下。 官方文档中是这样介绍的:A flexible view for providing a limited window into a large data set. RecyclerView比listview更先进更灵活，对于很多的视图它就是一个容器，可以有效的重用和滚动。当数据动态变化的时候请使用它。 #####专业术语: Adapter: A subclass of RecyclerView.Adapter responsible for providing views that represent items in a data set. Position: The position of a data item within an Adapter. Index: The index of an attached child view as used in a call to getChildAt(int). Contrast with Position. Binding: The process of preparing a child view to display data corresponding to a position within the adapter. Recycle (view): A view previously used to display data for a specific adapter position may be placed in a cache for later reuse to display the same type of data again later. This can drastically improve performance by skipping initial layout inflation or construction. Scrap (view): A child view that has entered into a temporarily detached state during layout. Scrap views may be reused without becoming fully detached from the parent RecyclerView, either unmodified if no rebinding is required or modified by the adapter if the view was considered dirty. Dirty (view): A child view that must be rebound by the adapter before being displayed. #####RecyclerView中的位置: RecyclerView在RecyclerView.Adapter和RecyclerView.LayoutManager中引进了一个抽象的额外中间层来保证在布局计算的过程中能批量的监听到数据变化。这样介绍了LayoutManager追踪adapter数据变化来计算动画的时间。因为所有的View绑定都是在同一时间执行，所以这样也提高了性能和避免了一些非必要的绑定。因为这个原因，在RecylcerView中有两种position类型相关的方法: layout position: 在最近一次layout计算是item的位置。这是LayoutManager角度中的位置。 adapter position: item在adapter中的位置。这是从Adapter的角度中的位置。 这两种position除了在分发adapter.notify*事件与之后计算布局更新的这段时间之内外都是相同的。可以通过getLayoutPosition(),findViewHolderForLayoutPosition(int)方法来获取最近一次布局计算的LayoutPosition。这些positions包括从最近一次布局计算的所有改变。你可以根据这些位置来方便的得到用户当前从屏幕上所看到的。例如，如果在屏幕上有一个列表，用户请求的是第五个条目，你可以通过该方法来匹配当前用户正在看的内容。 另一种AdapterPosition相关的方法是getAdapterPosition(),findViewHolderForAdapterPosition(int)，当及时一些数据可能没有来得及被展现到布局上时便需要获取最新的adapter位置可以使用这些相关的方法。例如，如果你想获取一个条目的ViewHOlder的click事件时，你应该使用getAdapterPosition()。需要知道这些方法在notifyDataSetChange()方法被调用和新布局还没有被计算之前是不能使用的。鉴于这个原因，你应该小心的去处理这些方法有可能返回NO_POSITION或者null的情况。 ###结构 RecyclerView.Adapter: 创建View并将数据集合绑定到View上 ViewHolder: 持有所有的用于绑定数据或者需要操作的View LayoutManager: 布局管理器，负责摆放视图等相关操作 ItemDecoration: 负责绘制Item附近的分割线，通过RecyclerView.addItemDecoration()使用 ItemAnimator: 为Item的操作添加动画效果，如，增删条目等，通过RecyclerView.setItemAnimator(new DefaultItemAnimator());使用 下图能更直观的了解: #####RecyclerView提供这些内置布局管理器: LinearLayoutManager: 以垂直或水平滚动列表方式显示项目。 GridLayoutManager: 在网格中显示项目。 StaggeredGridLayoutManager: 在分散对齐网格中显示项目。 #####RecyclerView.ItemDecoration是一个抽象类，可以通过重写以下三个方法，来实现Item之间的偏移量或者装饰效果: public void onDraw(Canvas c, RecyclerView parent) 装饰的绘制在Item条目绘制之前调用，所以这有可能被Item的内容所遮挡 public void onDrawOver(Canvas c, RecyclerView parent) 装饰的绘制在Item条目绘制之后调用，因此装饰将浮于Item之上 public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) 与padding或margin类似，LayoutManager在测量阶段会调用该方法，计算出每一个Item的正确尺寸并设置偏移量。 #####ItemAnimator触发于以下三种事件: 某条数据被插入到数据集合中 从数据集合中移除某条数据 更改数据集合中的某条数据 在之前的版本中，当时据集合发生改变时通过调用notifyDataSetChanged()，来刷新列表，因为这样做会触发列表的重绘，所以并不会出现任何动画效果，因此需要调用一些以notifyItem*()作为前缀的特殊方法，比如: public final void notifyItemInserted(int position) 向指定位置插入Item public final void notifyItemRemoved(int position) 移除指定位置Item public final void notifyItemChanged(int position) 更新指定位置Item ###使用介绍: 添加依赖库 123dependencies &#123; compile &apos;com.android.support:recyclerview-v7:23.4.0&apos;&#125; 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class MainActivity extends AppCompatActivity &#123; private RecyclerView mRecyclerView; private LinearLayoutManager mLayoutManager; private RecyclerView.Adapter mAdapter; private String [] mDatas = &#123;\"Android\",\"ios\",\"jack\",\"tony\",\"window\",\"mac\",\"1234\",\"hehe\",\"495948\", \"89757\", \"66666\"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findView(); initView(); &#125; private void findView() &#123; mRecyclerView = (RecyclerView) findViewById(R.id.rv); &#125; private void initView() &#123; // use this setting to improve performance if you know that changes // in content do not change the layout size of the RecyclerView mRecyclerView.setHasFixedSize(true); // use a linear layout manager mLayoutManager = new LinearLayoutManager(this); mLayoutManager.setOrientation(LinearLayoutManager.VERTICAL); mRecyclerView.setLayoutManager(mLayoutManager); mAdapter = new MyAdapter(mDatas); mRecyclerView.setAdapter(mAdapter); &#125; private class MyAdapter extends RecyclerView.Adapter&lt;MyHolder&gt; &#123; private String[] mData; public MyAdapter(String[] data) &#123; mData = data; &#125; @Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; // create a new view View v = LayoutInflater.from(parent.getContext()).inflate( R.layout.item, parent, false); MyHolder holder = new MyHolder(v); return holder; &#125; @Override public void onBindViewHolder(MyHolder holder, int position) &#123; holder.mTitleTv.setText(mData[position]); &#125; @Override public int getItemCount() &#123; return mData == null ? 0 : mData.length; &#125; &#125; static class MyHolder extends RecyclerView.ViewHolder &#123; public TextView mTitleTv; public MyHolder(View itemView) &#123; super(itemView); mTitleTv = (TextView) itemView; &#125; &#125;&#125; `activity_main的内容如下: ` 1234&lt;android.support.v7.widget.RecyclerView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/rv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; `item的内容如下：` 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;TextView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:padding=\"20dp\" android:gravity=\"center_horizontal\" android:textSize=\"30dp\"&gt;&lt;/TextView&gt; ###点击事件 之前在使用ListView的时候，设置点击事件是非常方便的。12mListView.setOnItemClickListener();mListView.setOnItemLongClickListener(); 但是RecylcerView确没有提供类似的方法。那我们只能是自己去处理。处理的方式也有两种: 通过itemView.onClickListener()以及onLongClickListener() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class MainActivity extends AppCompatActivity &#123; private RecyclerView mRecyclerView; private LinearLayoutManager mLayoutManager; private MyAdapter mAdapter; private String[] mDatas = &#123;\"Android\", \"ios\", \"jack\", \"tony\", \"window\", \"mac\", \"1234\", \"hehe\", \"495948\", \"89757\", \"66666\"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findView(); initView(); &#125; private void findView() &#123; mRecyclerView = (RecyclerView) findViewById(R.id.rv); &#125; private void initView() &#123; // use this setting to improve performance if you know that changes // in content do not change the layout size of the RecyclerView mRecyclerView.setHasFixedSize(true); // use a linear layout manager mLayoutManager = new LinearLayoutManager(this); mLayoutManager.setOrientation(LinearLayoutManager.VERTICAL); mRecyclerView.setLayoutManager(mLayoutManager); mAdapter = new MyAdapter(mDatas); mAdapter.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(View view, int position) &#123; Toast.makeText(MainActivity.this, \"click \" + mDatas[position], Toast.LENGTH_SHORT).show(); &#125; &#125;); mAdapter.setOnItemLongClickListener(new OnItemLongClickListener() &#123; @Override public void onItemLongClick(View view, int position) &#123; Toast.makeText(MainActivity.this, \"long click \" + mDatas[position], Toast.LENGTH_SHORT).show(); &#125; &#125;); mRecyclerView.setAdapter(mAdapter); &#125; class MyAdapter extends RecyclerView.Adapter&lt;MyHolder&gt; &#123; private String[] mData; public MyAdapter(String[] data) &#123; mData = data; &#125; @Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; // create a new view View v = LayoutInflater.from(parent.getContext()).inflate( R.layout.item, parent, false); MyHolder holder = new MyHolder(v); return holder; &#125; @Override public void onBindViewHolder(final MyHolder holder, final int position) &#123; holder.mTitleTv.setText(mData[position]); if (mOnItemClickListener != null) &#123; holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mOnItemClickListener.onItemClick(holder.itemView, position); &#125; &#125;); &#125; if (mOnItemLongClickListener != null) &#123; holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; mOnItemLongClickListener.onItemLongClick(holder.itemView, position); return true; &#125; &#125;); &#125; &#125; @Override public int getItemCount() &#123; return mData == null ? 0 : mData.length; &#125; private OnItemClickListener mOnItemClickListener; private OnItemLongClickListener mOnItemLongClickListener; public void setOnItemClickListener(OnItemClickListener mOnItemClickListener) &#123; this.mOnItemClickListener = mOnItemClickListener; &#125; public void setOnItemLongClickListener(OnItemLongClickListener mOnItemLongClickListener) &#123; this.mOnItemLongClickListener = mOnItemLongClickListener; &#125; &#125; static class MyHolder extends RecyclerView.ViewHolder &#123; public TextView mTitleTv; public MyHolder(View itemView) &#123; super(itemView); mTitleTv = (TextView) itemView; &#125; &#125; public interface OnItemClickListener &#123; void onItemClick(View view, int position); &#125; public interface OnItemLongClickListener &#123; void onItemLongClick(View view, int position); &#125;&#125; 使用RecyclerView.OnItemTouchListener 虽然没有提供现成的监听器，但是提供了一个内部接口OnItemTouchListener。 先来看看它的介绍: 123456789101112131415/** * An OnItemTouchListener allows the application to intercept touch events in progress at the * view hierarchy level of the RecyclerView before those touch events are considered for * RecyclerView&apos;s own scrolling behavior. * * &lt;p&gt;This can be useful for applications that wish to implement various forms of gestural * manipulation of item views within the RecyclerView. OnItemTouchListeners may intercept * a touch interaction already in progress even if the RecyclerView is already handling that * gesture stream itself for the purposes of scrolling.&lt;/p&gt; * * @see SimpleOnItemTouchListener */public static interface OnItemTouchListener &#123; ...&#125; 说的和明白了，而且还让你看SimpleOnItemTouchListener，猜也能猜出来是一个默认的实现类。 好了直接上代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class MainActivity extends AppCompatActivity &#123;private RecyclerView mRecyclerView;private LinearLayoutManager mLayoutManager;private MyAdapter mAdapter;private String[] mDatas = &#123;\"Android\", \"ios\", \"jack\", \"tony\", \"window\", \"mac\", \"1234\", \"hehe\", \"495948\", \"89757\", \"66666\"&#125;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findView(); initView();&#125;private void findView() &#123; mRecyclerView = (RecyclerView) findViewById(R.id.rv);&#125;private void initView() &#123; // use this setting to improve performance if you know that changes // in content do not change the layout size of the RecyclerView mRecyclerView.setHasFixedSize(true); // use a linear layout manager mLayoutManager = new LinearLayoutManager(this); mLayoutManager.setOrientation(LinearLayoutManager.VERTICAL); mRecyclerView.setLayoutManager(mLayoutManager); mAdapter = new MyAdapter(mDatas); mRecyclerView.setAdapter(mAdapter); mRecyclerView.addOnItemTouchListener(new RecyclerViewClickListener(this, mRecyclerView, new OnItemClickListener() &#123; @Override public void onItemClick(View view, int position) &#123; Toast.makeText(MainActivity.this, mDatas[position], Toast.LENGTH_SHORT).show(); &#125; @Override public void onItemLongClick(View view, int position) &#123; Toast.makeText(MainActivity.this, \"Long Click \" + mDatas[position], Toast.LENGTH_SHORT).show(); &#125; &#125;));&#125;class RecyclerViewClickListener extends RecyclerView.SimpleOnItemTouchListener &#123; private GestureDetector mGestureDetector; private OnItemClickListener mListener; public RecyclerViewClickListener(Context context, final RecyclerView recyclerView, OnItemClickListener listener) &#123; mListener = listener; mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() &#123; @Override public boolean onSingleTapUp(MotionEvent e) &#123; View childView = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (childView != null &amp;&amp; mListener != null) &#123; mListener.onItemClick(childView, recyclerView.getChildLayoutPosition(childView)); return true; &#125; return false; &#125; @Override public void onLongPress(MotionEvent e) &#123; View childView = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (childView != null &amp;&amp; mListener != null) &#123; mListener.onItemLongClick(childView, recyclerView.getChildLayoutPosition(childView)); &#125; &#125; &#125;); &#125; @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) &#123; if (mGestureDetector.onTouchEvent(e)) &#123; return true; &#125; else return super.onInterceptTouchEvent(rv, e); &#125; @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) &#123; super.onTouchEvent(rv, e); &#125; @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; super.onRequestDisallowInterceptTouchEvent(disallowIntercept); &#125;&#125;interface OnItemClickListener &#123; void onItemClick(View view, int position); void onItemLongClick(View view, int position);&#125; 上面的实现稍微有些缺陷，就是如果我手指按住某个条目一直不抬起，他也会执行Long click事件，这显然是不合理的，至于怎么解决，就是可以不用GestureDetector，自己在DOWN和UP事件中去判断处理。 Headerview FooterView之前在ListView中提供了addHeaderView()和addFooterView()等方法，但是在RecyclerView中并没有提供类似的方法，那我们该如何添加呢？ 也很简单，就是通过Adapter中去添加，利用不同的itemViewType，然后根据不同的类型去在onCreateViewHOlder中创建不同的视图，通过这种方式来达到headerview和FooterView的效果。 上一段简单的示例代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 public class HeaderAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; private static final int TYPE_HEADER = 0; private static final int TYPE_ITEM = 1; String[] data; public HeaderAdapter(String[] data) &#123; this.data = data; &#125; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (viewType == TYPE_ITEM) &#123; //inflate your layout and pass it to view holder return new VHItem(null); &#125; else if (viewType == TYPE_HEADER) &#123; //inflate your layout and pass it to view holder return new VHHeader(null); &#125; throw new RuntimeException(\"there is no type that matches the type \" + viewType + \" + make sure your using types correctly\"); &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; if (holder instanceof VHItem) &#123; String dataItem = getItem(position); //cast holder to VHItem and set data &#125; else if (holder instanceof VHHeader) &#123; //cast holder to VHHeader and set data for header. &#125; &#125; @Override public int getItemCount() &#123; return data.length + 1; &#125; @Override public int getItemViewType(int position) &#123; if (isPositionHeader(position)) return TYPE_HEADER; return TYPE_ITEM; &#125; private boolean isPositionHeader(int position) &#123; return position == 0; &#125; private String getItem(int position) &#123; return data[position - 1]; &#125; class VHItem extends RecyclerView.ViewHolder &#123; TextView title; public VHItem(View itemView) &#123; super(itemView); &#125; &#125; class VHHeader extends RecyclerView.ViewHolder &#123; Button button; public VHHeader(View itemView) &#123; super(itemView); &#125; &#125;&#125; 上面的代码对LinearLayoutManger是没问题的，但是使用GridLayoutManager呢？ 如果是两列，那添加的HeaderView并不是占据上第一行，而是HeaderView与第二个ItemView一起占据第一行。那该怎么处理呢？那就是使用setSpanSizeLookup()方法。比如:1recyclerView.setLayoutManager(new GridLayoutManager(this, 2)); 在上面的基本设置中，我们的spanCount为2，每个item的span size为1，因此一个header需要的span size则为2。在我尝试着添加header之前，我想先看看如何设置span size。其实很简单。12345678final GridLayoutManager manager = new GridLayoutManager(this, 2);recyclerView.setLayoutManager(manager);manager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; return adapter.isHeader(position) ? manager.getSpanCount() : 1; &#125;&#125;); 下拉刷新、自动加载#####实现下拉刷新实现下拉刷新也很简单了，可以使用SwipeRefrshLayout,SwipeRefrshLayout是Google官方提供的组件，可以实现下拉刷新的功能。已包含到support.v4包中。 主要方法有: setOnRefreshListener(OnRefreshListener):添加下拉刷新监听器 setRefreshing(boolean):显示或者隐藏刷新进度条 isRefreshing():检查是否处于刷新状态 setColorSchemeResources():设置进度条的颜色主题，最多设置四种。 12345678910&lt;android.support.v4.widget.SwipeRefreshLayout android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:scrollbars=\"vertical\" &gt; &lt;android.support.v7.widget.RecyclerView android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" &gt;&lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 具体实现就不写了。 #####实现滑动自动加载更多功能 实现方式和ListView的实现方式类似，就是通过监听scroll时间，然后判断当前显示的item。 12345678910111213141516171819202122232425//RecyclerView滑动监听mRecylcerView.setOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if (newState ==RecyclerView.SCROLL_STATE_IDLE &amp;&amp; lastVisibleItem + 1 ==adapter.getItemCount()) &#123; new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; List&lt;String&gt; newDatas = new ArrayList&lt;String&gt;(); for (int i = 0; i&lt; 5; i++) &#123; int index = i +1; newDatas.add(\"more item\" + index); &#125; adapter.addMoreItem(newDatas); &#125; &#125;,1000); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView,dx, dy); lastVisibleItem =linearLayoutManager.findLastVisibleItemPosition(); &#125;&#125;); 然后再通过结合FooterView以及增加几种状态就可以实现自动加载更多了。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"VideoView源码分析","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/VideoView源码分析/","text":"VideoView源码分析VideoView基于Android4.4源码进行分析 简介 1234567891011121314151617/** * Displays a video file. The VideoView class * can load images from various sources (such as resources or content * providers), takes care of computing its measurement from the video so that * it can be used in any layout manager, and provides various display options * such as scaling and tinting.&lt;p&gt; * * &lt;em&gt;Note: VideoView does not retain its full state when going into the * background.&lt;/em&gt; In particular, it does not restore the current play state, * play position, selected tracks, or any subtitle tracks added via * &#123;@link #addSubtitleSource addSubtitleSource()&#125;. Applications should * save and restore these on their own in * &#123;@link android.app.Activity#onSaveInstanceState&#125; and * &#123;@link android.app.Activity#onRestoreInstanceState&#125;.&lt;p&gt; * Also note that the audio session id (from &#123;@link #getAudioSessionId&#125;) may * change from its previously returned value when the VideoView is restored. */ 关系 12public class VideoView extends SurfaceView implements MediaPlayerControl 成员 播放器所有的状态 12345678// all possible internal statesprivate static final int STATE_ERROR = -1;private static final int STATE_IDLE = 0;private static final int STATE_PREPARING = 1;private static final int STATE_PREPARED = 2;private static final int STATE_PLAYING = 3;private static final int STATE_PAUSED = 4;private static final int STATE_PLAYBACK_COMPLETED = 5; 记录播放器状态 1234567891011121314 // mCurrentState is a VideoView object's current state. // mTargetState is the state that a method caller intends to reach. // For instance, regardless the VideoView object's current state, // calling pause() intends to bring the object to a target state // of STATE_PAUSED. private int mCurrentState = STATE_IDLE; private int mTargetState = STATE_IDLE; ``` - 主要功能部分 ```java private SurfaceHolder mSurfaceHolder = null;// 显示图像 private MediaPlayer mMediaPlayer = null; // 声音、播放 private MediaController mMediaController; // 播放控制 其他 12345private int mVideoWidth; // 视频宽度 在onVideoSizeChanged() 和 onPrepared() 中可以得到具体大小private int mVideoHeight; //视频高度private int mSurfaceWidth; // Surface宽度 在SurfaceHolder.Callback.surfaceChanged() 中可以得到具体大小private int mSurfaceHeight; // Surface高度private int mSeekWhenPrepared; // recording the seek position while preparing 具体实现 构造方法 1234567891011121314public VideoView(Context context) &#123; super(context); initVideoView();&#125;public VideoView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); initVideoView();&#125;public VideoView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); initVideoView();&#125; 1234567891011121314151617181920// 进行一些必要信息的初始化设置private void initVideoView() &#123; mVideoWidth = 0; mVideoHeight = 0; // 通过SurfaceHolder去控制SurfaceView getHolder().addCallback(mSHCallback); // Deprecated. this is ignored, this value is set automatically when needed.Android3.0以上会自动设置，但是为了兼容还需设置 getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); setFocusable(true); setFocusableInTouchMode(true); requestFocus(); // 字幕相关，用不到 mPendingSubtitleTracks = new Vector&lt;Pair&lt;InputStream, MediaFormat&gt;&gt;(); mCurrentState = STATE_IDLE; mTargetState = STATE_IDLE;&#125; SurfaceHolder.Callback源码 123456789101112131415161718192021222324252627282930313233SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()&#123; public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) &#123; mSurfaceWidth = w; mSurfaceHeight = h; boolean isValidState = (mTargetState == STATE_PLAYING); boolean hasValidSize = (mVideoWidth == w &amp;&amp; mVideoHeight == h); if (mMediaPlayer != null &amp;&amp; isValidState &amp;&amp; hasValidSize) &#123; if (mSeekWhenPrepared != 0) &#123; seekTo(mSeekWhenPrepared); &#125; // 如果当前已经是播放状态的话就调用mediaplaer.start() 方法，并且把当前状态以及目标状态进行改变 start(); &#125; &#125; public void surfaceCreated(SurfaceHolder holder) &#123; mSurfaceHolder = holder; // Surface创建后就开始调用播放 openVideo(); &#125; public void surfaceDestroyed(SurfaceHolder holder) &#123; // after we return from this we can't use the surface any more mSurfaceHolder = null; if (mMediaController != null) mMediaController.hide(); release(true); &#125;&#125;; - 重写onMeasure()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int width = getDefaultSize(mVideoWidth, widthMeasureSpec); int height = getDefaultSize(mVideoHeight, heightMeasureSpec); // ....根据视频的宽高比进行处理， 为了更好的宽展，提供一些用户能自己选择的模式，一般会另外提供方法, 这部分代码可以先不看 start int width = getDefaultSize(mVideoWidth, widthMeasureSpec); int height = getDefaultSize(mVideoHeight, heightMeasureSpec); if (mVideoWidth &gt; 0 &amp;&amp; mVideoHeight &gt; 0) &#123; int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.EXACTLY &amp;&amp; heightSpecMode == MeasureSpec.EXACTLY) &#123; // the size is fixed width = widthSpecSize; height = heightSpecSize; // for compatibility, we adjust size based on aspect ratio if ( mVideoWidth * height &lt; width * mVideoHeight ) &#123; //Log.i(\"@@@\", \"image too wide, correcting\"); width = height * mVideoWidth / mVideoHeight; &#125; else if ( mVideoWidth * height &gt; width * mVideoHeight ) &#123; //Log.i(\"@@@\", \"image too tall, correcting\"); height = width * mVideoHeight / mVideoWidth; &#125; &#125; else if (widthSpecMode == MeasureSpec.EXACTLY) &#123; // only the width is fixed, adjust the height to match aspect ratio if possible width = widthSpecSize; height = width * mVideoHeight / mVideoWidth; if (heightSpecMode == MeasureSpec.AT_MOST &amp;&amp; height &gt; heightSpecSize) &#123; // couldn't match aspect ratio within the constraints height = heightSpecSize; &#125; &#125; else if (heightSpecMode == MeasureSpec.EXACTLY) &#123; // only the height is fixed, adjust the width to match aspect ratio if possible height = heightSpecSize; width = height * mVideoWidth / mVideoHeight; if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; width &gt; widthSpecSize) &#123; // couldn't match aspect ratio within the constraints width = widthSpecSize; &#125; &#125; else &#123; // neither the width nor the height are fixed, try to use actual video size width = mVideoWidth; height = mVideoHeight; if (heightSpecMode == MeasureSpec.AT_MOST &amp;&amp; height &gt; heightSpecSize) &#123; // too tall, decrease both width and height height = heightSpecSize; width = height * mVideoWidth / mVideoHeight; &#125; if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; width &gt; widthSpecSize) &#123; // too wide, decrease both width and height width = widthSpecSize; height = width * mVideoHeight / mVideoWidth; &#125; &#125; &#125; else &#123; // no size yet, just adopt the given spec sizes &#125; // end setMeasuredDimension(width, height); &#125; - 附上getDefaultSize()源码 12345678910111213141516171819202122232425/** * Utility to return a default size. Uses the supplied size if the * MeasureSpec imposed no constraints. Will get larger if allowed * by the MeasureSpec. * * @param size Default size for this view * @param measureSpec Constraints imposed by the parent * @return The size this view should be. */public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; - 外部进行播放调用 123456789101112131415161718192021public void setVideoPath(String path) &#123; setVideoURI(Uri.parse(path));&#125;public void setVideoURI(Uri uri) &#123; setVideoURI(uri, null);&#125;/** * @hide */public void setVideoURI(Uri uri, Map&lt;String, String&gt; headers) &#123; mUri = uri; mHeaders = headers; mSeekWhenPrepared = 0; openVideo(); requestLayout(); invalidate();&#125; - openVide() 源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private void openVideo() &#123; if (mUri == null || mSurfaceHolder == null) &#123; // not ready for playback just yet, will try again later return; &#125; // Tell the music playback service to pause // TODO: these constants need to be published somewhere in the framework. Intent i = new Intent(\"com.android.music.musicservicecommand\"); i.putExtra(\"command\", \"pause\"); mContext.sendBroadcast(i); // we shouldn't clear the target state, because somebody might have // called start() previously // 先把已经存在的MediaPlayer释放掉，然后重新创建一个, 不一定只在SetVideoPath() 中调用，在其他地方也会调用 release(false); try &#123; // 创建一个MediaPlayer mMediaPlayer = new MediaPlayer(); // TODO: create SubtitleController in MediaPlayer, but we need // a context for the subtitle renderers final Context context = getContext(); final SubtitleController controller = new SubtitleController( context, mMediaPlayer.getMediaTimeProvider(), mMediaPlayer); controller.registerRenderer(new WebVttRenderer(context)); mMediaPlayer.setSubtitleAnchor(controller, this); if (mAudioSession != 0) &#123; mMediaPlayer.setAudioSessionId(mAudioSession); &#125; else &#123; mAudioSession = mMediaPlayer.getAudioSessionId(); &#125; // 设置一些必要的监听 mMediaPlayer.setOnPreparedListener(mPreparedListener); mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener); mMediaPlayer.setOnCompletionListener(mCompletionListener); mMediaPlayer.setOnErrorListener(mErrorListener); mMediaPlayer.setOnInfoListener(mInfoListener); mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener); mCurrentBufferPercentage = 0; // 让MediaPlayer进行播放 mMediaPlayer.setDataSource(mContext, mUri, mHeaders); // 让SurfaceView进行画面显示 mMediaPlayer.setDisplay(mSurfaceHolder); // 设置音频类型 mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC); // 播放时屏幕常亮 mMediaPlayer.setScreenOnWhilePlaying(true); // Prepares the player for playback, asynchronously. After setting the datasource and the display surface, you need to either call prepare() or prepareAsync(). For streams, you should call prepareAsync(), // which returns immediately, rather than blocking until enough data has been buffered. mMediaPlayer.prepareAsync(); for (Pair&lt;InputStream, MediaFormat&gt; pending: mPendingSubtitleTracks) &#123; try &#123; mMediaPlayer.addSubtitleSource(pending.first, pending.second); &#125; catch (IllegalStateException e) &#123; mInfoListener.onInfo( mMediaPlayer, MediaPlayer.MEDIA_INFO_UNSUPPORTED_SUBTITLE, 0); &#125; &#125; // we don't set the target state here either, but preserve the // target state that was there before. mCurrentState = STATE_PREPARING; // 如果已经调用过SetMediaController() 方法，这里会直接显示 attachMediaController(); &#125; catch (IOException ex) &#123; Log.w(TAG, \"Unable to open content: \" + mUri, ex); mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0); return; &#125; catch (IllegalArgumentException ex) &#123; Log.w(TAG, \"Unable to open content: \" + mUri, ex); mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0); return; &#125; finally &#123; mPendingSubtitleTracks.clear(); &#125;&#125; release() 方法,在开始播放一个视频的时候会先调用该方法，然后重新创建一个，在SurfaceView销毁的时候也会调用该方法 123456789101112131415/* * release the media player in any state */private void release(boolean cleartargetstate) &#123; if (mMediaPlayer != null) &#123; mMediaPlayer.reset(); mMediaPlayer.release(); mMediaPlayer = null; mPendingSubtitleTracks.clear(); mCurrentState = STATE_IDLE; if (cleartargetstate) &#123; mTargetState = STATE_IDLE; &#125; &#125;&#125; - 外部停止播放调用 123456789public void stopPlayback() &#123; if (mMediaPlayer != null) &#123; mMediaPlayer.stop(); mMediaPlayer.release(); mMediaPlayer = null; mCurrentState = STATE_IDLE; mTargetState = STATE_IDLE; &#125;&#125; - 外部设置控制栏部分 1234567891011121314151617181920public void setMediaController(MediaController controller) &#123; if (mMediaController != null) &#123; mMediaController.hide(); &#125; mMediaController = controller; attachMediaController();&#125;private void attachMediaController() &#123; if (mMediaPlayer != null &amp;&amp; mMediaController != null) &#123; // setMediaPlayer(MediaPlayerControl player), 让MediaPlayer相应的控制部分调用本类中的实现方法 mMediaController.setMediaPlayer(this); View anchorView = this.getParent() instanceof View ? (View)this.getParent() : this; // 创建Controller并且依据AnchorView的位置进行显示 mMediaController.setAnchorView(anchorView); mMediaController.setEnabled(isInPlaybackState()); &#125;&#125; - MediaPlayer必要监听 - OnVideoSizeChangedListener 12345678910111213MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener = new MediaPlayer.OnVideoSizeChangedListener() &#123; public void onVideoSizeChanged(MediaPlayer mp, int width, int height) &#123; mVideoWidth = mp.getVideoWidth(); mVideoHeight = mp.getVideoHeight(); if (mVideoWidth != 0 &amp;&amp; mVideoHeight != 0) &#123; // 这个方法是设置Surface分辨率，而不是设置视频播放窗口的大小，视频播放窗口大小是由SurfaceView的布局控制，要分清Surface与SurfaceView的区别，Surface是Window中整个的一个控件(句柄), // 而SurfaceView是一个包含Surface的View，SurfaceView覆盖到Surface上(可以这样理解)，我们只能通过SurfaceView来看Surface中的内容,至于在SurfaceView显示之外的Surface我们是不可见的. getHolder().setFixedSize(mVideoWidth, mVideoHeight); requestLayout(); &#125; &#125;&#125;; - OnPreparedListener 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() &#123; public void onPrepared(MediaPlayer mp) &#123; mCurrentState = STATE_PREPARED; // Get the capabilities of the player for this stream Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL, MediaPlayer.BYPASS_METADATA_FILTER); if (data != null) &#123; mCanPause = !data.has(Metadata.PAUSE_AVAILABLE) || data.getBoolean(Metadata.PAUSE_AVAILABLE); mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE) || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE); mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE) || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE); &#125; else &#123; mCanPause = mCanSeekBack = mCanSeekForward = true; &#125; if (mOnPreparedListener != null) &#123; mOnPreparedListener.onPrepared(mMediaPlayer); &#125; if (mMediaController != null) &#123; mMediaController.setEnabled(true); &#125; mVideoWidth = mp.getVideoWidth(); mVideoHeight = mp.getVideoHeight(); int seekToPosition = mSeekWhenPrepared; // mSeekWhenPrepared may be changed after seekTo() call if (seekToPosition != 0) &#123; seekTo(seekToPosition); &#125; if (mVideoWidth != 0 &amp;&amp; mVideoHeight != 0) &#123; //Log.i(\"@@@@\", \"video size: \" + mVideoWidth +\"/\"+ mVideoHeight); getHolder().setFixedSize(mVideoWidth, mVideoHeight); if (mSurfaceWidth == mVideoWidth &amp;&amp; mSurfaceHeight == mVideoHeight) &#123; // We didn't actually change the size (it was already at the size // we need), so we won't get a \"surface changed\" callback, so // start the video here instead of in the callback. if (mTargetState == STATE_PLAYING) &#123; start(); if (mMediaController != null) &#123; mMediaController.show(); &#125; &#125; else if (!isPlaying() &amp;&amp; (seekToPosition != 0 || getCurrentPosition() &gt; 0)) &#123; if (mMediaController != null) &#123; // Show the media controls when we're paused into a video and make 'em stick. mMediaController.show(0); &#125; &#125; &#125; &#125; else &#123; // We don't know the video size yet, but should start anyway. // The video size might be reported to us later. if (mTargetState == STATE_PLAYING) &#123; start(); &#125; &#125; &#125;&#125;; - OnCompletionListener 12345678910111213private MediaPlayer.OnCompletionListener mCompletionListener = new MediaPlayer.OnCompletionListener() &#123; public void onCompletion(MediaPlayer mp) &#123; mCurrentState = STATE_PLAYBACK_COMPLETED; mTargetState = STATE_PLAYBACK_COMPLETED; if (mMediaController != null) &#123; mMediaController.hide(); &#125; if (mOnCompletionListener != null) &#123; mOnCompletionListener.onCompletion(mMediaPlayer); &#125; &#125;&#125;; - Touch以及Key的监听 12345678@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; if (isInPlaybackState() &amp;&amp; mMediaController != null) &#123; // 控制MediaController的显示与隐藏 toggleMediaControlsVisiblity(); &#125; return false;&#125; - toggleMediaControlsVisiblity 1234567private void toggleMediaControlsVisiblity() &#123; if (mMediaController.isShowing()) &#123; mMediaController.hide(); &#125; else &#123; mMediaController.show(); &#125;&#125; - Key 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event)&#123; boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_UP &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &amp;&amp; keyCode != KeyEvent.KEYCODE_MENU &amp;&amp; keyCode != KeyEvent.KEYCODE_CALL &amp;&amp; keyCode != KeyEvent.KEYCODE_ENDCALL; if (isInPlaybackState() &amp;&amp; isKeyCodeSupported &amp;&amp; mMediaController != null) &#123; if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) &#123; if (mMediaPlayer.isPlaying()) &#123; pause(); mMediaController.show(); &#125; else &#123; start(); mMediaController.hide(); &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) &#123; if (!mMediaPlayer.isPlaying()) &#123; start(); mMediaController.hide(); &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) &#123; if (mMediaPlayer.isPlaying()) &#123; pause(); mMediaController.show(); &#125; return true; &#125; else &#123; toggleMediaControlsVisiblity(); &#125; &#125; return super.onKeyDown(keyCode, event);&#125; 华丽丽的分割线 上源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862/* * Copyright (C) 2006 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//** * Displays a video file. The VideoView class * can load images from various sources (such as resources or content * providers), takes care of computing its measurement from the video so that * it can be used in any layout manager, and provides various display options * such as scaling and tinting.&lt;p&gt; * * &lt;em&gt;Note: VideoView does not retain its full state when going into the * background.&lt;/em&gt; In particular, it does not restore the current play state, * play position, selected tracks, or any subtitle tracks added via * &#123;@link #addSubtitleSource addSubtitleSource()&#125;. Applications should * save and restore these on their own in * &#123;@link android.app.Activity#onSaveInstanceState&#125; and * &#123;@link android.app.Activity#onRestoreInstanceState&#125;.&lt;p&gt; * Also note that the audio session id (from &#123;@link #getAudioSessionId&#125;) may * change from its previously returned value when the VideoView is restored. */public class VideoView extends SurfaceView implements MediaPlayerControl, SubtitleController.Anchor &#123; private String TAG = \"VideoView\"; // settable by the client private Uri mUri; private Map&lt;String, String&gt; mHeaders; // all possible internal states private static final int STATE_ERROR = -1; private static final int STATE_IDLE = 0; private static final int STATE_PREPARING = 1; private static final int STATE_PREPARED = 2; private static final int STATE_PLAYING = 3; private static final int STATE_PAUSED = 4; private static final int STATE_PLAYBACK_COMPLETED = 5; // mCurrentState is a VideoView object's current state. // mTargetState is the state that a method caller intends to reach. // For instance, regardless the VideoView object's current state, // calling pause() intends to bring the object to a target state // of STATE_PAUSED. private int mCurrentState = STATE_IDLE; private int mTargetState = STATE_IDLE; // All the stuff we need for playing and showing a video private SurfaceHolder mSurfaceHolder = null; private MediaPlayer mMediaPlayer = null; private int mAudioSession; private int mVideoWidth; private int mVideoHeight; private int mSurfaceWidth; private int mSurfaceHeight; private MediaController mMediaController; private OnCompletionListener mOnCompletionListener; private MediaPlayer.OnPreparedListener mOnPreparedListener; private int mCurrentBufferPercentage; private OnErrorListener mOnErrorListener; private OnInfoListener mOnInfoListener; private int mSeekWhenPrepared; // recording the seek position while preparing private boolean mCanPause; private boolean mCanSeekBack; private boolean mCanSeekForward; /** Subtitle rendering widget overlaid on top of the video. */ private RenderingWidget mSubtitleWidget; /** Listener for changes to subtitle data, used to redraw when needed. */ private RenderingWidget.OnChangedListener mSubtitlesChangedListener; public VideoView(Context context) &#123; super(context); initVideoView(); &#125; public VideoView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); initVideoView(); &#125; public VideoView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); initVideoView(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \" // + MeasureSpec.toString(heightMeasureSpec) + \")\"); int width = getDefaultSize(mVideoWidth, widthMeasureSpec); int height = getDefaultSize(mVideoHeight, heightMeasureSpec); if (mVideoWidth &gt; 0 &amp;&amp; mVideoHeight &gt; 0) &#123; int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.EXACTLY &amp;&amp; heightSpecMode == MeasureSpec.EXACTLY) &#123; // the size is fixed width = widthSpecSize; height = heightSpecSize; // for compatibility, we adjust size based on aspect ratio if ( mVideoWidth * height &lt; width * mVideoHeight ) &#123; //Log.i(\"@@@\", \"image too wide, correcting\"); width = height * mVideoWidth / mVideoHeight; &#125; else if ( mVideoWidth * height &gt; width * mVideoHeight ) &#123; //Log.i(\"@@@\", \"image too tall, correcting\"); height = width * mVideoHeight / mVideoWidth; &#125; &#125; else if (widthSpecMode == MeasureSpec.EXACTLY) &#123; // only the width is fixed, adjust the height to match aspect ratio if possible width = widthSpecSize; height = width * mVideoHeight / mVideoWidth; if (heightSpecMode == MeasureSpec.AT_MOST &amp;&amp; height &gt; heightSpecSize) &#123; // couldn't match aspect ratio within the constraints height = heightSpecSize; &#125; &#125; else if (heightSpecMode == MeasureSpec.EXACTLY) &#123; // only the height is fixed, adjust the width to match aspect ratio if possible height = heightSpecSize; width = height * mVideoWidth / mVideoHeight; if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; width &gt; widthSpecSize) &#123; // couldn't match aspect ratio within the constraints width = widthSpecSize; &#125; &#125; else &#123; // neither the width nor the height are fixed, try to use actual video size width = mVideoWidth; height = mVideoHeight; if (heightSpecMode == MeasureSpec.AT_MOST &amp;&amp; height &gt; heightSpecSize) &#123; // too tall, decrease both width and height height = heightSpecSize; width = height * mVideoWidth / mVideoHeight; &#125; if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; width &gt; widthSpecSize) &#123; // too wide, decrease both width and height width = widthSpecSize; height = width * mVideoHeight / mVideoWidth; &#125; &#125; &#125; else &#123; // no size yet, just adopt the given spec sizes &#125; setMeasuredDimension(width, height); &#125; @Override public void onInitializeAccessibilityEvent(AccessibilityEvent event) &#123; super.onInitializeAccessibilityEvent(event); event.setClassName(VideoView.class.getName()); &#125; @Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) &#123; super.onInitializeAccessibilityNodeInfo(info); info.setClassName(VideoView.class.getName()); &#125; public int resolveAdjustedSize(int desiredSize, int measureSpec) &#123; return getDefaultSize(desiredSize, measureSpec); &#125; private void initVideoView() &#123; mVideoWidth = 0; mVideoHeight = 0; getHolder().addCallback(mSHCallback); getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); setFocusable(true); setFocusableInTouchMode(true); requestFocus(); mPendingSubtitleTracks = new Vector&lt;Pair&lt;InputStream, MediaFormat&gt;&gt;(); mCurrentState = STATE_IDLE; mTargetState = STATE_IDLE; &#125; public void setVideoPath(String path) &#123; setVideoURI(Uri.parse(path)); &#125; public void setVideoURI(Uri uri) &#123; setVideoURI(uri, null); &#125; /** * @hide */ public void setVideoURI(Uri uri, Map&lt;String, String&gt; headers) &#123; mUri = uri; mHeaders = headers; mSeekWhenPrepared = 0; openVideo(); requestLayout(); invalidate(); &#125; /** * Adds an external subtitle source file (from the provided input stream.) * * Note that a single external subtitle source may contain multiple or no * supported tracks in it. If the source contained at least one track in * it, one will receive an &#123;@link MediaPlayer#MEDIA_INFO_METADATA_UPDATE&#125; * info message. Otherwise, if reading the source takes excessive time, * one will receive a &#123;@link MediaPlayer#MEDIA_INFO_SUBTITLE_TIMED_OUT&#125; * message. If the source contained no supported track (including an empty * source file or null input stream), one will receive a &#123;@link * MediaPlayer#MEDIA_INFO_UNSUPPORTED_SUBTITLE&#125; message. One can find the * total number of available tracks using &#123;@link MediaPlayer#getTrackInfo()&#125; * to see what additional tracks become available after this method call. * * @param is input stream containing the subtitle data. It will be * closed by the media framework. * @param format the format of the subtitle track(s). Must contain at least * the mime type (&#123;@link MediaFormat#KEY_MIME&#125;) and the * language (&#123;@link MediaFormat#KEY_LANGUAGE&#125;) of the file. * If the file itself contains the language information, * specify \"und\" for the language. */ public void addSubtitleSource(InputStream is, MediaFormat format) &#123; if (mMediaPlayer == null) &#123; mPendingSubtitleTracks.add(Pair.create(is, format)); &#125; else &#123; try &#123; mMediaPlayer.addSubtitleSource(is, format); &#125; catch (IllegalStateException e) &#123; mInfoListener.onInfo( mMediaPlayer, MediaPlayer.MEDIA_INFO_UNSUPPORTED_SUBTITLE, 0); &#125; &#125; &#125; private Vector&lt;Pair&lt;InputStream, MediaFormat&gt;&gt; mPendingSubtitleTracks; public void stopPlayback() &#123; if (mMediaPlayer != null) &#123; mMediaPlayer.stop(); mMediaPlayer.release(); mMediaPlayer = null; mCurrentState = STATE_IDLE; mTargetState = STATE_IDLE; &#125; &#125; private void openVideo() &#123; if (mUri == null || mSurfaceHolder == null) &#123; // not ready for playback just yet, will try again later return; &#125; // Tell the music playback service to pause // TODO: these constants need to be published somewhere in the framework. Intent i = new Intent(\"com.android.music.musicservicecommand\"); i.putExtra(\"command\", \"pause\"); mContext.sendBroadcast(i); // we shouldn't clear the target state, because somebody might have // called start() previously release(false); try &#123; mMediaPlayer = new MediaPlayer(); // TODO: create SubtitleController in MediaPlayer, but we need // a context for the subtitle renderers final Context context = getContext(); final SubtitleController controller = new SubtitleController( context, mMediaPlayer.getMediaTimeProvider(), mMediaPlayer); controller.registerRenderer(new WebVttRenderer(context)); mMediaPlayer.setSubtitleAnchor(controller, this); if (mAudioSession != 0) &#123; mMediaPlayer.setAudioSessionId(mAudioSession); &#125; else &#123; mAudioSession = mMediaPlayer.getAudioSessionId(); &#125; mMediaPlayer.setOnPreparedListener(mPreparedListener); mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener); mMediaPlayer.setOnCompletionListener(mCompletionListener); mMediaPlayer.setOnErrorListener(mErrorListener); mMediaPlayer.setOnInfoListener(mInfoListener); mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener); mCurrentBufferPercentage = 0; mMediaPlayer.setDataSource(mContext, mUri, mHeaders); mMediaPlayer.setDisplay(mSurfaceHolder); mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC); mMediaPlayer.setScreenOnWhilePlaying(true); mMediaPlayer.prepareAsync(); for (Pair&lt;InputStream, MediaFormat&gt; pending: mPendingSubtitleTracks) &#123; try &#123; mMediaPlayer.addSubtitleSource(pending.first, pending.second); &#125; catch (IllegalStateException e) &#123; mInfoListener.onInfo( mMediaPlayer, MediaPlayer.MEDIA_INFO_UNSUPPORTED_SUBTITLE, 0); &#125; &#125; // we don't set the target state here either, but preserve the // target state that was there before. mCurrentState = STATE_PREPARING; attachMediaController(); &#125; catch (IOException ex) &#123; Log.w(TAG, \"Unable to open content: \" + mUri, ex); mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0); return; &#125; catch (IllegalArgumentException ex) &#123; Log.w(TAG, \"Unable to open content: \" + mUri, ex); mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0); return; &#125; finally &#123; mPendingSubtitleTracks.clear(); &#125; &#125; public void setMediaController(MediaController controller) &#123; if (mMediaController != null) &#123; mMediaController.hide(); &#125; mMediaController = controller; attachMediaController(); &#125; private void attachMediaController() &#123; if (mMediaPlayer != null &amp;&amp; mMediaController != null) &#123; mMediaController.setMediaPlayer(this); View anchorView = this.getParent() instanceof View ? (View)this.getParent() : this; mMediaController.setAnchorView(anchorView); mMediaController.setEnabled(isInPlaybackState()); &#125; &#125; MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener = new MediaPlayer.OnVideoSizeChangedListener() &#123; public void onVideoSizeChanged(MediaPlayer mp, int width, int height) &#123; mVideoWidth = mp.getVideoWidth(); mVideoHeight = mp.getVideoHeight(); if (mVideoWidth != 0 &amp;&amp; mVideoHeight != 0) &#123; getHolder().setFixedSize(mVideoWidth, mVideoHeight); requestLayout(); &#125; &#125; &#125;; MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() &#123; public void onPrepared(MediaPlayer mp) &#123; mCurrentState = STATE_PREPARED; // Get the capabilities of the player for this stream Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL, MediaPlayer.BYPASS_METADATA_FILTER); if (data != null) &#123; mCanPause = !data.has(Metadata.PAUSE_AVAILABLE) || data.getBoolean(Metadata.PAUSE_AVAILABLE); mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE) || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE); mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE) || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE); &#125; else &#123; mCanPause = mCanSeekBack = mCanSeekForward = true; &#125; if (mOnPreparedListener != null) &#123; mOnPreparedListener.onPrepared(mMediaPlayer); &#125; if (mMediaController != null) &#123; mMediaController.setEnabled(true); &#125; mVideoWidth = mp.getVideoWidth(); mVideoHeight = mp.getVideoHeight(); int seekToPosition = mSeekWhenPrepared; // mSeekWhenPrepared may be changed after seekTo() call if (seekToPosition != 0) &#123; seekTo(seekToPosition); &#125; if (mVideoWidth != 0 &amp;&amp; mVideoHeight != 0) &#123; //Log.i(\"@@@@\", \"video size: \" + mVideoWidth +\"/\"+ mVideoHeight); getHolder().setFixedSize(mVideoWidth, mVideoHeight); if (mSurfaceWidth == mVideoWidth &amp;&amp; mSurfaceHeight == mVideoHeight) &#123; // We didn't actually change the size (it was already at the size // we need), so we won't get a \"surface changed\" callback, so // start the video here instead of in the callback. if (mTargetState == STATE_PLAYING) &#123; start(); if (mMediaController != null) &#123; mMediaController.show(); &#125; &#125; else if (!isPlaying() &amp;&amp; (seekToPosition != 0 || getCurrentPosition() &gt; 0)) &#123; if (mMediaController != null) &#123; // Show the media controls when we're paused into a video and make 'em stick. mMediaController.show(0); &#125; &#125; &#125; &#125; else &#123; // We don't know the video size yet, but should start anyway. // The video size might be reported to us later. if (mTargetState == STATE_PLAYING) &#123; start(); &#125; &#125; &#125; &#125;; private MediaPlayer.OnCompletionListener mCompletionListener = new MediaPlayer.OnCompletionListener() &#123; public void onCompletion(MediaPlayer mp) &#123; mCurrentState = STATE_PLAYBACK_COMPLETED; mTargetState = STATE_PLAYBACK_COMPLETED; if (mMediaController != null) &#123; mMediaController.hide(); &#125; if (mOnCompletionListener != null) &#123; mOnCompletionListener.onCompletion(mMediaPlayer); &#125; &#125; &#125;; private MediaPlayer.OnInfoListener mInfoListener = new MediaPlayer.OnInfoListener() &#123; public boolean onInfo(MediaPlayer mp, int arg1, int arg2) &#123; if (mOnInfoListener != null) &#123; mOnInfoListener.onInfo(mp, arg1, arg2); &#125; return true; &#125; &#125;; private MediaPlayer.OnErrorListener mErrorListener = new MediaPlayer.OnErrorListener() &#123; public boolean onError(MediaPlayer mp, int framework_err, int impl_err) &#123; Log.d(TAG, \"Error: \" + framework_err + \",\" + impl_err); mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; if (mMediaController != null) &#123; mMediaController.hide(); &#125; /* If an error handler has been supplied, use it and finish. */ if (mOnErrorListener != null) &#123; if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) &#123; return true; &#125; &#125; /* Otherwise, pop up an error dialog so the user knows that * something bad has happened. Only try and pop up the dialog * if we're attached to a window. When we're going away and no * longer have a window, don't bother showing the user an error. */ if (getWindowToken() != null) &#123; Resources r = mContext.getResources(); int messageId; if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) &#123; messageId = com.android.internal.R.string.VideoView_error_text_invalid_progressive_playback; &#125; else &#123; messageId = com.android.internal.R.string.VideoView_error_text_unknown; &#125; new AlertDialog.Builder(mContext) .setMessage(messageId) .setPositiveButton(com.android.internal.R.string.VideoView_error_button, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; /* If we get here, there is no onError listener, so * at least inform them that the video is over. */ if (mOnCompletionListener != null) &#123; mOnCompletionListener.onCompletion(mMediaPlayer); &#125; &#125; &#125;) .setCancelable(false) .show(); &#125; return true; &#125; &#125;; private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener = new MediaPlayer.OnBufferingUpdateListener() &#123; public void onBufferingUpdate(MediaPlayer mp, int percent) &#123; mCurrentBufferPercentage = percent; &#125; &#125;; /** * Register a callback to be invoked when the media file * is loaded and ready to go. * * @param l The callback that will be run */ public void setOnPreparedListener(MediaPlayer.OnPreparedListener l) &#123; mOnPreparedListener = l; &#125; /** * Register a callback to be invoked when the end of a media file * has been reached during playback. * * @param l The callback that will be run */ public void setOnCompletionListener(OnCompletionListener l) &#123; mOnCompletionListener = l; &#125; /** * Register a callback to be invoked when an error occurs * during playback or setup. If no listener is specified, * or if the listener returned false, VideoView will inform * the user of any errors. * * @param l The callback that will be run */ public void setOnErrorListener(OnErrorListener l) &#123; mOnErrorListener = l; &#125; /** * Register a callback to be invoked when an informational event * occurs during playback or setup. * * @param l The callback that will be run */ public void setOnInfoListener(OnInfoListener l) &#123; mOnInfoListener = l; &#125; SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback() &#123; public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) &#123; mSurfaceWidth = w; mSurfaceHeight = h; boolean isValidState = (mTargetState == STATE_PLAYING); boolean hasValidSize = (mVideoWidth == w &amp;&amp; mVideoHeight == h); if (mMediaPlayer != null &amp;&amp; isValidState &amp;&amp; hasValidSize) &#123; if (mSeekWhenPrepared != 0) &#123; seekTo(mSeekWhenPrepared); &#125; start(); &#125; &#125; public void surfaceCreated(SurfaceHolder holder) &#123; mSurfaceHolder = holder; openVideo(); &#125; public void surfaceDestroyed(SurfaceHolder holder) &#123; // after we return from this we can't use the surface any more mSurfaceHolder = null; if (mMediaController != null) mMediaController.hide(); release(true); &#125; &#125;; /* * release the media player in any state */ private void release(boolean cleartargetstate) &#123; if (mMediaPlayer != null) &#123; mMediaPlayer.reset(); mMediaPlayer.release(); mMediaPlayer = null; mPendingSubtitleTracks.clear(); mCurrentState = STATE_IDLE; if (cleartargetstate) &#123; mTargetState = STATE_IDLE; &#125; &#125; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (isInPlaybackState() &amp;&amp; mMediaController != null) &#123; toggleMediaControlsVisiblity(); &#125; return false; &#125; @Override public boolean onTrackballEvent(MotionEvent ev) &#123; if (isInPlaybackState() &amp;&amp; mMediaController != null) &#123; toggleMediaControlsVisiblity(); &#125; return false; &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_UP &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &amp;&amp; keyCode != KeyEvent.KEYCODE_MENU &amp;&amp; keyCode != KeyEvent.KEYCODE_CALL &amp;&amp; keyCode != KeyEvent.KEYCODE_ENDCALL; if (isInPlaybackState() &amp;&amp; isKeyCodeSupported &amp;&amp; mMediaController != null) &#123; if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) &#123; if (mMediaPlayer.isPlaying()) &#123; pause(); mMediaController.show(); &#125; else &#123; start(); mMediaController.hide(); &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) &#123; if (!mMediaPlayer.isPlaying()) &#123; start(); mMediaController.hide(); &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) &#123; if (mMediaPlayer.isPlaying()) &#123; pause(); mMediaController.show(); &#125; return true; &#125; else &#123; toggleMediaControlsVisiblity(); &#125; &#125; return super.onKeyDown(keyCode, event); &#125; private void toggleMediaControlsVisiblity() &#123; if (mMediaController.isShowing()) &#123; mMediaController.hide(); &#125; else &#123; mMediaController.show(); &#125; &#125; @Override public void start() &#123; if (isInPlaybackState()) &#123; mMediaPlayer.start(); mCurrentState = STATE_PLAYING; &#125; mTargetState = STATE_PLAYING; &#125; @Override public void pause() &#123; if (isInPlaybackState()) &#123; if (mMediaPlayer.isPlaying()) &#123; mMediaPlayer.pause(); mCurrentState = STATE_PAUSED; &#125; &#125; mTargetState = STATE_PAUSED; &#125; public void suspend() &#123; release(false); &#125; public void resume() &#123; openVideo(); &#125; @Override public int getDuration() &#123; if (isInPlaybackState()) &#123; return mMediaPlayer.getDuration(); &#125; return -1; &#125; @Override public int getCurrentPosition() &#123; if (isInPlaybackState()) &#123; return mMediaPlayer.getCurrentPosition(); &#125; return 0; &#125; @Override public void seekTo(int msec) &#123; if (isInPlaybackState()) &#123; mMediaPlayer.seekTo(msec); mSeekWhenPrepared = 0; &#125; else &#123; mSeekWhenPrepared = msec; &#125; &#125; @Override public boolean isPlaying() &#123; return isInPlaybackState() &amp;&amp; mMediaPlayer.isPlaying(); &#125; @Override public int getBufferPercentage() &#123; if (mMediaPlayer != null) &#123; return mCurrentBufferPercentage; &#125; return 0; &#125; private boolean isInPlaybackState() &#123; return (mMediaPlayer != null &amp;&amp; mCurrentState != STATE_ERROR &amp;&amp; mCurrentState != STATE_IDLE &amp;&amp; mCurrentState != STATE_PREPARING); &#125; @Override public boolean canPause() &#123; return mCanPause; &#125; @Override public boolean canSeekBackward() &#123; return mCanSeekBack; &#125; @Override public boolean canSeekForward() &#123; return mCanSeekForward; &#125; @Override public int getAudioSessionId() &#123; if (mAudioSession == 0) &#123; MediaPlayer foo = new MediaPlayer(); mAudioSession = foo.getAudioSessionId(); foo.release(); &#125; return mAudioSession; &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); if (mSubtitleWidget != null) &#123; mSubtitleWidget.onAttachedToWindow(); &#125; &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); if (mSubtitleWidget != null) &#123; mSubtitleWidget.onDetachedFromWindow(); &#125; &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); if (mSubtitleWidget != null) &#123; measureAndLayoutSubtitleWidget(); &#125; &#125; @Override public void draw(Canvas canvas) &#123; super.draw(canvas); if (mSubtitleWidget != null) &#123; final int saveCount = canvas.save(); canvas.translate(getPaddingLeft(), getPaddingTop()); mSubtitleWidget.draw(canvas); canvas.restoreToCount(saveCount); &#125; &#125; /** * Forces a measurement and layout pass for all overlaid views. * * @see #setSubtitleWidget(RenderingWidget) */ private void measureAndLayoutSubtitleWidget() &#123; final int width = getWidth() - getPaddingLeft() - getPaddingRight(); final int height = getHeight() - getPaddingTop() - getPaddingBottom(); mSubtitleWidget.setSize(width, height); &#125; /** @hide */ @Override public void setSubtitleWidget(RenderingWidget subtitleWidget) &#123; if (mSubtitleWidget == subtitleWidget) &#123; return; &#125; final boolean attachedToWindow = isAttachedToWindow(); if (mSubtitleWidget != null) &#123; if (attachedToWindow) &#123; mSubtitleWidget.onDetachedFromWindow(); &#125; mSubtitleWidget.setOnChangedListener(null); &#125; mSubtitleWidget = subtitleWidget; if (subtitleWidget != null) &#123; if (mSubtitlesChangedListener == null) &#123; mSubtitlesChangedListener = new RenderingWidget.OnChangedListener() &#123; @Override public void onChanged(RenderingWidget renderingWidget) &#123; invalidate(); &#125; &#125;; &#125; setWillNotDraw(false); subtitleWidget.setOnChangedListener(mSubtitlesChangedListener); if (attachedToWindow) &#123; subtitleWidget.onAttachedToWindow(); requestLayout(); &#125; &#125; else &#123; setWillNotDraw(true); &#125; invalidate(); &#125; /** @hide */ @Override public Looper getSubtitleLooper() &#123; return Looper.getMainLooper(); &#125;&#125; MediaPlayerControl 通过该接口来打通MediaController以及VideoView 12345678910111213141516171819 public interface MediaPlayerControl &#123; void start(); void pause(); int getDuration(); int getCurrentPosition(); void seekTo(int pos); boolean isPlaying(); int getBufferPercentage(); boolean canPause(); boolean canSeekBackward(); boolean canSeekForward(); /** * Get the audio session id for the player used by this VideoView. This can be used to * apply audio effects to the audio track of a video. * @return The audio session, or 0 if there was an error. */ int getAudioSessionId();&#125; MediaController 简介 12345678910111213141516171819202122232425262728/*** A view containing controls for a MediaPlayer. Typically contains the* buttons like \"Play/Pause\", \"Rewind\", \"Fast Forward\" and a progress* slider. It takes care of synchronizing the controls with the state* of the MediaPlayer.* &lt;p&gt;* The way to use this class is to instantiate it programatically.* The MediaController will create a default set of controls* and put them in a window floating above your application. Specifically,* the controls will float above the view specified with setAnchorView().* The window will disappear if left idle for three seconds and reappear* when the user touches the anchor view.* &lt;p&gt;* Functions like show() and hide() have no effect when MediaController* is created in an xml layout.* * MediaController will hide and* show the buttons according to these rules:* &lt;ul&gt;* &lt;li&gt; The \"previous\" and \"next\" buttons are hidden until setPrevNextListeners()* has been called* &lt;li&gt; The \"previous\" and \"next\" buttons are visible but disabled if* setPrevNextListeners() was called with null listeners* &lt;li&gt; The \"rewind\" and \"fastforward\" buttons are shown unless requested* otherwise by using the MediaController(Context, boolean) constructor* with the boolean set to false* &lt;/ul&gt;*/ 关系 1public class MediaController extends FrameLayout 成员 123456789101112131415161718192021222324252627282930313233// 一些控制功能的接口private MediaPlayerControl mPlayer; private Context mContext;// VideoView中调用setAnchorView()设置进来的View，MediaController显示的时候会感觉该AnchorView的位置进行显示 private View mAnchor;// MediaController最外层的根布局 private View mRoot;// 通过Window的方式来显示MediaController，MediaController是一个填充屏幕的布局，但是背景是透明的 private WindowManager mWindowManager; private Window mWindow; private View mDecor;// 理解为当前整个MediaController的布局 private WindowManager.LayoutParams mDecorLayoutParams; private ProgressBar mProgress; private TextView mEndTime, mCurrentTime; private boolean mShowing; private boolean mDragging;// 默认自动消失的时间 private static final int sDefaultTimeout = 3000; private static final int FADE_OUT = 1; private static final int SHOW_PROGRESS = 2; private boolean mUseFastForward; private boolean mFromXml; private boolean mListenersSet; private View.OnClickListener mNextListener, mPrevListener; StringBuilder mFormatBuilder; Formatter mFormatter; private ImageButton mPauseButton; private ImageButton mFfwdButton; private ImageButton mRewButton; private ImageButton mNextButton; private ImageButton mPrevButton; 构造方法 1234567891011121314151617181920212223242526public MediaController(Context context, AttributeSet attrs) &#123; super(context, attrs); mRoot = this; mContext = context; mUseFastForward = true; mFromXml = true; &#125; @Override public void onFinishInflate() &#123; if (mRoot != null) initControllerView(mRoot); &#125; public MediaController(Context context, boolean useFastForward) &#123; super(context); mContext = context; mUseFastForward = useFastForward; // 创建该MediaController的布局 initFloatingWindowLayout(); initFloatingWindow(); &#125; public MediaController(Context context) &#123; this(context, true); &#125; - initFloatingWindowLayout 1234567891011121314151617// Allocate and initialize the static parts of mDecorLayoutParams. Must// also call updateFloatingWindowLayout() to fill in the dynamic parts// (y and width) before mDecorLayoutParams can be used.private void initFloatingWindowLayout() &#123; mDecorLayoutParams = new WindowManager.LayoutParams(); WindowManager.LayoutParams p = mDecorLayoutParams; p.gravity = Gravity.TOP | Gravity.LEFT; p.height = LayoutParams.WRAP_CONTENT; p.x = 0; p.format = PixelFormat.TRANSLUCENT; p.type = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL; p.flags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH; p.token = null; p.windowAnimations = 0; // android.R.style.DropDownAnimationDown;&#125; - initFloatingWindow 123456789101112131415161718192021private void initFloatingWindow() &#123; // Android内核剖析 中有介绍 mWindowManager = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); mWindow = PolicyManager.makeNewWindow(mContext); mWindow.setWindowManager(mWindowManager, null, null); mWindow.requestFeature(Window.FEATURE_NO_TITLE); // 通过WindowManager去add该Decor以及remove来实现MediaController的显示与隐藏 mDecor = mWindow.getDecorView(); mDecor.setOnTouchListener(mTouchListener); mWindow.setContentView(this); mWindow.setBackgroundDrawableResource(android.R.color.transparent); // While the media controller is up, the volume control keys should // affect the media stream type mWindow.setVolumeControlStream(AudioManager.STREAM_MUSIC); setFocusable(true); setFocusableInTouchMode(true); setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); requestFocus();&#125; - mTouchListener 12345678910private OnTouchListener mTouchListener = new OnTouchListener() &#123; public boolean onTouch(View v, MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; if (mShowing) &#123; hide(); &#125; &#125; return false; &#125;&#125;; - setMediaPlayer VideoView调用setMediaController的时候会调用到该方法 1234public void setMediaPlayer(MediaPlayerControl player) &#123; mPlayer = player; updatePausePlay();&#125; - setAnchorView VideoView调用setMediaController的时候会调用到该方法 12345678910111213141516171819202122232425/** * Set the view that acts as the anchor for the control view. * This can for example be a VideoView, or your Activity's main view. * When VideoView calls this method, it will use the VideoView's parent * as the anchor. * @param view The view to which to anchor the controller when it is visible. */public void setAnchorView(View view) &#123; if (mAnchor != null) &#123; mAnchor.removeOnLayoutChangeListener(mLayoutChangeListener); &#125; mAnchor = view; if (mAnchor != null) &#123; mAnchor.addOnLayoutChangeListener(mLayoutChangeListener); &#125; FrameLayout.LayoutParams frameParams = new FrameLayout.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ); removeAllViews(); View v = makeControllerView(); addView(v, frameParams);&#125; - mLayoutChangeListener 12345678910111213// This is called whenever mAnchor's layout bound changesprivate OnLayoutChangeListener mLayoutChangeListener = new OnLayoutChangeListener() &#123; public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) &#123; // 更新布局 updateFloatingWindowLayout(); if (mShowing) &#123; mWindowManager.updateViewLayout(mDecor, mDecorLayoutParams); &#125; &#125;&#125;; - updateFloatingWindowLayout 12345678910111213141516// Update the dynamic parts of mDecorLayoutParams// Must be called with mAnchor != NULL.private void updateFloatingWindowLayout() &#123; int [] anchorPos = new int[2]; mAnchor.getLocationOnScreen(anchorPos); // we need to know the size of the controller so we can properly position it // within its space mDecor.measure(MeasureSpec.makeMeasureSpec(mAnchor.getWidth(), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(mAnchor.getHeight(), MeasureSpec.AT_MOST)); WindowManager.LayoutParams p = mDecorLayoutParams; p.width = mAnchor.getWidth(); p.x = anchorPos[0] + (mAnchor.getWidth() - p.width) / 2; p.y = anchorPos[1] + mAnchor.getHeight() - mDecor.getMeasuredHeight();&#125; - makeControllerView 1234567891011121314/** * Create the view that holds the widgets that control playback. * Derived classes can override this to create their own. * @return The controller view. * @hide This doesn't work as advertised */protected View makeControllerView() &#123; LayoutInflater inflate = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE); mRoot = inflate.inflate(com.android.internal.R.layout.media_controller, null); // 对Controller中的一些按钮、功能进行事件设置 initControllerView(mRoot); return mRoot;&#125; - touch事件处理 12345@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; show(sDefaultTimeout); return true;&#125; - 进度的处理 - seekBar的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// There are two scenarios that can trigger the seekbar listener to trigger://// The first is the user using the touchpad to adjust the posititon of the// seekbar's thumb. In this case onStartTrackingTouch is called followed by// a number of onProgressChanged notifications, concluded by onStopTrackingTouch.// We're setting the field \"mDragging\" to true for the duration of the dragging// session to avoid jumps in the position in case of ongoing playback.//// The second scenario involves the user operating the scroll ball, in this// case there WON'T BE onStartTrackingTouch/onStopTrackingTouch notifications,// we will simply apply the updated position without suspending regular updates.private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() &#123; public void onStartTrackingTouch(SeekBar bar) &#123; show(3600000); mDragging = true; // By removing these pending progress messages we make sure // that a) we won't update the progress while the user adjusts // the seekbar and b) once the user is done dragging the thumb // we will post one of these messages to the queue again and // this ensures that there will be exactly one message queued up. mHandler.removeMessages(SHOW_PROGRESS); &#125; public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) &#123; if (!fromuser) &#123; // We're not interested in programmatically generated changes to // the progress bar's position. return; &#125; long duration = mPlayer.getDuration(); long newposition = (duration * progress) / 1000L; mPlayer.seekTo( (int) newposition); if (mCurrentTime != null) mCurrentTime.setText(stringForTime( (int) newposition)); &#125; public void onStopTrackingTouch(SeekBar bar) &#123; mDragging = false; setProgress(); updatePausePlay(); show(sDefaultTimeout); // Ensure that progress is properly updated in the future, // the call to show() does not guarantee this because it is a // no-op if we are already showing. mHandler.sendEmptyMessage(SHOW_PROGRESS); &#125;&#125;; - SetProgress 1234567891011121314151617181920212223private int setProgress() &#123; if (mPlayer == null || mDragging) &#123; return 0; &#125; int position = mPlayer.getCurrentPosition(); int duration = mPlayer.getDuration(); if (mProgress != null) &#123; if (duration &gt; 0) &#123; // use long to avoid overflow long pos = 1000L * position / duration; mProgress.setProgress( (int) pos); &#125; int percent = mPlayer.getBufferPercentage(); mProgress.setSecondaryProgress(percent * 10); &#125; if (mEndTime != null) mEndTime.setText(stringForTime(duration)); if (mCurrentTime != null) mCurrentTime.setText(stringForTime(position)); return position;&#125; - show 1234567891011121314151617181920212223242526272829303132/** * Show the controller on screen. It will go away * automatically after 'timeout' milliseconds of inactivity. * @param timeout The timeout in milliseconds. Use 0 to show * the controller until hide() is called. */ public void show(int timeout) &#123; if (!mShowing &amp;&amp; mAnchor != null) &#123; // 先去设置一下进度 setProgress(); if (mPauseButton != null) &#123; mPauseButton.requestFocus(); &#125; disableUnsupportedButtons(); updateFloatingWindowLayout(); mWindowManager.addView(mDecor, mDecorLayoutParams); mShowing = true; &#125; updatePausePlay(); // cause the progress bar to be updated even if mShowing // was already true. This happens, for example, if we're // paused with the progress bar showing the user hits play. // 发送定期更新进度的消息 mHandler.sendEmptyMessage(SHOW_PROGRESS); Message msg = mHandler.obtainMessage(FADE_OUT); if (timeout != 0) &#123; mHandler.removeMessages(FADE_OUT); mHandler.sendMessageDelayed(msg, timeout); &#125; &#125; - hide 123456789101112131415161718/** * Remove the controller from the screen. */public void hide() &#123; if (mAnchor == null) return; if (mShowing) &#123; try &#123; // 移除定期更新消息 mHandler.removeMessages(SHOW_PROGRESS); mWindowManager.removeView(mDecor); &#125; catch (IllegalArgumentException ex) &#123; Log.w(\"MediaController\", \"already removed\"); &#125; mShowing = false; &#125;&#125; 上源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688/* * Copyright (C) 2006 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package android.widget;import android.content.Context;import android.graphics.PixelFormat;import android.media.AudioManager;import android.os.Handler;import android.os.Message;import android.util.AttributeSet;import android.util.Log;import android.view.Gravity;import android.view.KeyEvent;import android.view.LayoutInflater;import android.view.MotionEvent;import android.view.View;import android.view.ViewGroup;import android.view.Window;import android.view.WindowManager;import android.view.accessibility.AccessibilityEvent;import android.view.accessibility.AccessibilityNodeInfo;import android.widget.SeekBar.OnSeekBarChangeListener;import com.android.internal.policy.PolicyManager;import java.util.Formatter;import java.util.Locale;/** * A view containing controls for a MediaPlayer. Typically contains the * buttons like \"Play/Pause\", \"Rewind\", \"Fast Forward\" and a progress * slider. It takes care of synchronizing the controls with the state * of the MediaPlayer. * &lt;p&gt; * The way to use this class is to instantiate it programatically. * The MediaController will create a default set of controls * and put them in a window floating above your application. Specifically, * the controls will float above the view specified with setAnchorView(). * The window will disappear if left idle for three seconds and reappear * when the user touches the anchor view. * &lt;p&gt; * Functions like show() and hide() have no effect when MediaController * is created in an xml layout. * * MediaController will hide and * show the buttons according to these rules: * &lt;ul&gt; * &lt;li&gt; The \"previous\" and \"next\" buttons are hidden until setPrevNextListeners() * has been called * &lt;li&gt; The \"previous\" and \"next\" buttons are visible but disabled if * setPrevNextListeners() was called with null listeners * &lt;li&gt; The \"rewind\" and \"fastforward\" buttons are shown unless requested * otherwise by using the MediaController(Context, boolean) constructor * with the boolean set to false * &lt;/ul&gt; */public class MediaController extends FrameLayout &#123; private MediaPlayerControl mPlayer; private Context mContext; private View mAnchor; private View mRoot; private WindowManager mWindowManager; private Window mWindow; private View mDecor; private WindowManager.LayoutParams mDecorLayoutParams; private ProgressBar mProgress; private TextView mEndTime, mCurrentTime; private boolean mShowing; private boolean mDragging; private static final int sDefaultTimeout = 3000; private static final int FADE_OUT = 1; private static final int SHOW_PROGRESS = 2; private boolean mUseFastForward; private boolean mFromXml; private boolean mListenersSet; private View.OnClickListener mNextListener, mPrevListener; StringBuilder mFormatBuilder; Formatter mFormatter; private ImageButton mPauseButton; private ImageButton mFfwdButton; private ImageButton mRewButton; private ImageButton mNextButton; private ImageButton mPrevButton; public MediaController(Context context, AttributeSet attrs) &#123; super(context, attrs); mRoot = this; mContext = context; mUseFastForward = true; mFromXml = true; &#125; @Override public void onFinishInflate() &#123; if (mRoot != null) initControllerView(mRoot); &#125; public MediaController(Context context, boolean useFastForward) &#123; super(context); mContext = context; mUseFastForward = useFastForward; initFloatingWindowLayout(); initFloatingWindow(); &#125; public MediaController(Context context) &#123; this(context, true); &#125; private void initFloatingWindow() &#123; mWindowManager = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); mWindow = PolicyManager.makeNewWindow(mContext); mWindow.setWindowManager(mWindowManager, null, null); mWindow.requestFeature(Window.FEATURE_NO_TITLE); mDecor = mWindow.getDecorView(); mDecor.setOnTouchListener(mTouchListener); mWindow.setContentView(this); mWindow.setBackgroundDrawableResource(android.R.color.transparent); // While the media controller is up, the volume control keys should // affect the media stream type mWindow.setVolumeControlStream(AudioManager.STREAM_MUSIC); setFocusable(true); setFocusableInTouchMode(true); setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); requestFocus(); &#125; // Allocate and initialize the static parts of mDecorLayoutParams. Must // also call updateFloatingWindowLayout() to fill in the dynamic parts // (y and width) before mDecorLayoutParams can be used. private void initFloatingWindowLayout() &#123; mDecorLayoutParams = new WindowManager.LayoutParams(); WindowManager.LayoutParams p = mDecorLayoutParams; p.gravity = Gravity.TOP | Gravity.LEFT; p.height = LayoutParams.WRAP_CONTENT; p.x = 0; p.format = PixelFormat.TRANSLUCENT; p.type = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL; p.flags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH; p.token = null; p.windowAnimations = 0; // android.R.style.DropDownAnimationDown; &#125; // Update the dynamic parts of mDecorLayoutParams // Must be called with mAnchor != NULL. private void updateFloatingWindowLayout() &#123; int [] anchorPos = new int[2]; mAnchor.getLocationOnScreen(anchorPos); // we need to know the size of the controller so we can properly position it // within its space mDecor.measure(MeasureSpec.makeMeasureSpec(mAnchor.getWidth(), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(mAnchor.getHeight(), MeasureSpec.AT_MOST)); WindowManager.LayoutParams p = mDecorLayoutParams; p.width = mAnchor.getWidth(); p.x = anchorPos[0] + (mAnchor.getWidth() - p.width) / 2; p.y = anchorPos[1] + mAnchor.getHeight() - mDecor.getMeasuredHeight(); &#125; // This is called whenever mAnchor's layout bound changes private OnLayoutChangeListener mLayoutChangeListener = new OnLayoutChangeListener() &#123; public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) &#123; updateFloatingWindowLayout(); if (mShowing) &#123; mWindowManager.updateViewLayout(mDecor, mDecorLayoutParams); &#125; &#125; &#125;; private OnTouchListener mTouchListener = new OnTouchListener() &#123; public boolean onTouch(View v, MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; if (mShowing) &#123; hide(); &#125; &#125; return false; &#125; &#125;; public void setMediaPlayer(MediaPlayerControl player) &#123; mPlayer = player; updatePausePlay(); &#125; /** * Set the view that acts as the anchor for the control view. * This can for example be a VideoView, or your Activity's main view. * When VideoView calls this method, it will use the VideoView's parent * as the anchor. * @param view The view to which to anchor the controller when it is visible. */ public void setAnchorView(View view) &#123; if (mAnchor != null) &#123; mAnchor.removeOnLayoutChangeListener(mLayoutChangeListener); &#125; mAnchor = view; if (mAnchor != null) &#123; mAnchor.addOnLayoutChangeListener(mLayoutChangeListener); &#125; FrameLayout.LayoutParams frameParams = new FrameLayout.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ); removeAllViews(); View v = makeControllerView(); addView(v, frameParams); &#125; /** * Create the view that holds the widgets that control playback. * Derived classes can override this to create their own. * @return The controller view. * @hide This doesn't work as advertised */ protected View makeControllerView() &#123; LayoutInflater inflate = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE); mRoot = inflate.inflate(com.android.internal.R.layout.media_controller, null); initControllerView(mRoot); return mRoot; &#125; private void initControllerView(View v) &#123; mPauseButton = (ImageButton) v.findViewById(com.android.internal.R.id.pause); if (mPauseButton != null) &#123; mPauseButton.requestFocus(); mPauseButton.setOnClickListener(mPauseListener); &#125; mFfwdButton = (ImageButton) v.findViewById(com.android.internal.R.id.ffwd); if (mFfwdButton != null) &#123; mFfwdButton.setOnClickListener(mFfwdListener); if (!mFromXml) &#123; mFfwdButton.setVisibility(mUseFastForward ? View.VISIBLE : View.GONE); &#125; &#125; mRewButton = (ImageButton) v.findViewById(com.android.internal.R.id.rew); if (mRewButton != null) &#123; mRewButton.setOnClickListener(mRewListener); if (!mFromXml) &#123; mRewButton.setVisibility(mUseFastForward ? View.VISIBLE : View.GONE); &#125; &#125; // By default these are hidden. They will be enabled when setPrevNextListeners() is called mNextButton = (ImageButton) v.findViewById(com.android.internal.R.id.next); if (mNextButton != null &amp;&amp; !mFromXml &amp;&amp; !mListenersSet) &#123; mNextButton.setVisibility(View.GONE); &#125; mPrevButton = (ImageButton) v.findViewById(com.android.internal.R.id.prev); if (mPrevButton != null &amp;&amp; !mFromXml &amp;&amp; !mListenersSet) &#123; mPrevButton.setVisibility(View.GONE); &#125; mProgress = (ProgressBar) v.findViewById(com.android.internal.R.id.mediacontroller_progress); if (mProgress != null) &#123; if (mProgress instanceof SeekBar) &#123; SeekBar seeker = (SeekBar) mProgress; seeker.setOnSeekBarChangeListener(mSeekListener); &#125; mProgress.setMax(1000); &#125; mEndTime = (TextView) v.findViewById(com.android.internal.R.id.time); mCurrentTime = (TextView) v.findViewById(com.android.internal.R.id.time_current); mFormatBuilder = new StringBuilder(); mFormatter = new Formatter(mFormatBuilder, Locale.getDefault()); installPrevNextListeners(); &#125; /** * Show the controller on screen. It will go away * automatically after 3 seconds of inactivity. */ public void show() &#123; show(sDefaultTimeout); &#125; /** * Disable pause or seek buttons if the stream cannot be paused or seeked. * This requires the control interface to be a MediaPlayerControlExt */ private void disableUnsupportedButtons() &#123; try &#123; if (mPauseButton != null &amp;&amp; !mPlayer.canPause()) &#123; mPauseButton.setEnabled(false); &#125; if (mRewButton != null &amp;&amp; !mPlayer.canSeekBackward()) &#123; mRewButton.setEnabled(false); &#125; if (mFfwdButton != null &amp;&amp; !mPlayer.canSeekForward()) &#123; mFfwdButton.setEnabled(false); &#125; &#125; catch (IncompatibleClassChangeError ex) &#123; // We were given an old version of the interface, that doesn't have // the canPause/canSeekXYZ methods. This is OK, it just means we // assume the media can be paused and seeked, and so we don't disable // the buttons. &#125; &#125; /** * Show the controller on screen. It will go away * automatically after 'timeout' milliseconds of inactivity. * @param timeout The timeout in milliseconds. Use 0 to show * the controller until hide() is called. */ public void show(int timeout) &#123; if (!mShowing &amp;&amp; mAnchor != null) &#123; setProgress(); if (mPauseButton != null) &#123; mPauseButton.requestFocus(); &#125; disableUnsupportedButtons(); updateFloatingWindowLayout(); mWindowManager.addView(mDecor, mDecorLayoutParams); mShowing = true; &#125; updatePausePlay(); // cause the progress bar to be updated even if mShowing // was already true. This happens, for example, if we're // paused with the progress bar showing the user hits play. mHandler.sendEmptyMessage(SHOW_PROGRESS); Message msg = mHandler.obtainMessage(FADE_OUT); if (timeout != 0) &#123; mHandler.removeMessages(FADE_OUT); mHandler.sendMessageDelayed(msg, timeout); &#125; &#125; public boolean isShowing() &#123; return mShowing; &#125; /** * Remove the controller from the screen. */ public void hide() &#123; if (mAnchor == null) return; if (mShowing) &#123; try &#123; mHandler.removeMessages(SHOW_PROGRESS); mWindowManager.removeView(mDecor); &#125; catch (IllegalArgumentException ex) &#123; Log.w(\"MediaController\", \"already removed\"); &#125; mShowing = false; &#125; &#125; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; int pos; switch (msg.what) &#123; case FADE_OUT: hide(); break; case SHOW_PROGRESS: pos = setProgress(); if (!mDragging &amp;&amp; mShowing &amp;&amp; mPlayer.isPlaying()) &#123; msg = obtainMessage(SHOW_PROGRESS); sendMessageDelayed(msg, 1000 - (pos % 1000)); &#125; break; &#125; &#125; &#125;; private String stringForTime(int timeMs) &#123; int totalSeconds = timeMs / 1000; int seconds = totalSeconds % 60; int minutes = (totalSeconds / 60) % 60; int hours = totalSeconds / 3600; mFormatBuilder.setLength(0); if (hours &gt; 0) &#123; return mFormatter.format(\"%d:%02d:%02d\", hours, minutes, seconds).toString(); &#125; else &#123; return mFormatter.format(\"%02d:%02d\", minutes, seconds).toString(); &#125; &#125; private int setProgress() &#123; if (mPlayer == null || mDragging) &#123; return 0; &#125; int position = mPlayer.getCurrentPosition(); int duration = mPlayer.getDuration(); if (mProgress != null) &#123; if (duration &gt; 0) &#123; // use long to avoid overflow long pos = 1000L * position / duration; mProgress.setProgress( (int) pos); &#125; int percent = mPlayer.getBufferPercentage(); mProgress.setSecondaryProgress(percent * 10); &#125; if (mEndTime != null) mEndTime.setText(stringForTime(duration)); if (mCurrentTime != null) mCurrentTime.setText(stringForTime(position)); return position; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; show(sDefaultTimeout); return true; &#125; @Override public boolean onTrackballEvent(MotionEvent ev) &#123; show(sDefaultTimeout); return false; &#125; @Override public boolean dispatchKeyEvent(KeyEvent event) &#123; int keyCode = event.getKeyCode(); final boolean uniqueDown = event.getRepeatCount() == 0 &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN; if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE || keyCode == KeyEvent.KEYCODE_SPACE) &#123; if (uniqueDown) &#123; doPauseResume(); show(sDefaultTimeout); if (mPauseButton != null) &#123; mPauseButton.requestFocus(); &#125; &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) &#123; if (uniqueDown &amp;&amp; !mPlayer.isPlaying()) &#123; mPlayer.start(); updatePausePlay(); show(sDefaultTimeout); &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) &#123; if (uniqueDown &amp;&amp; mPlayer.isPlaying()) &#123; mPlayer.pause(); updatePausePlay(); show(sDefaultTimeout); &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE || keyCode == KeyEvent.KEYCODE_CAMERA) &#123; // don't show the controls for volume adjustment return super.dispatchKeyEvent(event); &#125; else if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU) &#123; if (uniqueDown) &#123; hide(); &#125; return true; &#125; show(sDefaultTimeout); return super.dispatchKeyEvent(event); &#125; private View.OnClickListener mPauseListener = new View.OnClickListener() &#123; public void onClick(View v) &#123; doPauseResume(); show(sDefaultTimeout); &#125; &#125;; private void updatePausePlay() &#123; if (mRoot == null || mPauseButton == null) return; if (mPlayer.isPlaying()) &#123; mPauseButton.setImageResource(com.android.internal.R.drawable.ic_media_pause); &#125; else &#123; mPauseButton.setImageResource(com.android.internal.R.drawable.ic_media_play); &#125; &#125; private void doPauseResume() &#123; if (mPlayer.isPlaying()) &#123; mPlayer.pause(); &#125; else &#123; mPlayer.start(); &#125; updatePausePlay(); &#125; // There are two scenarios that can trigger the seekbar listener to trigger: // // The first is the user using the touchpad to adjust the posititon of the // seekbar's thumb. In this case onStartTrackingTouch is called followed by // a number of onProgressChanged notifications, concluded by onStopTrackingTouch. // We're setting the field \"mDragging\" to true for the duration of the dragging // session to avoid jumps in the position in case of ongoing playback. // // The second scenario involves the user operating the scroll ball, in this // case there WON'T BE onStartTrackingTouch/onStopTrackingTouch notifications, // we will simply apply the updated position without suspending regular updates. private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() &#123; public void onStartTrackingTouch(SeekBar bar) &#123; show(3600000); mDragging = true; // By removing these pending progress messages we make sure // that a) we won't update the progress while the user adjusts // the seekbar and b) once the user is done dragging the thumb // we will post one of these messages to the queue again and // this ensures that there will be exactly one message queued up. mHandler.removeMessages(SHOW_PROGRESS); &#125; public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) &#123; if (!fromuser) &#123; // We're not interested in programmatically generated changes to // the progress bar's position. return; &#125; long duration = mPlayer.getDuration(); long newposition = (duration * progress) / 1000L; mPlayer.seekTo( (int) newposition); if (mCurrentTime != null) mCurrentTime.setText(stringForTime( (int) newposition)); &#125; public void onStopTrackingTouch(SeekBar bar) &#123; mDragging = false; setProgress(); updatePausePlay(); show(sDefaultTimeout); // Ensure that progress is properly updated in the future, // the call to show() does not guarantee this because it is a // no-op if we are already showing. mHandler.sendEmptyMessage(SHOW_PROGRESS); &#125; &#125;; @Override public void setEnabled(boolean enabled) &#123; if (mPauseButton != null) &#123; mPauseButton.setEnabled(enabled); &#125; if (mFfwdButton != null) &#123; mFfwdButton.setEnabled(enabled); &#125; if (mRewButton != null) &#123; mRewButton.setEnabled(enabled); &#125; if (mNextButton != null) &#123; mNextButton.setEnabled(enabled &amp;&amp; mNextListener != null); &#125; if (mPrevButton != null) &#123; mPrevButton.setEnabled(enabled &amp;&amp; mPrevListener != null); &#125; if (mProgress != null) &#123; mProgress.setEnabled(enabled); &#125; disableUnsupportedButtons(); super.setEnabled(enabled); &#125; @Override public void onInitializeAccessibilityEvent(AccessibilityEvent event) &#123; super.onInitializeAccessibilityEvent(event); event.setClassName(MediaController.class.getName()); &#125; @Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) &#123; super.onInitializeAccessibilityNodeInfo(info); info.setClassName(MediaController.class.getName()); &#125; private View.OnClickListener mRewListener = new View.OnClickListener() &#123; public void onClick(View v) &#123; int pos = mPlayer.getCurrentPosition(); pos -= 5000; // milliseconds mPlayer.seekTo(pos); setProgress(); show(sDefaultTimeout); &#125; &#125;; private View.OnClickListener mFfwdListener = new View.OnClickListener() &#123; public void onClick(View v) &#123; int pos = mPlayer.getCurrentPosition(); pos += 15000; // milliseconds mPlayer.seekTo(pos); setProgress(); show(sDefaultTimeout); &#125; &#125;; private void installPrevNextListeners() &#123; if (mNextButton != null) &#123; mNextButton.setOnClickListener(mNextListener); mNextButton.setEnabled(mNextListener != null); &#125; if (mPrevButton != null) &#123; mPrevButton.setOnClickListener(mPrevListener); mPrevButton.setEnabled(mPrevListener != null); &#125; &#125; public void setPrevNextListeners(View.OnClickListener next, View.OnClickListener prev) &#123; mNextListener = next; mPrevListener = prev; mListenersSet = true; if (mRoot != null) &#123; installPrevNextListeners(); if (mNextButton != null &amp;&amp; !mFromXml) &#123; mNextButton.setVisibility(View.VISIBLE); &#125; if (mPrevButton != null &amp;&amp; !mFromXml) &#123; mPrevButton.setVisibility(View.VISIBLE); &#125; &#125; &#125; public interface MediaPlayerControl &#123; void start(); void pause(); int getDuration(); int getCurrentPosition(); void seekTo(int pos); boolean isPlaying(); int getBufferPercentage(); boolean canPause(); boolean canSeekBackward(); boolean canSeekForward(); /** * Get the audio session id for the player used by this VideoView. This can be used to * apply audio effects to the audio track of a video. * @return The audio session, or 0 if there was an error. */ int getAudioSessionId(); &#125;&#125; 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"ListView源码分析","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/ListView源码分析/","text":"ListView源码分析一直都想写一篇文章分析下ListView的实现，总是忙，一直拖到现在，快到年底了，写出来希望能帮助一些面试跳槽的人。当然写这篇文章也是有原因的，当时有同事在面试的时候，被对方要求当场实现一个ListView，同事简单的答了一些实现原理后，很显然对方不满意，经过几轮PK后，就有了不河蟹的结局。不欢而散，哈哈。听说后当时我想着要把ListView源码仔细分析后，我自己也去面试试试，可是拖到了现在也没机会了。 GridView与ListView都继承自AbsListView，他俩的实现也比较类似，这里就不说GridView了。只说一下ListView。首先看一下ListView的文档:1234567891011121314/* * Implementation Notes: * * Some terminology: * * index - index of the items that are currently visible * position - index of the items in the cursor *//** * A view that shows items in a vertically scrolling list. The items * come from the &#123;@link ListAdapter&#125; associated with this view. */ 然后再说一下ListView的继承关系ListView extends AbsListView extends AdapterView&lt;ListAdapter&gt; extends ViewGroup extends View。ListView与其他空间不一样，不是拖到界面上就能用，而是要通过设置适配器来添加条目。这就是AdapterView的主要功能。既然通过适配器来操作数据。这里自然想到的就是MVC设计模式。 Data - M ListView - V Adapter - C 到这里我们写罗列一下我们将要分析的内容: ListView与Adapter间的调用。 ListView上下滑动时操作及缓存。 我们平时使用ListView的时候都是调用setAdapter()方法，所以我们这里就从该方法入手:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110 /** * Sets the data behind this ListView. * * The adapter passed to this method may be wrapped by a &#123;@link WrapperListAdapter&#125;, * depending on the ListView features currently in use. For instance, adding * headers and/or footers will cause the adapter to be wrapped. * * @param adapter The ListAdapter which is responsible for maintaining the * data backing this list and for producing a view to represent an * item in that data set. * * @see #getAdapter() */ @Override public void setAdapter(ListAdapter adapter) &#123; if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123; // 取消之前注册过的Adapter mAdapter.unregisterDataSetObserver(mDataSetObserver); &#125; // 清空所有的数据 resetList(); // The data set used to store unused views that should be reused during the next layout to avoid creating new ones. // 从注释中可以很明显的看出`View`的复用是通过`RecycleBin`类来实现的。它就决定了为什么`ListView`可以显示很多数据缺不会内存溢出。 mRecycler.clear(); if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123; // 如果有HeaderView或者FooterView就把Adapter重新封装下,这是什么设计模式？－装饰 // mHeaderViewInfos和mFooterViewInfos分别是header view和foooter view装饰类FixedViewInfo的集合。 // 会在addHeaderView()和addFooterView()中进行添加。 mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, adapter); &#125; else &#123; mAdapter = adapter; &#125; mOldSelectedPosition = INVALID_POSITION; mOldSelectedRowId = INVALID_ROW_ID; // AbsListView#setAdapter will update choice mode states. super.setAdapter(adapter); if (mAdapter != null) &#123; mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; mItemCount = mAdapter.getCount(); checkFocus(); mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); // 将viewtypecount设置给RecycleBin mRecycler.setViewTypeCount(mAdapter.getViewTypeCount()); int position; // mStackFromBottom Indicates whether the list is stacked from the bottom edge or the top edge. if (mStackFromBottom) &#123; position = lookForSelectablePosition(mItemCount - 1, false); &#125; else &#123; position = lookForSelectablePosition(0, true); &#125; setSelectedPositionInt(position); setNextSelectedPositionInt(position); if (mItemCount == 0) &#123; // Nothing selected checkSelectionChanged(); &#125; &#125; else &#123; mAreAllItemsSelectable = true; checkFocus(); // Nothing selected checkSelectionChanged(); &#125; // 请求layout了，这个就很重要了啊...我们稍后看一下。 requestLayout(); &#125;/** * The list is empty. Clear everything out. */ @Override void resetList() &#123; // The parent's resetList() will remove all views from the layout so we need to // cleanup the state of our footers and headers clearRecycledState(mHeaderViewInfos); clearRecycledState(mFooterViewInfos); // The list is empty. Clear everything out. super.resetList(); mLayoutMode = LAYOUT_NORMAL; &#125;private void clearRecycledState(ArrayList&lt;FixedViewInfo&gt; infos) &#123; if (infos != null) &#123; final int count = infos.size(); for (int i = 0; i &lt; count; i++) &#123; final View child = infos.get(i).view; final LayoutParams p = (LayoutParams) child.getLayoutParams(); if (p != null) &#123; // 这里p就是AbsListView.LayoutParams。对于recycledHeaderFooter在注释中是这样说的. /** * When this boolean is set, the view has been added to the AbsListView * at least once. It is used to know whether headers/footers have already * been added to the list view and whether they should be treated as * recycled views or not. */ p.recycledHeaderFooter = false; &#125; &#125; &#125; &#125; 我们看到setAdapter()方法中会调用requestLayout()方法。而requestLayout()方法会调用onLayout()方法，但是我们在ListView中找不到onLayout()方法。那就去他的父类AbsListView中找。我们接着来看一下AbsListView.onLayout()方法的实现。1234567891011121314151617181920212223242526272829/** * Subclasses should NOT override this method but * &#123;@link #layoutChildren()&#125; instead. */@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); mInLayout = true; final int childCount = getChildCount(); if (changed) &#123; for (int i = 0; i &lt; childCount; i++) &#123; getChildAt(i).forceLayout(); &#125; mRecycler.markChildrenDirty(); &#125; // 调用layoutChildren()方法。 layoutChildren(); mInLayout = false; mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR; // TODO: Move somewhere sane. This doesn't belong in onLayout(). if (mFastScroll != null) &#123; mFastScroll.onItemCountChanged(getChildCount(), mItemCount); &#125;&#125; 我们看一下AbsListView.layoutChildren()方法的实现:12345/** * Subclasses must override this method to layout their children. */protected void layoutChildren() &#123;&#125; 实现是空的,文档说的很明白了，子类必须要去实现该方法，这也是应该的，因为ListView和GridView的展现是不一样的.所以我们看一下ListView.layoutChildren()方法的实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337@Overrideprotected void layoutChildren() &#123; // When set to true, calls to requestLayout() will not propagate up the parent hierarchy. // This is used to layout the children during a layout pass. final boolean blockLayoutRequests = mBlockLayoutRequests; if (blockLayoutRequests) &#123; return; &#125; // 开始了，置为true mBlockLayoutRequests = true; try &#123; super.layoutChildren(); invalidate(); if (mAdapter == null) &#123; resetList(); invokeOnItemScrollListener(); return; &#125; final int childrenTop = mListPadding.top; final int childrenBottom = mBottom - mTop - mListPadding.bottom; final int childCount = getChildCount(); int index = 0; int delta = 0; View sel; View oldSel = null; View oldFirst = null; View newSel = null; // Remember stuff we will need down below // mLayoutMode的注释为Controls how the next layout will happen，默认为LAYOUT_NORMAL switch (mLayoutMode) &#123; case LAYOUT_SET_SELECTION: index = mNextSelectedPosition - mFirstPosition; if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123; newSel = getChildAt(index); &#125; break; case LAYOUT_FORCE_TOP: case LAYOUT_FORCE_BOTTOM: case LAYOUT_SPECIFIC: case LAYOUT_SYNC: break; case LAYOUT_MOVE_SELECTION: default: // Remember the previously selected view index = mSelectedPosition - mFirstPosition; if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123; oldSel = getChildAt(index); &#125; // Remember the previous first child oldFirst = getChildAt(0); if (mNextSelectedPosition &gt;= 0) &#123; delta = mNextSelectedPosition - mSelectedPosition; &#125; // Caution: newSel might be null newSel = getChildAt(index + delta); &#125; // mDataChanged变量标记Adapter中数据是否发生变化 boolean dataChanged = mDataChanged; if (dataChanged) &#123; handleDataChanged(); &#125; // Handle the empty set by removing all views that are visible // and calling it a day if (mItemCount == 0) &#123; resetList(); invokeOnItemScrollListener(); return; &#125; else if (mItemCount != mAdapter.getCount()) &#123; throw new IllegalStateException(\"The content of the adapter has changed but \" + \"ListView did not receive a notification. Make sure the content of \" + \"your adapter is not modified from a background thread, but only from \" + \"the UI thread. Make sure your adapter calls notifyDataSetChanged() \" + \"when its content changes. [in ListView(\" + getId() + \", \" + getClass() + \") with Adapter(\" + mAdapter.getClass() + \")]\"); &#125; setSelectedPositionInt(mNextSelectedPosition); AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null; View accessibilityFocusLayoutRestoreView = null; int accessibilityFocusPosition = INVALID_POSITION; // Remember which child, if any, had accessibility focus. This must // occur before recycling any views, since that will clear // accessibility focus. final ViewRootImpl viewRootImpl = getViewRootImpl(); if (viewRootImpl != null) &#123; final View focusHost = viewRootImpl.getAccessibilityFocusedHost(); if (focusHost != null) &#123; final View focusChild = getAccessibilityFocusedChild(focusHost); if (focusChild != null) &#123; if (!dataChanged || isDirectChildHeaderOrFooter(focusChild) || focusChild.hasTransientState() || mAdapterHasStableIds) &#123; // The views won't be changing, so try to maintain // focus on the current host and virtual view. accessibilityFocusLayoutRestoreView = focusHost; accessibilityFocusLayoutRestoreNode = viewRootImpl .getAccessibilityFocusedVirtualView(); &#125; // If all else fails, maintain focus at the same // position. accessibilityFocusPosition = getPositionForView(focusChild); &#125; &#125; &#125; View focusLayoutRestoreDirectChild = null; View focusLayoutRestoreView = null; // Take focus back to us temporarily to avoid the eventual call to // clear focus when removing the focused child below from messing // things up when ViewAncestor assigns focus back to someone else. final View focusedChild = getFocusedChild(); if (focusedChild != null) &#123; // TODO: in some cases focusedChild.getParent() == null // We can remember the focused view to restore after re-layout // if the data hasn't changed, or if the focused position is a // header or footer. if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) &#123; focusLayoutRestoreDirectChild = focusedChild; // Remember the specific view that had focus. focusLayoutRestoreView = findFocus(); if (focusLayoutRestoreView != null) &#123; // Tell it we are going to mess with it. focusLayoutRestoreView.onStartTemporaryDetach(); &#125; &#125; requestFocus(); &#125; // Pull all children into the RecycleBin. // These views will be reused if possible final int firstPosition = mFirstPosition; final RecycleBin recycleBin = mRecycler; // RecycleBin控制着整个item的复用，等最后我们再仔细分析下RecycleBin类 if (dataChanged) &#123; // 如果数据发生变化，就把现在的View都添加到一个废弃的View进行缓存，RecycleBin.addScrapView()方法就是缓存一些废弃的View for (int i = 0; i &lt; childCount; i++) &#123; recycleBin.addScrapView(getChildAt(i), firstPosition+i); &#125; &#125; else &#123; // 调用这个方法后就会根据传入的参数来将ListView中的指定元素存储到mActiveViews数组当中。 recycleBin.fillActiveViews(childCount, firstPosition); &#125; // Clear out old views detachAllViewsFromParent(); recycleBin.removeSkippedScrap(); // mLayoutMode默认是LAYOUT_NORMAL switch (mLayoutMode) &#123; case LAYOUT_SET_SELECTION: if (newSel != null) &#123; sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom); &#125; else &#123; sel = fillFromMiddle(childrenTop, childrenBottom); &#125; break; case LAYOUT_SYNC: sel = fillSpecific(mSyncPosition, mSpecificTop); break; case LAYOUT_FORCE_BOTTOM: sel = fillUp(mItemCount - 1, childrenBottom); adjustViewsUpOrDown(); break; case LAYOUT_FORCE_TOP: mFirstPosition = 0; sel = fillFromTop(childrenTop); adjustViewsUpOrDown(); break; case LAYOUT_SPECIFIC: sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop); break; case LAYOUT_MOVE_SELECTION: sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom); break; default: // 第一次调用layoutChildren方法的时候是还没有layout的，所以这时候childCount是0 if (childCount == 0) &#123; // mStackFromBottom的注释Indicates whether the list is stacked from the bottom edge or the top edge. if (!mStackFromBottom) &#123; // 默认的布局方式是从上往下的。 final int position = lookForSelectablePosition(0, true); setSelectedPositionInt(position); // 调用fillFromTop方法。 sel = fillFromTop(childrenTop); &#125; else &#123; final int position = lookForSelectablePosition(mItemCount - 1, false); setSelectedPositionInt(position); sel = fillUp(mItemCount - 1, childrenBottom); &#125; &#125; else &#123; // 如果已经有条目了就会走到这里 if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123; sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop()); &#125; else if (mFirstPosition &lt; mItemCount) &#123; // 没有选中的条目 // TODO 一会先分析上面的fillFromTop部分，把其全部分析完后再回来分析这里。 sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop()); &#125; else &#123; sel = fillSpecific(0, childrenTop); &#125; &#125; break; &#125; // Flush any cached views that did not get reused above recycleBin.scrapActiveViews(); if (sel != null) &#123; // The current selected item should get focus if items are // focusable. if (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123; final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp; focusLayoutRestoreView != null &amp;&amp; focusLayoutRestoreView.requestFocus()) || sel.requestFocus(); if (!focusWasTaken) &#123; // Selected item didn't take focus, but we still want to // make sure something else outside of the selected view // has focus. final View focused = getFocusedChild(); if (focused != null) &#123; focused.clearFocus(); &#125; positionSelector(INVALID_POSITION, sel); &#125; else &#123; sel.setSelected(false); mSelectorRect.setEmpty(); &#125; &#125; else &#123; positionSelector(INVALID_POSITION, sel); &#125; mSelectedTop = sel.getTop(); &#125; else &#123; final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING; if (inTouchMode) &#123; // If the user's finger is down, select the motion position. final View child = getChildAt(mMotionPosition - mFirstPosition); if (child != null) &#123; positionSelector(mMotionPosition, child); &#125; &#125; else if (mSelectorPosition != INVALID_POSITION) &#123; // If we had previously positioned the selector somewhere, // put it back there. It might not match up with the data, // but it's transitioning out so it's not a big deal. final View child = getChildAt(mSelectorPosition - mFirstPosition); if (child != null) &#123; positionSelector(mSelectorPosition, child); &#125; &#125; else &#123; // Otherwise, clear selection. mSelectedTop = 0; mSelectorRect.setEmpty(); &#125; // Even if there is not selected position, we may need to // restore focus (i.e. something focusable in touch mode). if (hasFocus() &amp;&amp; focusLayoutRestoreView != null) &#123; focusLayoutRestoreView.requestFocus(); &#125; &#125; // Attempt to restore accessibility focus, if necessary. if (viewRootImpl != null) &#123; final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost(); if (newAccessibilityFocusedView == null) &#123; if (accessibilityFocusLayoutRestoreView != null &amp;&amp; accessibilityFocusLayoutRestoreView.isAttachedToWindow()) &#123; final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider(); if (accessibilityFocusLayoutRestoreNode != null &amp;&amp; provider != null) &#123; final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId( accessibilityFocusLayoutRestoreNode.getSourceNodeId()); provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null); &#125; else &#123; accessibilityFocusLayoutRestoreView.requestAccessibilityFocus(); &#125; &#125; else if (accessibilityFocusPosition != INVALID_POSITION) &#123; // Bound the position within the visible children. final int position = MathUtils.constrain( accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1); final View restoreView = getChildAt(position); if (restoreView != null) &#123; restoreView.requestAccessibilityFocus(); &#125; &#125; &#125; &#125; // Tell focus view we are done mucking with it, if it is still in // our view hierarchy. if (focusLayoutRestoreView != null &amp;&amp; focusLayoutRestoreView.getWindowToken() != null) &#123; focusLayoutRestoreView.onFinishTemporaryDetach(); &#125; mLayoutMode = LAYOUT_NORMAL; mDataChanged = false; if (mPositionScrollAfterLayout != null) &#123; post(mPositionScrollAfterLayout); mPositionScrollAfterLayout = null; &#125; mNeedSync = false; setNextSelectedPositionInt(mSelectedPosition); updateScrollIndicators(); if (mItemCount &gt; 0) &#123; checkSelectionChanged(); &#125; invokeOnItemScrollListener(); &#125; finally &#123; if (!blockLayoutRequests) &#123; mBlockLayoutRequests = false; &#125; &#125;&#125; 上面看到会调用fillFromTop()方法，我们看一下该方法的实现:1234567891011121314151617/** * Fills the list from top to bottom, starting with mFirstPosition * * @param nextTop The location where the top of the first item should be * drawn * * @return The view that is currently selected */private View fillFromTop(int nextTop) &#123; mFirstPosition = Math.min(mFirstPosition, mSelectedPosition); mFirstPosition = Math.min(mFirstPosition, mItemCount - 1); if (mFirstPosition &lt; 0) &#123; mFirstPosition = 0; &#125; // 调用fillDown()方法。 return fillDown(mFirstPosition, nextTop);&#125; 接下来我们看一下fillDown()方法的实现:123456789101112131415161718192021222324252627282930313233343536/** * Fills the list from pos down to the end of the list view. * * @param pos The first position to put in the list * * @param nextTop The location where the top of the item associated with pos * should be drawn * * @return The view that is currently selected, if it happens to be in the * range that we draw. */private View fillDown(int pos, int nextTop) &#123; View selectedView = null; int end = (mBottom - mTop); if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; end -= mListPadding.bottom; &#125; // 用一个循环一直去填充，nextTop与end的比较来判断是否超过当前屏幕了，这就是为什么ListView就算有一万条最开始载入也不卡，因为他只初始化一屏啊。 // 以后都是边滑动边显示啊，说到这里一会我们还要看一下手势部分的处理。pos和mItemCount的比较来判断当前是否已经把所有条目填充完 while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123; // is this the selected item? boolean selected = pos == mSelectedPosition; // 调用makeAndAddView方法 View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected); nextTop = child.getBottom() + mDividerHeight; if (selected) &#123; selectedView = child; &#125; pos++; &#125; setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1); return selectedView;&#125; 接下来看一下makeAndAddView()方法，文档里面说的非常清楚了: 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Obtain the view and add it to our list of children. The view can be made * fresh, converted from an unused view, or used as is if it was in the * recycle bin. * * @param position Logical position in the list * @param y Top or bottom edge of the view to add * @param flow If flow is true, align top edge to y. If false, align bottom * edge to y. * @param childrenLeft Left edge where children should be positioned * @param selected Is this position selected? * @return View that was added */private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) &#123; View child; if (!mDataChanged) &#123; // Try to use an existing view for this position child = mRecycler.getActiveView(position); if (child != null) &#123; // Found it -- we're using an existing child // This just needs to be positioned // 最后一个参数为true说明是复用的 setupChild(child, position, y, flow, childrenLeft, selected, true); return child; &#125; &#125; // Make a new view for this position, or convert an unused view if possible // 一会我们先看一下obtainView方法，这个方法其实就是创建一个childView // obtainView方法中会更改mIsScrap[0]的值，以便下面setupChild()中使用。 child = obtainView(position, mIsScrap); // This needs to be positioned and measured // 把childView添加到listview中，这里最后一个参数会是false setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child;&#125; 在makeAndAddView()方法里面就是通过RecycleBin来复用View，如果不存在可以复用的View时就创建一个新的。那我们就先看一下`obtainView()方法，这个方法中的注释写的非常清楚，谷歌大神写代码就是规范，不想某些牛逼哄哄的人整天咋呼敏捷开发，一个注释也不写，那能叫敏捷？。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Get a view and have it show the data associated with the specified * position. This is called when we have already discovered that the view is * not available for reuse in the recycle bin. The only choices left are * converting an old view or making a new one. * * @param position The position to display * @param isScrap Array of at least 1 boolean, the first entry will become true if * the returned view was taken from the scrap heap, false if otherwise. * * @return A view displaying the data associated with the specified position */View obtainView(int position, boolean[] isScrap) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"obtainView\"); isScrap[0] = false; // Check whether we have a transient state view. Attempt to re-bind the // data and discard the view if we fail. final View transientView = mRecycler.getTransientStateView(position); if (transientView != null) &#123; final LayoutParams params = (LayoutParams) transientView.getLayoutParams(); // If the view type hasn't changed, attempt to re-bind the data. if (params.viewType == mAdapter.getItemViewType(position)) &#123; final View updatedView = mAdapter.getView(position, transientView, this); // If we failed to re-bind the data, scrap the obtained view. if (updatedView != transientView) &#123; setItemViewLayoutParams(updatedView, position); mRecycler.addScrapView(updatedView, position); &#125; &#125; // Scrap view implies temporary detachment. isScrap[0] = true; return transientView; &#125; // getScrapView()方法会从废弃View的缓存中去取，一旦View移除了屏幕就会被加到该废弃缓存中，所以他就是当View移除屏幕了就加到该缓存中 // 显示的时候再从该缓存中取，就这样进行了复用。 final View scrapView = mRecycler.getScrapView(position); // 调用Adapter.getView()方法了。并且将scrapView作为converview的参数传入。这个方法都挺熟，就不说了。 final View child = mAdapter.getView(position, scrapView, this); if (scrapView != null) &#123; if (child != scrapView) &#123; // Failed to re-bind the data, return scrap to the heap. mRecycler.addScrapView(scrapView, position); &#125; else &#123; isScrap[0] = true; child.dispatchFinishTemporaryDetach(); &#125; &#125; if (mCacheColorHint != 0) &#123; child.setDrawingCacheBackgroundColor(mCacheColorHint); &#125; if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123; child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES); &#125; // 设置该view的layoutparams setItemViewLayoutParams(child, position); if (AccessibilityManager.getInstance(mContext).isEnabled()) &#123; if (mAccessibilityDelegate == null) &#123; mAccessibilityDelegate = new ListItemAccessibilityDelegate(); &#125; if (child.getAccessibilityDelegate() == null) &#123; child.setAccessibilityDelegate(mAccessibilityDelegate); &#125; &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); return child;&#125; 到这里我们就把obtainView()方法都看完了，接下来我们再看一下setupChild()方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Add a view as a child and make sure it is measured (if necessary) and * positioned properly. * * @param child The view to add * @param position The position of this child * @param y The y position relative to which this view will be positioned * @param flowDown If true, align top edge to y. If false, align bottom * edge to y. * @param childrenLeft Left edge where children should be positioned * @param selected Is this position selected? * @param recycled Has this view been pulled from the recycle bin? If so it * does not need to be remeasured. */private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft, boolean selected, boolean recycled) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"setupListItem\"); final boolean isSelected = selected &amp;&amp; shouldShowSelector(); final boolean updateChildSelected = isSelected != child.isSelected(); final int mode = mTouchMode; final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL &amp;&amp; mMotionPosition == position; final boolean updateChildPressed = isPressed != child.isPressed(); final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested(); // Respect layout params that are already in the view. Otherwise make some up... // noinspection unchecked AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams(); if (p == null) &#123; p = (AbsListView.LayoutParams) generateDefaultLayoutParams(); &#125; // 这里就是Adapter中getItemViewType的调用处 p.viewType = mAdapter.getItemViewType(position); if ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123; // 复用的或者headerView及footerView等调用attachViewToParent方法，把之前detach的View重新attach到ViewGroup上 attachViewToParent(child, flowDown ? -1 : 0, p); &#125; else &#123; p.forceAdd = false; if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123; p.recycledHeaderFooter = true; &#125; // 第一次都是通过该方法来把View添加到ViewGroup中 addViewInLayout(child, flowDown ? -1 : 0, p, true); &#125; if (updateChildSelected) &#123; child.setSelected(isSelected); &#125; if (updateChildPressed) &#123; child.setPressed(isPressed); &#125; if (mChoiceMode != CHOICE_MODE_NONE &amp;&amp; mCheckStates != null) &#123; if (child instanceof Checkable) &#123; ((Checkable) child).setChecked(mCheckStates.get(position)); &#125; else if (getContext().getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.HONEYCOMB) &#123; child.setActivated(mCheckStates.get(position)); &#125; &#125; if (needToMeasure) &#123; int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, mListPadding.left + mListPadding.right, p.width); int lpHeight = p.height; int childHeightSpec; if (lpHeight &gt; 0) &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); &#125; else &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); &#125; child.measure(childWidthSpec, childHeightSpec); &#125; else &#123; cleanupLayoutState(child); &#125; final int w = child.getMeasuredWidth(); final int h = child.getMeasuredHeight(); final int childTop = flowDown ? y : y - h; if (needToMeasure) &#123; final int childRight = childrenLeft + w; final int childBottom = childTop + h; child.layout(childrenLeft, childTop, childRight, childBottom); &#125; else &#123; child.offsetLeftAndRight(childrenLeft - child.getLeft()); child.offsetTopAndBottom(childTop - child.getTop()); &#125; if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123; child.setDrawingCacheEnabled(true); &#125; if (recycled &amp;&amp; (((AbsListView.LayoutParams)child.getLayoutParams()).scrappedFromPosition) != position) &#123; child.jumpDrawablesToCurrentState(); &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW);&#125; 通过分析我们看到核心的部分就是attachViewToParent()方法和addViewInLayout()方法，这两个方法都是父类ViewGroup中的方法，我们分别来看一下:12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Attaches a view to this view group. Attaching a view assigns this group as the parent, * sets the layout parameters and puts the view in the list of children so that * it can be retrieved by calling &#123;@link #getChildAt(int)&#125;. * &lt;p&gt; * This method is intended to be lightweight and makes no assumptions about whether the * parent or child should be redrawn. Proper use of this method will include also making * any appropriate &#123;@link #requestLayout()&#125; or &#123;@link #invalidate()&#125; calls. * For example, callers can &#123;@link #post(Runnable) post&#125; a &#123;@link Runnable&#125; * which performs a &#123;@link #requestLayout()&#125; on the next frame, after all detach/attach * calls are finished, causing layout to be run prior to redrawing the view hierarchy. * &lt;p&gt; * This method should be called only for views which were detached from their parent. * * @param child the child to attach * @param index the index at which the child should be attached * @param params the layout parameters of the child * * @see #removeDetachedView(View, boolean) * @see #detachAllViewsFromParent() * @see #detachViewFromParent(View) * @see #detachViewFromParent(int) */protected void attachViewToParent(View child, int index, LayoutParams params) &#123; child.mLayoutParams = params; if (index &lt; 0) &#123; index = mChildrenCount; &#125; // 把该view添加到数组中，就像注释所说的为了能够让`getChildAt()`方法能获取到。 addInArray(child, index); child.mParent = this; child.mPrivateFlags = (child.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK &amp; ~PFLAG_DRAWING_CACHE_VALID) | PFLAG_DRAWN | PFLAG_INVALIDATED; this.mPrivateFlags |= PFLAG_INVALIDATED; if (child.hasFocus()) &#123; requestChildFocus(child, child.findFocus()); &#125;&#125; 复用的处理看完后，我们看一下新创建的childView如何被添加到ListView上，我们看一下addViewInLayout()方法:123456789101112131415161718192021222324/** * Adds a view during layout. This is useful if in your onLayout() method, * you need to add more views (as does the list view for example). * * If index is negative, it means put it at the end of the list. * * @param child the view to add to the group * @param index the index at which the child must be added * @param params the layout parameters to associate with the child * @param preventRequestLayout if true, calling this method will not trigger a * layout request on child * @return true if the child was added, false otherwise */protected boolean addViewInLayout(View child, int index, LayoutParams params, boolean preventRequestLayout) &#123; if (child == null) &#123; throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\"); &#125; child.mParent = null; // 这个方法最终会调用addView方法添加childView addViewInner(child, index, params, preventRequestLayout); child.mPrivateFlags = (child.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; return true;&#125; 到这里已经把上面fillFromTop()方法的部分都分析完了。不要忘了我们上面还留了一个TODO的部分，就是对于已经有数据的部分调用fillSpecific()方法，那我们就看一下他的实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Put a specific item at a specific location on the screen and then build * up and down from there. * * @param position The reference view to use as the starting point * @param top Pixel offset from the top of this view to the top of the * reference view. * * @return The selected view, or null if the selected view is outside the * visible area. */private View fillSpecific(int position, int top) &#123; boolean tempIsSelected = position == mSelectedPosition; View temp = makeAndAddView(position, top, true, mListPadding.left, tempIsSelected); // Possibly changed again in fillUp if we add rows above this one. mFirstPosition = position; View above; View below; final int dividerHeight = mDividerHeight; if (!mStackFromBottom) &#123; above = fillUp(position - 1, temp.getTop() - dividerHeight); // This will correct for the top of the first view not touching the top of the list adjustViewsUpOrDown(); below = fillDown(position + 1, temp.getBottom() + dividerHeight); int childCount = getChildCount(); if (childCount &gt; 0) &#123; correctTooHigh(childCount); &#125; &#125; else &#123; below = fillDown(position + 1, temp.getBottom() + dividerHeight); // This will correct for the bottom of the last view not touching the bottom of the list adjustViewsUpOrDown(); above = fillUp(position - 1, temp.getTop() - dividerHeight); int childCount = getChildCount(); if (childCount &gt; 0) &#123; correctTooLow(childCount); &#125; &#125; if (tempIsSelected) &#123; return temp; &#125; else if (above != null) &#123; return above; &#125; else &#123; return below; &#125;&#125; 就像注释所说的它是让指定位置的View先加载到屏幕上，然后在加载该view往上以及往下位置的其他View，他里面会调用fillUp()和fillDown()方法，又会走上面的流程，所以这里就不分析了。 好了，到这里我们就基本已经分析完了，但是感觉好像好少了点什么？ 这里少了不是一点，是两点: 手势滑动过程中ListView的复用处理 RecycleBin中复用的具体实现 一个个的来，先看一下手势滑动部分，这个当然是从onTouchEvent()方法看了，手势这一块不太清楚的可以看我之前的一篇文章Android Touch事件分发详解 发现ListView没有重写onTouchEvent()方法，这也好理解，因为GridView也有类似的滑动功能，所以去父类AbsListView中看.我们看一下AbsListView.onTouchEvent()方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; if (!isEnabled()) &#123; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return isClickable() || isLongClickable(); &#125; if (mPositionScroller != null) &#123; mPositionScroller.stop(); &#125; if (mIsDetaching || !isAttachedToWindow()) &#123; // Something isn't right. // Since we rely on being attached to get data set change notifications, // don't risk doing anything where we might try to resync and find things // in a bogus state. return false; &#125; startNestedScroll(SCROLL_AXIS_VERTICAL); if (mFastScroll != null) &#123; boolean intercepted = mFastScroll.onTouchEvent(ev); if (intercepted) &#123; return true; &#125; &#125; initVelocityTrackerIfNotExists(); final MotionEvent vtev = MotionEvent.obtain(ev); final int actionMasked = ev.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; mNestedYOffset = 0; &#125; vtev.offsetLocation(0, mNestedYOffset); switch (actionMasked) &#123; case MotionEvent.ACTION_DOWN: &#123; onTouchDown(ev); break; &#125; case MotionEvent.ACTION_MOVE: &#123; // 具体移动的部分就在这里了 onTouchMove(ev, vtev); break; &#125; case MotionEvent.ACTION_UP: &#123; onTouchUp(ev); break; &#125; case MotionEvent.ACTION_CANCEL: &#123; onTouchCancel(); break; &#125; case MotionEvent.ACTION_POINTER_UP: &#123; onSecondaryPointerUp(ev); final int x = mMotionX; final int y = mMotionY; final int motionPosition = pointToPosition(x, y); if (motionPosition &gt;= 0) &#123; // Remember where the motion event started final View child = getChildAt(motionPosition - mFirstPosition); mMotionViewOriginalTop = child.getTop(); mMotionPosition = motionPosition; &#125; mLastY = y; break; &#125; case MotionEvent.ACTION_POINTER_DOWN: &#123; // New pointers take over dragging duties final int index = ev.getActionIndex(); final int id = ev.getPointerId(index); final int x = (int) ev.getX(index); final int y = (int) ev.getY(index); mMotionCorrection = 0; mActivePointerId = id; mMotionX = x; mMotionY = y; final int motionPosition = pointToPosition(x, y); if (motionPosition &gt;= 0) &#123; // Remember where the motion event started final View child = getChildAt(motionPosition - mFirstPosition); mMotionViewOriginalTop = child.getTop(); mMotionPosition = motionPosition; &#125; mLastY = y; break; &#125; &#125; if (mVelocityTracker != null) &#123; mVelocityTracker.addMovement(vtev); &#125; vtev.recycle(); return true;&#125; 接着看一下onTouchMove()方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private void onTouchMove(MotionEvent ev, MotionEvent vtev) &#123; int pointerIndex = ev.findPointerIndex(mActivePointerId); if (pointerIndex == -1) &#123; pointerIndex = 0; mActivePointerId = ev.getPointerId(pointerIndex); &#125; if (mDataChanged) &#123; // Re-sync everything if data has been changed // since the scroll operation can query the adapter. layoutChildren(); &#125; final int y = (int) ev.getY(pointerIndex); switch (mTouchMode) &#123; case TOUCH_MODE_DOWN: case TOUCH_MODE_TAP: case TOUCH_MODE_DONE_WAITING: // Check if we have moved far enough that it looks more like a // scroll than a tap. If so, we'll enter scrolling mode. if (startScrollIfNeeded((int) ev.getX(pointerIndex), y, vtev)) &#123; break; &#125; // Otherwise, check containment within list bounds. If we're // outside bounds, cancel any active presses. final View motionView = getChildAt(mMotionPosition - mFirstPosition); final float x = ev.getX(pointerIndex); if (!pointInView(x, y, mTouchSlop)) &#123; setPressed(false); if (motionView != null) &#123; motionView.setPressed(false); &#125; removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress); mTouchMode = TOUCH_MODE_DONE_WAITING; updateSelectorState(); &#125; else if (motionView != null) &#123; // Still within bounds, update the hotspot. final float[] point = mTmpPoint; point[0] = x; point[1] = y; transformPointToViewLocal(point, motionView); motionView.drawableHotspotChanged(point[0], point[1]); &#125; break; case TOUCH_MODE_SCROLL: case TOUCH_MODE_OVERSCROLL: // 滑动部分的处理，传入当前位置的x,y坐标 scrollIfNeeded((int) ev.getX(pointerIndex), y, vtev); break; &#125;&#125; 再看一下scrollIfNeeded()方法的实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203private void scrollIfNeeded(int x, int y, MotionEvent vtev) &#123; int rawDeltaY = y - mMotionY; int scrollOffsetCorrection = 0; int scrollConsumedCorrection = 0; if (mLastY == Integer.MIN_VALUE) &#123; rawDeltaY -= mMotionCorrection; &#125; if (dispatchNestedPreScroll(0, mLastY != Integer.MIN_VALUE ? mLastY - y : -rawDeltaY, mScrollConsumed, mScrollOffset)) &#123; rawDeltaY += mScrollConsumed[1]; scrollOffsetCorrection = -mScrollOffset[1]; scrollConsumedCorrection = mScrollConsumed[1]; if (vtev != null) &#123; vtev.offsetLocation(0, mScrollOffset[1]); mNestedYOffset += mScrollOffset[1]; &#125; &#125; final int deltaY = rawDeltaY; int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY + scrollConsumedCorrection : deltaY; int lastYCorrection = 0; if (mTouchMode == TOUCH_MODE_SCROLL) &#123; if (PROFILE_SCROLLING) &#123; if (!mScrollProfilingStarted) &#123; Debug.startMethodTracing(\"AbsListViewScroll\"); mScrollProfilingStarted = true; &#125; &#125; if (mScrollStrictSpan == null) &#123; // If it's non-null, we're already in a scroll. mScrollStrictSpan = StrictMode.enterCriticalSpan(\"AbsListView-scroll\"); &#125; if (y != mLastY) &#123; // 移动了 // We may be here after stopping a fling and continuing to scroll. // If so, we haven't disallowed intercepting touch events yet. // Make sure that we do so in case we're in a parent that can intercept. if ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) == 0 &amp;&amp; Math.abs(rawDeltaY) &gt; mTouchSlop) &#123; final ViewParent parent = getParent(); if (parent != null) &#123; parent.requestDisallowInterceptTouchEvent(true); &#125; &#125; final int motionIndex; if (mMotionPosition &gt;= 0) &#123; motionIndex = mMotionPosition - mFirstPosition; &#125; else &#123; // If we don't have a motion position that we can reliably track, // pick something in the middle to make a best guess at things below. motionIndex = getChildCount() / 2; &#125; int motionViewPrevTop = 0; View motionView = this.getChildAt(motionIndex); if (motionView != null) &#123; motionViewPrevTop = motionView.getTop(); &#125; // No need to do all this work if we're not going to move anyway boolean atEdge = false; if (incrementalDeltaY != 0) &#123; // 移动的过程中不断调用 atEdge = trackMotionScroll(deltaY, incrementalDeltaY); &#125; // Check to see if we have bumped into the scroll limit motionView = this.getChildAt(motionIndex); if (motionView != null) &#123; // Check if the top of the motion view is where it is // supposed to be final int motionViewRealTop = motionView.getTop(); if (atEdge) &#123; // Apply overscroll int overscroll = -incrementalDeltaY - (motionViewRealTop - motionViewPrevTop); if (dispatchNestedScroll(0, overscroll - incrementalDeltaY, 0, overscroll, mScrollOffset)) &#123; lastYCorrection -= mScrollOffset[1]; if (vtev != null) &#123; vtev.offsetLocation(0, mScrollOffset[1]); mNestedYOffset += mScrollOffset[1]; &#125; &#125; else &#123; final boolean atOverscrollEdge = overScrollBy(0, overscroll, 0, mScrollY, 0, 0, 0, mOverscrollDistance, true); if (atOverscrollEdge &amp;&amp; mVelocityTracker != null) &#123; // Don't allow overfling if we're at the edge mVelocityTracker.clear(); &#125; final int overscrollMode = getOverScrollMode(); if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp; !contentFits())) &#123; if (!atOverscrollEdge) &#123; mDirection = 0; // Reset when entering overscroll. mTouchMode = TOUCH_MODE_OVERSCROLL; &#125; if (incrementalDeltaY &gt; 0) &#123; mEdgeGlowTop.onPull((float) -overscroll / getHeight(), (float) x / getWidth()); if (!mEdgeGlowBottom.isFinished()) &#123; mEdgeGlowBottom.onRelease(); &#125; invalidate(0, 0, getWidth(), mEdgeGlowTop.getMaxHeight() + getPaddingTop()); &#125; else if (incrementalDeltaY &lt; 0) &#123; mEdgeGlowBottom.onPull((float) overscroll / getHeight(), 1.f - (float) x / getWidth()); if (!mEdgeGlowTop.isFinished()) &#123; mEdgeGlowTop.onRelease(); &#125; invalidate(0, getHeight() - getPaddingBottom() - mEdgeGlowBottom.getMaxHeight(), getWidth(), getHeight()); &#125; &#125; &#125; &#125; mMotionY = y + lastYCorrection + scrollOffsetCorrection; &#125; mLastY = y + lastYCorrection + scrollOffsetCorrection; &#125; &#125; else if (mTouchMode == TOUCH_MODE_OVERSCROLL) &#123; // 灰起了. if (y != mLastY) &#123; final int oldScroll = mScrollY; final int newScroll = oldScroll - incrementalDeltaY; int newDirection = y &gt; mLastY ? 1 : -1; if (mDirection == 0) &#123; mDirection = newDirection; &#125; int overScrollDistance = -incrementalDeltaY; if ((newScroll &lt; 0 &amp;&amp; oldScroll &gt;= 0) || (newScroll &gt; 0 &amp;&amp; oldScroll &lt;= 0)) &#123; overScrollDistance = -oldScroll; incrementalDeltaY += overScrollDistance; &#125; else &#123; incrementalDeltaY = 0; &#125; if (overScrollDistance != 0) &#123; overScrollBy(0, overScrollDistance, 0, mScrollY, 0, 0, 0, mOverscrollDistance, true); final int overscrollMode = getOverScrollMode(); if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp; !contentFits())) &#123; if (rawDeltaY &gt; 0) &#123; mEdgeGlowTop.onPull((float) overScrollDistance / getHeight(), (float) x / getWidth()); if (!mEdgeGlowBottom.isFinished()) &#123; mEdgeGlowBottom.onRelease(); &#125; invalidate(0, 0, getWidth(), mEdgeGlowTop.getMaxHeight() + getPaddingTop()); &#125; else if (rawDeltaY &lt; 0) &#123; mEdgeGlowBottom.onPull((float) overScrollDistance / getHeight(), 1.f - (float) x / getWidth()); if (!mEdgeGlowTop.isFinished()) &#123; mEdgeGlowTop.onRelease(); &#125; invalidate(0, getHeight() - getPaddingBottom() - mEdgeGlowBottom.getMaxHeight(), getWidth(), getHeight()); &#125; &#125; &#125; if (incrementalDeltaY != 0) &#123; // Coming back to 'real' list scrolling if (mScrollY != 0) &#123; mScrollY = 0; invalidateParentIfNeeded(); &#125; // 继续处理着 trackMotionScroll(incrementalDeltaY, incrementalDeltaY); mTouchMode = TOUCH_MODE_SCROLL; // We did not scroll the full amount. Treat this essentially like the // start of a new touch scroll final int motionPosition = findClosestMotionRow(y); mMotionCorrection = 0; View motionView = getChildAt(motionPosition - mFirstPosition); mMotionViewOriginalTop = motionView != null ? motionView.getTop() : 0; mMotionY = y + scrollOffsetCorrection; mMotionPosition = motionPosition; &#125; mLastY = y + lastYCorrection + scrollOffsetCorrection; mDirection = newDirection; &#125; &#125;&#125; 这部分代码逻辑牵扯太多，有点晕呼呼的，记着看一下trackMotionScroll()方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/** * Track a motion scroll * * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion * began. Positive numbers mean the user's finger is moving down the screen. * @param incrementalDeltaY Change in deltaY from the previous event. 通过它的正负来判断是向上还是向下。 * @return true if we're already at the beginning/end of the list and have nothing to do. */boolean trackMotionScroll(int deltaY, int incrementalDeltaY) &#123; final int childCount = getChildCount(); if (childCount == 0) &#123; return true; &#125; final int firstTop = getChildAt(0).getTop(); final int lastBottom = getChildAt(childCount - 1).getBottom(); final Rect listPadding = mListPadding; // \"effective padding\" In this case is the amount of padding that affects // how much space should not be filled by items. If we don't clip to padding // there is no effective padding. int effectivePaddingTop = 0; int effectivePaddingBottom = 0; if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; effectivePaddingTop = listPadding.top; effectivePaddingBottom = listPadding.bottom; &#125; // FIXME account for grid vertical spacing too? final int spaceAbove = effectivePaddingTop - firstTop; final int end = getHeight() - effectivePaddingBottom; final int spaceBelow = lastBottom - end; final int height = getHeight() - mPaddingBottom - mPaddingTop; if (deltaY &lt; 0) &#123; deltaY = Math.max(-(height - 1), deltaY); &#125; else &#123; deltaY = Math.min(height - 1, deltaY); &#125; if (incrementalDeltaY &lt; 0) &#123; incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY); &#125; else &#123; incrementalDeltaY = Math.min(height - 1, incrementalDeltaY); &#125; final int firstPosition = mFirstPosition; // Update our guesses for where the first and last views are if (firstPosition == 0) &#123; mFirstPositionDistanceGuess = firstTop - listPadding.top; &#125; else &#123; mFirstPositionDistanceGuess += incrementalDeltaY; &#125; if (firstPosition + childCount == mItemCount) &#123; mLastPositionDistanceGuess = lastBottom + listPadding.bottom; &#125; else &#123; mLastPositionDistanceGuess += incrementalDeltaY; &#125; final boolean cannotScrollDown = (firstPosition == 0 &amp;&amp; firstTop &gt;= listPadding.top &amp;&amp; incrementalDeltaY &gt;= 0); final boolean cannotScrollUp = (firstPosition + childCount == mItemCount &amp;&amp; lastBottom &lt;= getHeight() - listPadding.bottom &amp;&amp; incrementalDeltaY &lt;= 0); if (cannotScrollDown || cannotScrollUp) &#123; return incrementalDeltaY != 0; &#125; // 判断向上还是向下 final boolean down = incrementalDeltaY &lt; 0; final boolean inTouchMode = isInTouchMode(); if (inTouchMode) &#123; hideSelector(); &#125; final int headerViewsCount = getHeaderViewsCount(); final int footerViewsStart = mItemCount - getFooterViewsCount(); int start = 0; int count = 0; if (down) &#123; int top = -incrementalDeltaY; if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; top += listPadding.top; &#125; for (int i = 0; i &lt; childCount; i++) &#123; final View child = getChildAt(i); if (child.getBottom() &gt;= top) &#123; break; &#125; else &#123; // 如果这个View的底部位置已经小于top值了，说明这个view已经移除屏幕了，不可见了 count++; int position = firstPosition + i; if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123; // The view will be rebound to new data, clear any // system-managed transient state. child.clearAccessibilityFocus(); // 只要该view移除屏幕就把该view添加到废弃的缓存中 mRecycler.addScrapView(child, position); &#125; &#125; &#125; &#125; else &#123; int bottom = getHeight() - incrementalDeltaY; if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; bottom -= listPadding.bottom; &#125; for (int i = childCount - 1; i &gt;= 0; i--) &#123; final View child = getChildAt(i); if (child.getTop() &lt;= bottom) &#123; break; &#125; else &#123; start = i; count++; int position = firstPosition + i; if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123; // The view will be rebound to new data, clear any // system-managed transient state. child.clearAccessibilityFocus(); mRecycler.addScrapView(child, position); &#125; &#125; &#125; &#125; mMotionViewNewTop = mMotionViewOriginalTop + deltaY; mBlockLayoutRequests = true; // count记录了当前已经移除屏幕的view个数 if (count &gt; 0) &#123; // 把已经移除的View从ViewGroup总detach掉 detachViewsFromParent(start, count); mRecycler.removeSkippedScrap(); &#125; // invalidate before moving the children to avoid unnecessary invalidate // calls to bubble up from the children all the way to the top if (!awakenScrollBars()) &#123; invalidate(); &#125; // 这个方法让所有的子view都按照这个参数的距离大小进行改变，这样就实现了移动也就是滑动的功能。 offsetChildrenTopAndBottom(incrementalDeltaY); if (down) &#123; mFirstPosition += count; &#125; final int absIncrementalDeltaY = Math.abs(incrementalDeltaY); if (spaceAbove &lt; absIncrementalDeltaY || spaceBelow &lt; absIncrementalDeltaY) &#123; // 第一个View的顶部移入了屏幕或者最后一个View的底部移入了屏幕 fillGap(down); &#125; if (!inTouchMode &amp;&amp; mSelectedPosition != INVALID_POSITION) &#123; final int childIndex = mSelectedPosition - mFirstPosition; if (childIndex &gt;= 0 &amp;&amp; childIndex &lt; getChildCount()) &#123; positionSelector(mSelectedPosition, getChildAt(childIndex)); &#125; &#125; else if (mSelectorPosition != INVALID_POSITION) &#123; final int childIndex = mSelectorPosition - mFirstPosition; if (childIndex &gt;= 0 &amp;&amp; childIndex &lt; getChildCount()) &#123; positionSelector(INVALID_POSITION, getChildAt(childIndex)); &#125; &#125; else &#123; mSelectorRect.setEmpty(); &#125; mBlockLayoutRequests = false; invokeOnItemScrollListener(); return false;&#125; 继续看一下offsetChildrenTopAndBottom()方法的，在AbsListView中没有重写该方法，具体要看其父类ViewGroup中的实现: `12345678910111213141516171819202122232425262728/** * Offset the vertical location of all children of this view by the specified number of pixels. * * @param offset the number of pixels to offset * * @hide */public void offsetChildrenTopAndBottom(int offset) &#123; final int count = mChildrenCount; final View[] children = mChildren; boolean invalidate = false; for (int i = 0; i &lt; count; i++) &#123; // 把所有的view都移动指定的距离 final View v = children[i]; v.mTop += offset; v.mBottom += offset; if (v.mRenderNode != null) &#123; invalidate = true; v.mRenderNode.offsetTopAndBottom(offset); &#125; &#125; if (invalidate) &#123; invalidateViewProperty(false, false); &#125; notifySubtreeAccessibilityStateChangedIfNeeded();&#125; 再看一下fillGap()方法的实现:123456789/** * Fills the gap left open by a touch-scroll. During a touch scroll, children that * remain on screen are shifted and the other ones are discarded. The role of this * method is to fill the gap thus created by performing a partial layout in the * empty space. * * @param down true if the scroll is going down, false if it is going up */abstract void fillGap(boolean down); 发现在AbsListView中该方法是抽象的，所以我们要再ListView中找一下他的具体实现类:1234567891011121314151617181920212223242526/** * &#123;@inheritDoc&#125; */@Overridevoid fillGap(boolean down) &#123; final int count = getChildCount(); if (down) &#123; int paddingTop = 0; if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; paddingTop = getListPaddingTop(); &#125; final int startOffset = count &gt; 0 ? getChildAt(count - 1).getBottom() + mDividerHeight : paddingTop; fillDown(mFirstPosition + count, startOffset); correctTooHigh(getChildCount()); &#125; else &#123; int paddingBottom = 0; if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; paddingBottom = getListPaddingBottom(); &#125; final int startOffset = count &gt; 0 ? getChildAt(0).getTop() - mDividerHeight : getHeight() - paddingBottom; fillUp(mFirstPosition - 1, startOffset); correctTooLow(getChildCount()); &#125;&#125; 可以看到他会分别根据向下滑动还是向上滑动去调用fillDown和fillUp两个方法，这两个方法之前我们都分析过了，就不再继续看了。 到这里基本就把滑动部分的处理都看完了。还剩最后一个问题就是RecycleBin的实现,他是AbsListView中的一个内部类。 直接上代码了，他的注释也说的非常清楚，我就把不好理解的地方简单说一下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503/** * The RecycleBin facilitates reuse of views across layouts. The RecycleBin has two levels of * storage: ActiveViews and ScrapViews. ActiveViews are those views which were onscreen at the * start of a layout. By construction, they are displaying current information. At the end of * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews are old views that * could potentially be used by the adapter to avoid allocating views unnecessarily. * * @see android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener) * @see android.widget.AbsListView.RecyclerListener */class RecycleBin &#123; private RecyclerListener mRecyclerListener; /** * The position of the first view stored in mActiveViews. */ private int mFirstActivePosition; /** * Views that were on screen at the start of layout. This array is populated at the start of * layout, and at the end of layout all view in mActiveViews are moved to mScrapViews. * Views in mActiveViews represent a contiguous range of Views, with position of the first * view store in mFirstActivePosition. */ private View[] mActiveViews = new View[0]; /** * 为什么是个数组呢？因为ListView会有多种不同的ViewType啊。 * Unsorted views that can be used by the adapter as a convert view. */ private ArrayList&lt;View&gt;[] mScrapViews; private int mViewTypeCount; // mScrapViews数组中的第一个元素，方便在ViewType是1的时候使用 private ArrayList&lt;View&gt; mCurrentScrap; private ArrayList&lt;View&gt; mSkippedScrap; private SparseArray&lt;View&gt; mTransientStateViews; private LongSparseArray&lt;View&gt; mTransientStateViewsById; public void setViewTypeCount(int viewTypeCount) &#123; if (viewTypeCount &lt; 1) &#123; throw new IllegalArgumentException(\"Can't have a viewTypeCount &lt; 1\"); &#125; // 根据ViewType的数量来创建，因为ViewType可以有多中类型，每种不同类型的View肯定要分开单独进行缓存和复用的。 //noinspection unchecked ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount]; for (int i = 0; i &lt; viewTypeCount; i++) &#123; scrapViews[i] = new ArrayList&lt;View&gt;(); &#125; mViewTypeCount = viewTypeCount; mCurrentScrap = scrapViews[0]; mScrapViews = scrapViews; &#125; // 方法名说明了一切 public void markChildrenDirty() &#123; if (mViewTypeCount == 1) &#123; final ArrayList&lt;View&gt; scrap = mCurrentScrap; final int scrapCount = scrap.size(); for (int i = 0; i &lt; scrapCount; i++) &#123; scrap.get(i).forceLayout(); &#125; &#125; else &#123; final int typeCount = mViewTypeCount; for (int i = 0; i &lt; typeCount; i++) &#123; final ArrayList&lt;View&gt; scrap = mScrapViews[i]; final int scrapCount = scrap.size(); for (int j = 0; j &lt; scrapCount; j++) &#123; scrap.get(j).forceLayout(); &#125; &#125; &#125; if (mTransientStateViews != null) &#123; final int count = mTransientStateViews.size(); for (int i = 0; i &lt; count; i++) &#123; mTransientStateViews.valueAt(i).forceLayout(); &#125; &#125; if (mTransientStateViewsById != null) &#123; final int count = mTransientStateViewsById.size(); for (int i = 0; i &lt; count; i++) &#123; mTransientStateViewsById.valueAt(i).forceLayout(); &#125; &#125; &#125; public boolean shouldRecycleViewType(int viewType) &#123; return viewType &gt;= 0; &#125; /** * Clears the scrap heap. */ void clear() &#123; if (mViewTypeCount == 1) &#123; final ArrayList&lt;View&gt; scrap = mCurrentScrap; clearScrap(scrap); &#125; else &#123; final int typeCount = mViewTypeCount; for (int i = 0; i &lt; typeCount; i++) &#123; final ArrayList&lt;View&gt; scrap = mScrapViews[i]; clearScrap(scrap); &#125; &#125; clearTransientStateViews(); &#125; /** * Fill ActiveViews with all of the children of the AbsListView. * 将View存储到mActiveViews数组中 * @param childCount The minimum number of views mActiveViews should hold * @param firstActivePosition The position of the first view that will be stored in * mActiveViews */ void fillActiveViews(int childCount, int firstActivePosition) &#123; if (mActiveViews.length &lt; childCount) &#123; mActiveViews = new View[childCount]; &#125; mFirstActivePosition = firstActivePosition; //noinspection MismatchedReadAndWriteOfArray final View[] activeViews = mActiveViews; for (int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams(); // Don't put header or footer views into the scrap heap if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123; // Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views. // However, we will NOT place them into scrap views. activeViews[i] = child; // Remember the position so that setupChild() doesn't reset state. lp.scrappedFromPosition = firstActivePosition + i; &#125; &#125; &#125; /** * Get the view corresponding to the specified position. The view will be removed from * mActiveViews if it is found.注释说了获取完之后就会从mActiveViews中移除，这是很好理解的 * 因为获取了就是说这个View已经显示到当前的ListView中了，肯定不能再复用他了。 * * @param position The position to look up in mActiveViews * @return The view if it is found, null otherwise */ View getActiveView(int position) &#123; int index = position - mFirstActivePosition; final View[] activeViews = mActiveViews; if (index &gt;=0 &amp;&amp; index &lt; activeViews.length) &#123; final View match = activeViews[index]; activeViews[index] = null; return match; &#125; return null; &#125; View getTransientStateView(int position) &#123; if (mAdapter != null &amp;&amp; mAdapterHasStableIds &amp;&amp; mTransientStateViewsById != null) &#123; long id = mAdapter.getItemId(position); View result = mTransientStateViewsById.get(id); mTransientStateViewsById.remove(id); return result; &#125; if (mTransientStateViews != null) &#123; final int index = mTransientStateViews.indexOfKey(position); if (index &gt;= 0) &#123; View result = mTransientStateViews.valueAt(index); mTransientStateViews.removeAt(index); return result; &#125; &#125; return null; &#125; /** * Dumps and fully detaches any currently saved views with transient * state. */ void clearTransientStateViews() &#123; final SparseArray&lt;View&gt; viewsByPos = mTransientStateViews; if (viewsByPos != null) &#123; final int N = viewsByPos.size(); for (int i = 0; i &lt; N; i++) &#123; removeDetachedView(viewsByPos.valueAt(i), false); &#125; viewsByPos.clear(); &#125; final LongSparseArray&lt;View&gt; viewsById = mTransientStateViewsById; if (viewsById != null) &#123; final int N = viewsById.size(); for (int i = 0; i &lt; N; i++) &#123; removeDetachedView(viewsById.valueAt(i), false); &#125; viewsById.clear(); &#125; &#125; /** * 从废弃View的缓存中获取，只要移动出屏幕之后就都会被加到废弃View的缓存中 * @return A view from the ScrapViews collection. These are unordered. */ View getScrapView(int position) &#123; if (mViewTypeCount == 1) &#123; return retrieveFromScrap(mCurrentScrap, position); &#125; else &#123; final int whichScrap = mAdapter.getItemViewType(position); if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) &#123; return retrieveFromScrap(mScrapViews[whichScrap], position); &#125; &#125; return null; &#125; /** * Puts a view into the list of scrap views. * &lt;p&gt; * If the list data hasn't changed or the adapter has stable IDs, views * with transient state will be preserved for later retrieval. * * @param scrap The view to add * @param position The view's position within its parent */ void addScrapView(View scrap, int position) &#123; final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams(); if (lp == null) &#123; return; &#125; lp.scrappedFromPosition = position; // Remove but don't scrap header or footer views, or views that // should otherwise not be recycled. final int viewType = lp.viewType; if (!shouldRecycleViewType(viewType)) &#123; return; &#125; scrap.dispatchStartTemporaryDetach(); // The the accessibility state of the view may change while temporary // detached and we do not allow detached views to fire accessibility // events. So we are announcing that the subtree changed giving a chance // to clients holding on to a view in this subtree to refresh it. notifyViewAccessibilityStateChangedIfNeeded( AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE); // 对一些瞬态View的处理 // Don't scrap views that have transient state. final boolean scrapHasTransientState = scrap.hasTransientState(); if (scrapHasTransientState) &#123; if (mAdapter != null &amp;&amp; mAdapterHasStableIds) &#123; // If the adapter has stable IDs, we can reuse the view for // the same data. if (mTransientStateViewsById == null) &#123; mTransientStateViewsById = new LongSparseArray&lt;View&gt;(); &#125; mTransientStateViewsById.put(lp.itemId, scrap); &#125; else if (!mDataChanged) &#123; // If the data hasn't changed, we can reuse the views at // their old positions. if (mTransientStateViews == null) &#123; mTransientStateViews = new SparseArray&lt;View&gt;(); &#125; mTransientStateViews.put(position, scrap); &#125; else &#123; // Otherwise, we'll have to remove the view and start over. if (mSkippedScrap == null) &#123; mSkippedScrap = new ArrayList&lt;View&gt;(); &#125; mSkippedScrap.add(scrap); &#125; &#125; else &#123; if (mViewTypeCount == 1) &#123; mCurrentScrap.add(scrap); &#125; else &#123; mScrapViews[viewType].add(scrap); &#125; if (mRecyclerListener != null) &#123; mRecyclerListener.onMovedToScrapHeap(scrap); &#125; &#125; &#125; /** * Finish the removal of any views that skipped the scrap heap. */ void removeSkippedScrap() &#123; if (mSkippedScrap == null) &#123; return; &#125; final int count = mSkippedScrap.size(); for (int i = 0; i &lt; count; i++) &#123; removeDetachedView(mSkippedScrap.get(i), false); &#125; mSkippedScrap.clear(); &#125; /** * Move all views remaining in mActiveViews to mScrapViews. */ void scrapActiveViews() &#123; final View[] activeViews = mActiveViews; final boolean hasListener = mRecyclerListener != null; final boolean multipleScraps = mViewTypeCount &gt; 1; ArrayList&lt;View&gt; scrapViews = mCurrentScrap; final int count = activeViews.length; for (int i = count - 1; i &gt;= 0; i--) &#123; final View victim = activeViews[i]; if (victim != null) &#123; final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) victim.getLayoutParams(); final int whichScrap = lp.viewType; activeViews[i] = null; if (victim.hasTransientState()) &#123; // Store views with transient state for later use. victim.dispatchStartTemporaryDetach(); if (mAdapter != null &amp;&amp; mAdapterHasStableIds) &#123; if (mTransientStateViewsById == null) &#123; mTransientStateViewsById = new LongSparseArray&lt;View&gt;(); &#125; long id = mAdapter.getItemId(mFirstActivePosition + i); mTransientStateViewsById.put(id, victim); &#125; else if (!mDataChanged) &#123; if (mTransientStateViews == null) &#123; mTransientStateViews = new SparseArray&lt;View&gt;(); &#125; mTransientStateViews.put(mFirstActivePosition + i, victim); &#125; else if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123; // The data has changed, we can't keep this view. removeDetachedView(victim, false); &#125; &#125; else if (!shouldRecycleViewType(whichScrap)) &#123; // Discard non-recyclable views except headers/footers. if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123; removeDetachedView(victim, false); &#125; &#125; else &#123; // Store everything else on the appropriate scrap heap. if (multipleScraps) &#123; scrapViews = mScrapViews[whichScrap]; &#125; victim.dispatchStartTemporaryDetach(); lp.scrappedFromPosition = mFirstActivePosition + i; scrapViews.add(victim); if (hasListener) &#123; mRecyclerListener.onMovedToScrapHeap(victim); &#125; &#125; &#125; &#125; pruneScrapViews(); &#125; /** * Makes sure that the size of mScrapViews does not exceed the size of * mActiveViews, which can happen if an adapter does not recycle its * views. Removes cached transient state views that no longer have * transient state. */ private void pruneScrapViews() &#123; final int maxViews = mActiveViews.length; final int viewTypeCount = mViewTypeCount; final ArrayList&lt;View&gt;[] scrapViews = mScrapViews; for (int i = 0; i &lt; viewTypeCount; ++i) &#123; final ArrayList&lt;View&gt; scrapPile = scrapViews[i]; int size = scrapPile.size(); final int extras = size - maxViews; size--; for (int j = 0; j &lt; extras; j++) &#123; removeDetachedView(scrapPile.remove(size--), false); &#125; &#125; final SparseArray&lt;View&gt; transViewsByPos = mTransientStateViews; if (transViewsByPos != null) &#123; for (int i = 0; i &lt; transViewsByPos.size(); i++) &#123; final View v = transViewsByPos.valueAt(i); if (!v.hasTransientState()) &#123; removeDetachedView(v, false); transViewsByPos.removeAt(i); i--; &#125; &#125; &#125; final LongSparseArray&lt;View&gt; transViewsById = mTransientStateViewsById; if (transViewsById != null) &#123; for (int i = 0; i &lt; transViewsById.size(); i++) &#123; final View v = transViewsById.valueAt(i); if (!v.hasTransientState()) &#123; removeDetachedView(v, false); transViewsById.removeAt(i); i--; &#125; &#125; &#125; &#125; /** * Puts all views in the scrap heap into the supplied list. */ void reclaimScrapViews(List&lt;View&gt; views) &#123; if (mViewTypeCount == 1) &#123; views.addAll(mCurrentScrap); &#125; else &#123; final int viewTypeCount = mViewTypeCount; final ArrayList&lt;View&gt;[] scrapViews = mScrapViews; for (int i = 0; i &lt; viewTypeCount; ++i) &#123; final ArrayList&lt;View&gt; scrapPile = scrapViews[i]; views.addAll(scrapPile); &#125; &#125; &#125; /** * Updates the cache color hint of all known views. * * @param color The new cache color hint. */ void setCacheColorHint(int color) &#123; if (mViewTypeCount == 1) &#123; final ArrayList&lt;View&gt; scrap = mCurrentScrap; final int scrapCount = scrap.size(); for (int i = 0; i &lt; scrapCount; i++) &#123; scrap.get(i).setDrawingCacheBackgroundColor(color); &#125; &#125; else &#123; final int typeCount = mViewTypeCount; for (int i = 0; i &lt; typeCount; i++) &#123; final ArrayList&lt;View&gt; scrap = mScrapViews[i]; final int scrapCount = scrap.size(); for (int j = 0; j &lt; scrapCount; j++) &#123; scrap.get(j).setDrawingCacheBackgroundColor(color); &#125; &#125; &#125; // Just in case this is called during a layout pass final View[] activeViews = mActiveViews; final int count = activeViews.length; for (int i = 0; i &lt; count; ++i) &#123; final View victim = activeViews[i]; if (victim != null) &#123; victim.setDrawingCacheBackgroundColor(color); &#125; &#125; &#125; private View retrieveFromScrap(ArrayList&lt;View&gt; scrapViews, int position) &#123; final int size = scrapViews.size(); if (size &gt; 0) &#123; // See if we still have a view for this position or ID. for (int i = 0; i &lt; size; i++) &#123; final View view = scrapViews.get(i); final AbsListView.LayoutParams params = (AbsListView.LayoutParams) view.getLayoutParams(); if (mAdapterHasStableIds) &#123; final long id = mAdapter.getItemId(position); if (id == params.itemId) &#123; return scrapViews.remove(i); &#125; &#125; else if (params.scrappedFromPosition == position) &#123; final View scrap = scrapViews.remove(i); clearAccessibilityFromScrap(scrap); return scrap; &#125; &#125; final View scrap = scrapViews.remove(size - 1); clearAccessibilityFromScrap(scrap); return scrap; &#125; else &#123; return null; &#125; &#125; private void clearScrap(final ArrayList&lt;View&gt; scrap) &#123; final int scrapCount = scrap.size(); for (int j = 0; j &lt; scrapCount; j++) &#123; removeDetachedView(scrap.remove(scrapCount - 1 - j), false); &#125; &#125; private void clearAccessibilityFromScrap(View view) &#123; view.clearAccessibilityFocus(); view.setAccessibilityDelegate(null); &#125; private void removeDetachedView(View child, boolean animate) &#123; child.setAccessibilityDelegate(null); AbsListView.this.removeDetachedView(child, animate); &#125;&#125; 到此为止。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Activity启动过程","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Activity启动过程/","text":"Activity启动过程前两天面试了天猫的开发，被问到了Activity启动过程，不懂啊….今天就来分析一下，我们开启Activity主要有两种方式: 通过桌面图标启动，桌面就是Launcher其实他也是一个应用程序，他也是继承Activity。 在程序内部调用startActivity()开启。 而Launcher点击图标其实也是调用了Activity的startActivity()方法，所以我们就从startActivity()方法入手了。首先看一下Activity类中的startActivity()方法:1234@Overridepublic void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125; 继续看startActivity(intent, null):1234567891011121314151617181920212223242526272829303132/** * Launch a new activity. You will not receive any information about when * the activity exits. This implementation overrides the base version, * providing information about * the activity performing the launch. Because of this additional * information, the &#123;@link Intent#FLAG_ACTIVITY_NEW_TASK&#125; launch flag is not * required; if not specified, the new activity will be added to the * task of the caller. * * &lt;p&gt;This method throws &#123;@link android.content.ActivityNotFoundException&#125; * if there was no Activity found to run the given Intent. * * @param intent The intent to start. * @param options Additional options for how the Activity should be started. * See &#123;@link android.content.Context#startActivity(Intent, Bundle) * Context.startActivity(Intent, Bundle)&#125; for more details. * * @throws android.content.ActivityNotFoundException * * @see &#123;@link #startActivity(Intent)&#125; * @see #startActivityForResult */@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125; 接下来会调用startActivityForResult()方法(注释也很重要啊，里面也说明了singleTask启动模式时该方法不会走到回调中):12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Launch an activity for which you would like a result when it finished. * When this activity exits, your * onActivityResult() method will be called with the given requestCode. * Using a negative requestCode is the same as calling * &#123;@link #startActivity&#125; (the activity is not launched as a sub-activity). * * &lt;p&gt;Note that this method should only be used with Intent protocols * that are defined to return a result. In other protocols (such as * &#123;@link Intent#ACTION_MAIN&#125; or &#123;@link Intent#ACTION_VIEW&#125;), you may * not get the result when you expect. For example, if the activity you * are launching uses the singleTask launch mode, it will not run in your * task and thus you will immediately receive a cancel result. * * &lt;p&gt;As a special case, if you call startActivityForResult() with a requestCode * &gt;= 0 during the initial onCreate(Bundle savedInstanceState)/onResume() of your * activity, then your window will not be displayed until a result is * returned back from the started activity. This is to avoid visible * flickering when redirecting to another activity. * * &lt;p&gt;This method throws &#123;@link android.content.ActivityNotFoundException&#125; * if there was no Activity found to run the given Intent. * * @param intent The intent to start. * @param requestCode If &gt;= 0, this code will be returned in * onActivityResult() when the activity exits. * @param options Additional options for how the Activity should be started. * See &#123;@link android.content.Context#startActivity(Intent, Bundle) * Context.startActivity(Intent, Bundle)&#125; for more details. * * @throws android.content.ActivityNotFoundException * * @see #startActivity */public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; // mParent也是Activity类，通过名字就能看明白了。 if (mParent == null) &#123; // 开始了啊 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125;&#125; 里面调用了mInstrumentation.execStartActivity这是啥玩意，先看一下mInstrumentation属性，他是Instrumentation类，我们看下文档1234567891011/** * Base class for implementing application instrumentation code. When running * with instrumentation turned on, this class will be instantiated for you * before any of the application code, allowing you to monitor all of the * interaction the system has with the application. An Instrumentation * implementation is described to the system through an AndroidManifest.xml's * &amp;lt;instrumentation&amp;gt; tag. */public class Instrumentation &#123; ...&#125; 放狗查了下Instrumentation的意思是仪器、工具、装置的意思。我就大体翻一下(英语不好- -~，可能不准确)该类是实现应用程序代码的基类，当该类在启动的状态下运行时，该类会在其他任何应用程序运行前进行初始化，允许你件事所有应用程序与系统的交互。一个Instrumentation实例会通过Manifest文件中的&lt;instrumenttation标签描述给系统。所以继续看一下mInstrumentation.execStartActivity():1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** // 下面的注释说的很明白了默认实现会更新任何活跃的对象并分发给系统的`activity manager` * Execute a startActivity call made by the application. The default * implementation takes care of updating any active &#123;@link ActivityMonitor&#125; * objects and dispatches this call to the system activity manager; you can * override this to watch for the application to start an activity, and * modify what happens when it does. * * &lt;p&gt;This method returns an &#123;@link ActivityResult&#125; object, which you can * use when intercepting application calls to avoid performing the start * activity action but still return the result the application is * expecting. To do this, override this method to catch the call to start * activity so that it returns a new ActivityResult containing the results * you would like the application to see, and don't call up to the super * class. Note that an application is only expecting a result if * &lt;var&gt;requestCode&lt;/var&gt; is &amp;gt;= 0. * * &lt;p&gt;This method throws &#123;@link android.content.ActivityNotFoundException&#125; * if there was no Activity found to run the given Intent. * * @param who The Context from which the activity is being started. * @param contextThread The main thread of the Context from which the activity * is being started. * @param token Internal token identifying to the system who is starting * the activity; may be null. * @param target Which activity is performing the start (and thus receiving * any result); may be null if this call is not being made * from an activity. * @param intent The actual Intent to start. * @param requestCode Identifier for this request's result; less than zero * if the caller is not expecting a result. * @param options Addition options. * * @return To force the return of a particular result, return an * ActivityResult object containing the desired data; otherwise * return null. The default implementation always returns null. * * @throws android.content.ActivityNotFoundException * * @see Activity#startActivity(Intent) * @see Activity#startActivityForResult(Intent, int) * @see Activity#startActivityFromChild * * &#123;@hide&#125; */public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); // 通过注释然后再结合代码一看我们就知道这应该就是分发到系统activity manager的过程 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 那就直接看下ActivityManagerNative.getDefault().startActivity()方法，看之前我们先看看ActivityManagerNative.getDefault()是什么鬼:123456/** * Retrieve the system's default/global activity manager. */static public IActivityManager getDefault() &#123; return gDefault.get();&#125; 注释说的明白的就是拿到系统默认/全局的activity manager，通过名字也能看出来IActivityManager是个接口，那就继续看IActivityManager.startActivity()方法吧:123public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException; 这里就顺便看一下IActivityManager接口是神马鬼：123456789/** * System private API for talking with the activity manager service. This * provides calls from the application back to the activity manager. * * &#123;@hide&#125; */public interface IActivityManager extends IInterface &#123; ...&#125; 但是看到这里我不知道怎么继续往下分析了啊，既然是接口我们要找到实现类啊，又是通过ActivityManagerNative.getDefault()得到的IActivityManager实例，所以这里我们再看下ActivityManagerNative类。1234/** &#123;@hide&#125; */public abstract class ActivityManagerNative extends Binder implements IActivityManager &#123; ...&#125; 啊！ 隐藏的，连个注释也没有，我拖动了下这个类一看5992行，不知道从哪下手了，还能从哪下手啊，当然是从ActivityManagerNative.getDefault()方法啊1234567891011121314151617181920212223242526272829public abstract class ActivityManagerNative extends Binder implements IActivityManager &#123; // 继承Binder接口，而且asInterFace方法，我好想明白了点什么 /** * Cast a Binder object into an activity manager interface, generating * a proxy if needed. */ static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj); &#125; /** * Retrieve the system's default/global activity manager. */ static public IActivityManager getDefault() &#123; // 使用了getDefaule的get方法 return gDefault.get(); &#125; ....&#125; 继续看： 123456789101112131415private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; // 进程间通信了 IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; // 看到了吗？用到了刚才我们说的asInterface方法 IActivityManager am = asInterface(b); if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125;&#125;; 好了，我们再看下asInterface()方法: 123456789101112static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; // 在这里 return new ActivityManagerProxy(obj);&#125; 终于找到了其实就是ActivityManagerProxy类，刚才我们找到IActivityManager接口的startActivity() 方法，现在终于找到了在这里使用的是IActivityManager接口实现类的ActivityManagerProxy类，我们来看一下该类实现的startActivity()方法:12345678910111213141516171819202122232425262728293031323334353637383940414243444546class ActivityManagerProxy implements IActivityManager&#123; public ActivityManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public IBinder asBinder() &#123; return mRemote; &#125; public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; if (options != null) &#123; data.writeInt(1); options.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; &#125; ...&#125; 再继续我就不知道走到哪里了….这一块其实是用了Binder机制，上面的IActivityManager.getDefault()方法返回的是ActivityManagerService的远程接口，所以接下来我们应该看一下ActivityManagerService.startActivity()类。(具体Binder机制我们后续会专门写一篇文章，这里就不说了，不然就说不完了)12345678@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125; 继续看下startActivityAsUser()方法:123456789101112@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null);&#125; 继续看一下mStackSupervisor.startActivityMayWait()方法,这里mStackSupervisor是ActivityStackSupervisor类:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors()) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; boolean componentSpecified = intent.getComponent() != null; // Don't modify the client's object! intent = new Intent(intent); // 解析出要开启的Activity的信息，包名、类名、参数等。 // Collect information about the target of the Intent. ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId); ActivityContainer container = (ActivityContainer)iContainer; synchronized (mService) &#123; if (container != null &amp;&amp; container.mParentActivity != null &amp;&amp; container.mParentActivity.state != RESUMED) &#123; // Cannot start a child activity if the parent is not resumed. return ActivityManager.START_CANCELED; &#125; final int realCallingPid = Binder.getCallingPid(); final int realCallingUid = Binder.getCallingUid(); int callingPid; if (callingUid &gt;= 0) &#123; callingPid = -1; &#125; else if (caller == null) &#123; callingPid = realCallingPid; callingUid = realCallingUid; &#125; else &#123; callingPid = callingUid = -1; &#125; final ActivityStack stack; if (container == null || container.mStack.isOnHomeDisplay()) &#123; stack = mFocusedStack; &#125; else &#123; stack = container.mStack; &#125; stack.mConfigWillChange = config != null &amp;&amp; mService.mConfiguration.diff(config) != 0; if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, \"Starting activity when config will change = \" + stack.mConfigWillChange); final long origId = Binder.clearCallingIdentity(); if (aInfo != null &amp;&amp; (aInfo.applicationInfo.privateFlags &amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) &#123; // This may be a heavy-weight process! Check to see if we already // have another, different heavy-weight process running. if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) &#123; if (mService.mHeavyWeightProcess != null &amp;&amp; (mService.mHeavyWeightProcess.info.uid != aInfo.applicationInfo.uid || !mService.mHeavyWeightProcess.processName.equals(aInfo.processName))) &#123; int appCallingUid = callingUid; if (caller != null) &#123; ProcessRecord callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; appCallingUid = callerApp.info.uid; &#125; else &#123; Slog.w(TAG, \"Unable to find app for caller \" + caller + \" (pid=\" + callingPid + \") when starting: \" + intent.toString()); ActivityOptions.abort(options); return ActivityManager.START_PERMISSION_DENIED; &#125; &#125; IIntentSender target = mService.getIntentSenderLocked( ActivityManager.INTENT_SENDER_ACTIVITY, \"android\", appCallingUid, userId, null, null, 0, new Intent[] &#123; intent &#125;, new String[] &#123; resolvedType &#125;, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT, null); Intent newIntent = new Intent(); if (requestCode &gt;= 0) &#123; // Caller is requesting a result. newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, true); &#125; newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT, new IntentSender(target)); if (mService.mHeavyWeightProcess.activities.size() &gt; 0) &#123; ActivityRecord hist = mService.mHeavyWeightProcess.activities.get(0); newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP, hist.packageName); newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK, hist.task.taskId); &#125; newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP, aInfo.packageName); newIntent.setFlags(intent.getFlags()); newIntent.setClassName(\"android\", HeavyWeightSwitcherActivity.class.getName()); intent = newIntent; resolvedType = null; caller = null; callingUid = Binder.getCallingUid(); callingPid = Binder.getCallingPid(); componentSpecified = true; try &#123; ResolveInfo rInfo = AppGlobals.getPackageManager().resolveIntent( intent, null, PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS, userId); aInfo = rInfo != null ? rInfo.activityInfo : null; aInfo = mService.getActivityInfoForUser(aInfo, userId); &#125; catch (RemoteException e) &#123; aInfo = null; &#125; &#125; &#125; &#125; // 根据上面解析的内容去开启了。。。 int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); Binder.restoreCallingIdentity(origId); if (stack.mConfigWillChange) &#123; // If the caller also wants to switch to a new configuration, // do so now. This allows a clean switch, as we are waiting // for the current activity to pause (so we will not destroy // it), and have not yet started the next activity. mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, \"updateConfiguration()\"); stack.mConfigWillChange = false; if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, \"Updating to new configuration after starting activity.\"); mService.updateConfigurationLocked(config, null, false, false); &#125; if (outResult != null) &#123; outResult.result = res; if (res == ActivityManager.START_SUCCESS) &#123; mWaitingActivityLaunched.add(outResult); do &#123; try &#123; mService.wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; while (!outResult.timeout &amp;&amp; outResult.who == null); &#125; else if (res == ActivityManager.START_TASK_TO_FRONT) &#123; ActivityRecord r = stack.topRunningActivityLocked(null); if (r.nowVisible &amp;&amp; r.state == RESUMED) &#123; outResult.timeout = false; outResult.who = new ComponentName(r.info.packageName, r.info.name); outResult.totalTime = 0; outResult.thisTime = 0; &#125; else &#123; outResult.thisTime = SystemClock.uptimeMillis(); mWaitingActivityVisible.add(outResult); do &#123; try &#123; mService.wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; while (!outResult.timeout &amp;&amp; outResult.who == null); &#125; &#125; &#125; return res; &#125;&#125; 那就继续看一下startActivityLocked()方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, Bundle options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; ProcessRecord callerApp = null; if (caller != null) &#123; // mService就是ActivityManagerService类 callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; callingPid = callerApp.pid; callingUid = callerApp.info.uid; &#125; else &#123; Slog.w(TAG, \"Unable to find app for caller \" + caller + \" (pid=\" + callingPid + \") when starting: \" + intent.toString()); err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0; if (err == ActivityManager.START_SUCCESS) &#123; Slog.i(TAG, \"START u\" + userId + \" &#123;\" + intent.toShortString(true, true, true, false) + \"&#125; from uid \" + callingUid + \" on display \" + (container == null ? (mFocusedStack == null ? Display.DEFAULT_DISPLAY : mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId))); &#125; ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; if (resultTo != null) &#123; sourceRecord = isInAnyStackLocked(resultTo); if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, \"Will send result to \" + resultTo + \" \" + sourceRecord); if (sourceRecord != null) &#123; if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; resultRecord = sourceRecord; &#125; &#125; &#125; final int launchFlags = intent.getFlags(); if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; // Transfer the result target from the source activity to the new // one being started, including any failures. if (requestCode &gt;= 0) &#123; ActivityOptions.abort(options); return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT; &#125; resultRecord = sourceRecord.resultTo; if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) &#123; resultRecord = null; &#125; resultWho = sourceRecord.resultWho; requestCode = sourceRecord.requestCode; sourceRecord.resultTo = null; if (resultRecord != null) &#123; resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode); &#125; if (sourceRecord.launchedFromUid == callingUid) &#123; // The new activity is being launched from the same uid as the previous // activity in the flow, and asking to forward its result back to the // previous. In this case the activity is serving as a trampoline between // the two, so we also want to update its launchedFromPackage to be the // same as the previous activity. Note that this is safe, since we know // these two packages come from the same uid; the caller could just as // well have supplied that same package name itself. This specifially // deals with the case of an intent picker/chooser being launched in the app // flow to redirect to an activity picked by the user, where we want the final // activity to consider it to have been launched by the previous app activity. callingPackage = sourceRecord.launchedFromPackage; &#125; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123; // We couldn't find a class that can handle the given Intent. // That's the end of that! err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123; // We couldn't find the specific class specified in the Intent. // Also the end of the line. err = ActivityManager.START_CLASS_NOT_FOUND; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; !isCurrentProfileLocked(userId) &amp;&amp; (aInfo.flags &amp; FLAG_SHOW_FOR_ALL_USERS) == 0) &#123; // Trying to launch a background activity that doesn't show for all users. err = ActivityManager.START_NOT_CURRENT_USER_ACTIVITY; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null &amp;&amp; sourceRecord.task.voiceSession != null) &#123; // If this activity is being launched as part of a voice session, we need // to ensure that it is safe to do so. If the upcoming activity will also // be part of the voice session, we can only launch it if it has explicitly // said it supports the VOICE category, or it is a part of the calling app. if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) &#123; try &#123; intent.addCategory(Intent.CATEGORY_VOICE); if (!AppGlobals.getPackageManager().activitySupportsIntent( intent.getComponent(), intent, resolvedType)) &#123; Slog.w(TAG, \"Activity being started in current voice task does not support voice: \" + intent); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Failure checking voice capabilities\", e); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) &#123; // If the caller is starting a new voice session, just make sure the target // is actually allowing it to run this way. try &#123; if (!AppGlobals.getPackageManager().activitySupportsIntent(intent.getComponent(), intent, resolvedType)) &#123; Slog.w(TAG, \"Activity being started in new voice task does not support: \" + intent); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Failure checking voice capabilities\", e); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; // Activity栈 final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack; if (err != ActivityManager.START_SUCCESS) &#123; if (resultRecord != null) &#123; resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode, Activity.RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return err; &#125; boolean abort = false; final int startAnyPerm = mService.checkPermission( START_ANY_ACTIVITY, callingPid, callingUid); if (startAnyPerm != PERMISSION_GRANTED) &#123; final int componentRestriction = getComponentRestrictionForCallingPackage( aInfo, callingPackage, callingPid, callingUid, ignoreTargetSecurity); final int actionRestriction = getActionRestrictionForCallingPackage( intent.getAction(), callingPackage, callingPid, callingUid); if (componentRestriction == ACTIVITY_RESTRICTION_PERMISSION || actionRestriction == ACTIVITY_RESTRICTION_PERMISSION) &#123; if (resultRecord != null) &#123; resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode, Activity.RESULT_CANCELED, null); &#125; String msg; if (actionRestriction == ACTIVITY_RESTRICTION_PERMISSION) &#123; msg = \"Permission Denial: starting \" + intent.toString() + \" from \" + callerApp + \" (pid=\" + callingPid + \", uid=\" + callingUid + \")\" + \" with revoked permission \" + ACTION_TO_RUNTIME_PERMISSION.get(intent.getAction()); &#125; else if (!aInfo.exported) &#123; msg = \"Permission Denial: starting \" + intent.toString() + \" from \" + callerApp + \" (pid=\" + callingPid + \", uid=\" + callingUid + \")\" + \" not exported from uid \" + aInfo.applicationInfo.uid; &#125; else &#123; msg = \"Permission Denial: starting \" + intent.toString() + \" from \" + callerApp + \" (pid=\" + callingPid + \", uid=\" + callingUid + \")\" + \" requires \" + aInfo.permission; &#125; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; if (actionRestriction == ACTIVITY_RESTRICTION_APPOP) &#123; String message = \"Appop Denial: starting \" + intent.toString() + \" from \" + callerApp + \" (pid=\" + callingPid + \", uid=\" + callingUid + \")\" + \" requires \" + AppOpsManager.permissionToOp( ACTION_TO_RUNTIME_PERMISSION.get(intent.getAction())); Slog.w(TAG, message); abort = true; &#125; else if (componentRestriction == ACTIVITY_RESTRICTION_APPOP) &#123; String message = \"Appop Denial: starting \" + intent.toString() + \" from \" + callerApp + \" (pid=\" + callingPid + \", uid=\" + callingUid + \")\" + \" requires appop \" + AppOpsManager.permissionToOp(aInfo.permission); Slog.w(TAG, message); abort = true; &#125; &#125; abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid, callingPid, resolvedType, aInfo.applicationInfo); if (mService.mController != null) &#123; try &#123; // The Intent we give to the watcher has the extra data // stripped off, since it can contain private information. Intent watchIntent = intent.cloneFilter(); abort |= !mService.mController.activityStarting(watchIntent, aInfo.applicationInfo.packageName); &#125; catch (RemoteException e) &#123; mService.mController = null; &#125; &#125; if (abort) &#123; if (resultRecord != null) &#123; resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode, Activity.RESULT_CANCELED, null); &#125; // We pretend to the caller that it was really started, but // they will just get a cancel result. ActivityOptions.abort(options); return ActivityManager.START_SUCCESS; &#125; // ActivityRecord: An entry in the history stack, representing an activity. ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, this, container, options); if (outActivity != null) &#123; outActivity[0] = r; &#125; if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) &#123; // If the caller didn't specify an explicit time tracker, we want to continue // tracking under any it has. r.appTimeTracker = sourceRecord.appTimeTracker; &#125; final ActivityStack stack = mFocusedStack; if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123; if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, realCallingPid, realCallingUid, \"Activity start\")) &#123; PendingActivityLaunch pal = new PendingActivityLaunch(r, sourceRecord, startFlags, stack); mPendingActivityLaunches.add(pal); ActivityOptions.abort(options); return ActivityManager.START_SWITCHES_CANCELED; &#125; &#125; if (mService.mDidAppSwitch) &#123; // This is the second allowed switch since we stopped switches, // so now just generally allow switches. Use case: user presses // home (switches disabled, switch to home, mDidAppSwitch now true); // user taps a home icon (coming from home so allowed, we hit here // and now allow anyone to switch again). mService.mAppSwitchesAllowedTime = 0; &#125; else &#123; mService.mDidAppSwitch = true; &#125; doPendingActivityLaunchesLocked(false); // 继续调用方法 err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); if (err &lt; 0) &#123; // If someone asked to have the keyguard dismissed on the next // activity start, but we are not actually doing an activity // switch... just dismiss the keyguard now, because we // probably want to see whatever is behind it. notifyActivityDrawnForKeyguard(); &#125; return err;&#125; 再继续看startActivityUncheckedLocked方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447final int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, Bundle options, TaskRecord inTask) &#123; final Intent intent = r.intent; final int callingUid = r.launchedFromUid; // In some flows in to this function, we retrieve the task record and hold on to it // without a lock before calling back in to here... so the task at this point may // not actually be in recents. Check for that, and if it isn't in recents just // consider it invalid. if (inTask != null &amp;&amp; !inTask.inRecents) &#123; Slog.w(TAG, \"Starting activity in task not in recents: \" + inTask); inTask = null; &#125; // 判断不同的启动模式 final boolean launchSingleTop = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP; final boolean launchSingleInstance = r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE; final boolean launchSingleTask = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK; ..... // We may want to try to place the new activity in to an existing task. We always // do this if the target activity is singleTask or singleInstance; we will also do // this if NEW_TASK has been requested, and there is not an additional qualifier telling // us to still place it in a new task: multi task, always doc mode, or being asked to // launch this as a new task behind the current one. if (((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || launchSingleInstance || launchSingleTask) &#123; // If bring to front is requested, and no result is requested and we have not // been given an explicit task to launch in to, and // we can find a task that was started with this same // component, then instead of launching bring that one to the front. if (inTask == null &amp;&amp; r.resultTo == null) &#123; // See if there is a task to bring to the front. If this is // a SINGLE_INSTANCE activity, there can be one and only one // instance of it in the history, and it is always in its own // unique task, so we do a special search. ActivityRecord intentActivity = !launchSingleInstance ? findTaskLocked(r) : findActivityLocked(intent, r.info); if (intentActivity != null) &#123; // When the flags NEW_TASK and CLEAR_TASK are set, then the task gets reused // but still needs to be a lock task mode violation since the task gets // cleared out and the device would otherwise leave the locked task. if (isLockTaskModeViolation(intentActivity.task, (launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) &#123; showLockTaskToast(); Slog.e(TAG, \"startActivityUnchecked: Attempt to violate Lock Task Mode\"); return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; if (r.task == null) &#123; r.task = intentActivity.task; &#125; if (intentActivity.task.intent == null) &#123; // This task was started because of movement of // the activity based on affinity... now that we // are actually launching it, we can assign the // base intent. intentActivity.task.setIntent(r); &#125; targetStack = intentActivity.task.stack; targetStack.mLastPausedActivity = null; // If the target task is not in the front, then we need // to bring it to the front... except... well, with // SINGLE_TASK_LAUNCH it's not entirely clear. We'd like // to have the same behavior as if a new instance was // being started, which means not bringing it to the front // if the caller is not itself in the front. final ActivityStack focusStack = getFocusedStack(); ActivityRecord curTop = (focusStack == null) ? null : focusStack.topRunningNonDelayedActivityLocked(notTop); boolean movedToFront = false; if (curTop != null &amp;&amp; (curTop.task != intentActivity.task || curTop.task != focusStack.topTask())) &#123; r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT); if (sourceRecord == null || (sourceStack.topActivity() != null &amp;&amp; sourceStack.topActivity().task == sourceRecord.task)) &#123; // We really do want to push this one into the user's face, right now. if (launchTaskBehind &amp;&amp; sourceRecord != null) &#123; intentActivity.setTaskToAffiliateWith(sourceRecord.task); &#125; movedHome = true; targetStack.moveTaskToFrontLocked(intentActivity.task, noAnimation, options, r.appTimeTracker, \"bringingFoundTaskToFront\"); movedToFront = true; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123; // Caller wants to appear on home activity. intentActivity.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; options = null; &#125; &#125; if (!movedToFront) &#123; if (DEBUG_TASKS) Slog.d(TAG_TASKS, \"Bring to front target: \" + targetStack + \" from \" + intentActivity); targetStack.moveToFront(\"intentActivityFound\"); &#125; // If the caller has requested that the target task be // reset, then do so. if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r); &#125; if ((startFlags &amp; ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; // We don't need to start a new activity, and // the client said not to do anything if that // is the case, so this is it! And for paranoia, make // sure we have correctly resumed the top activity. if (doResume) &#123; resumeTopActivitiesLocked(targetStack, null, options); // Make sure to notify Keyguard as well if we are not running an app // transition later. if (!movedToFront) &#123; notifyActivityDrawnForKeyguard(); &#125; &#125; else &#123; ActivityOptions.abort(options); &#125; return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) &#123; // The caller has requested to completely replace any // existing task with its new activity. Well that should // not be too hard... reuseTask = intentActivity.task; reuseTask.performClearTaskLocked(); reuseTask.setIntent(r); &#125; else if ((launchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != 0 || launchSingleInstance || launchSingleTask) &#123; // In this situation we want to remove all activities // from the task up to the one being started. In most // cases this means we are resetting the task to its // initial state. ActivityRecord top = intentActivity.task.performClearTaskLocked(r, launchFlags); if (top != null) &#123; if (top.frontOfTask) &#123; // Activity aliases may mean we use different // intents for the top activity, so make sure // the task now has the identity of the new // intent. top.task.setIntent(r); &#125; ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task); top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); &#125; else &#123; // A special case: we need to start the activity because it is not // currently running, and the caller has asked to clear the current // task to have this activity at the top. addingToTask = true; // Now pretend like this activity is being started by the top of its // task, so it is put in the right place. sourceRecord = intentActivity; TaskRecord task = sourceRecord.task; if (task != null &amp;&amp; task.stack == null) &#123; // Target stack got cleared when we all activities were removed // above. Go ahead and reset it. targetStack = computeStackFocus(sourceRecord, false /* newTask */); targetStack.addTask( task, !launchTaskBehind /* toTop */, false /* moving */); &#125; &#125; &#125; else if (r.realActivity.equals(intentActivity.task.realActivity)) &#123; // In this case the top activity on the task is the // same as the one being launched, so we take that // as a request to bring the task to the foreground. // If the top activity in the task is the root // activity, deliver this new intent to it if it // desires. if (((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop) &amp;&amp; intentActivity.realActivity.equals(r.realActivity)) &#123; ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, intentActivity.task); if (intentActivity.frontOfTask) &#123; intentActivity.task.setIntent(r); &#125; intentActivity.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); &#125; else if (!r.intent.filterEquals(intentActivity.task.intent)) &#123; // In this case we are launching the root activity // of the task, but with a different intent. We // should start a new instance on top. addingToTask = true; sourceRecord = intentActivity; &#125; &#125; else if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) &#123; // In this case an activity is being launched in to an // existing task, without resetting that task. This // is typically the situation of launching an activity // from a notification or shortcut. We want to place // the new activity on top of the current task. addingToTask = true; sourceRecord = intentActivity; &#125; else if (!intentActivity.task.rootWasReset) &#123; // In this case we are launching in to an existing task // that has not yet been started from its front door. // The current task has been brought to the front. // Ideally, we'd probably like to place this new task // at the bottom of its stack, but that's a little hard // to do with the current organization of the code so // for now we'll just drop it. intentActivity.task.setIntent(r); &#125; if (!addingToTask &amp;&amp; reuseTask == null) &#123; // We didn't do anything... but it was needed (a.k.a., client // don't use that intent!) And for paranoia, make // sure we have correctly resumed the top activity. if (doResume) &#123; targetStack.resumeTopActivityLocked(null, options); if (!movedToFront) &#123; // Make sure to notify Keyguard as well if we are not running an app // transition later. notifyActivityDrawnForKeyguard(); &#125; &#125; else &#123; ActivityOptions.abort(options); &#125; return ActivityManager.START_TASK_TO_FRONT; &#125; &#125; &#125; &#125; //String uri = r.intent.toURI(); //Intent intent2 = new Intent(uri); //Slog.i(TAG, \"Given intent: \" + r.intent); //Slog.i(TAG, \"URI is: \" + uri); //Slog.i(TAG, \"To intent: \" + intent2); if (r.packageName != null) &#123; // If the activity being launched is the same as the one currently // at the top, then we need to check if it should only be launched // once. ActivityStack topStack = mFocusedStack; ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop); if (top != null &amp;&amp; r.resultTo == null) &#123; if (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123; if (top.app != null &amp;&amp; top.app.thread != null) &#123; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop || launchSingleTask) &#123; ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task); // For paranoia, make sure we have correctly // resumed the top activity. topStack.mLastPausedActivity = null; if (doResume) &#123; resumeTopActivitiesLocked(); &#125; ActivityOptions.abort(options); if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; // We don't need to start a new activity, and // the client said not to do anything if that // is the case, so this is it! return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; &#125; &#125; &#125; else &#123; if (r.resultTo != null &amp;&amp; r.resultTo.task.stack != null) &#123; r.resultTo.task.stack.sendActivityResultLocked(-1, r.resultTo, r.resultWho, r.requestCode, Activity.RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return ActivityManager.START_CLASS_NOT_FOUND; &#125; boolean newTask = false; boolean keepCurTransition = false; TaskRecord taskToAffiliate = launchTaskBehind &amp;&amp; sourceRecord != null ? sourceRecord.task : null; // Should this be considered a new task? if (r.resultTo == null &amp;&amp; inTask == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; newTask = true; targetStack = computeStackFocus(r, newTask); targetStack.moveToFront(\"startingNewTask\"); if (reuseTask == null) &#123; r.setTask(targetStack.createTaskRecord(getNextTaskId(), newTaskInfo != null ? newTaskInfo : r.info, newTaskIntent != null ? newTaskIntent : intent, voiceSession, voiceInteractor, !launchTaskBehind /* toTop */), taskToAffiliate); if (DEBUG_TASKS) Slog.v(TAG_TASKS, \"Starting new activity \" + r + \" in new task \" + r.task); &#125; else &#123; r.setTask(reuseTask, taskToAffiliate); &#125; if (isLockTaskModeViolation(r.task)) &#123; Slog.e(TAG, \"Attempted Lock Task Mode violation r=\" + r); return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; if (!movedHome) &#123; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123; // Caller wants to appear on home activity, so before starting // their own activity we will bring home to the front. r.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; &#125; &#125; else if (sourceRecord != null) &#123; final TaskRecord sourceTask = sourceRecord.task; if (isLockTaskModeViolation(sourceTask)) &#123; Slog.e(TAG, \"Attempted Lock Task Mode violation r=\" + r); return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; targetStack = sourceTask.stack; targetStack.moveToFront(\"sourceStackToFront\"); final TaskRecord topTask = targetStack.topTask(); if (topTask != sourceTask) &#123; targetStack.moveTaskToFrontLocked(sourceTask, noAnimation, options, r.appTimeTracker, \"sourceTaskToFront\"); &#125; if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) &#123; // In this case, we are adding the activity to an existing // task, but the caller has asked to clear that task if the // activity is already running. ActivityRecord top = sourceTask.performClearTaskLocked(r, launchFlags); keepCurTransition = true; if (top != null) &#123; ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task); top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); // For paranoia, make sure we have correctly // resumed the top activity. targetStack.mLastPausedActivity = null; if (doResume) &#123; targetStack.resumeTopActivityLocked(null); &#125; ActivityOptions.abort(options); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; else if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) &#123; // In this case, we are launching an activity in our own task // that may already be running somewhere in the history, and // we want to shuffle it to the front of the stack if so. final ActivityRecord top = sourceTask.findActivityInHistoryLocked(r); if (top != null) &#123; final TaskRecord task = top.task; task.moveActivityToFrontLocked(top); ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, task); top.updateOptionsLocked(options); top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); targetStack.mLastPausedActivity = null; if (doResume) &#123; targetStack.resumeTopActivityLocked(null); &#125; return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; // An existing activity is starting this new activity, so we want // to keep the new one in the same task as the one that is starting // it. r.setTask(sourceTask, null); if (DEBUG_TASKS) Slog.v(TAG_TASKS, \"Starting new activity \" + r + \" in existing task \" + r.task + \" from source \" + sourceRecord); &#125; else if (inTask != null) &#123; // The caller is asking that the new activity be started in an explicit // task it has provided to us. if (isLockTaskModeViolation(inTask)) &#123; Slog.e(TAG, \"Attempted Lock Task Mode violation r=\" + r); return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; targetStack = inTask.stack; targetStack.moveTaskToFrontLocked(inTask, noAnimation, options, r.appTimeTracker, \"inTaskToFront\"); // Check whether we should actually launch the new activity in to the task, // or just reuse the current activity on top. ActivityRecord top = inTask.getTopActivity(); if (top != null &amp;&amp; top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop || launchSingleTask) &#123; ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task); if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; // We don't need to start a new activity, and // the client said not to do anything if that // is the case, so this is it! return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; if (!addingToTask) &#123; // We don't actually want to have this activity added to the task, so just // stop here but still tell the caller that we consumed the intent. ActivityOptions.abort(options); return ActivityManager.START_TASK_TO_FRONT; &#125; r.setTask(inTask, null); if (DEBUG_TASKS) Slog.v(TAG_TASKS, \"Starting new activity \" + r + \" in explicit task \" + r.task); &#125; else &#123; // This not being started from an existing activity, and not part // of a new task... just put it in the top task, though these days // this case should never happen. targetStack = computeStackFocus(r, newTask); targetStack.moveToFront(\"addingToTopTask\"); ActivityRecord prev = targetStack.topActivity(); r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(), r.info, intent, null, null, true), null); mWindowManager.moveTaskToTop(r.task.taskId); if (DEBUG_TASKS) Slog.v(TAG_TASKS, \"Starting new activity \" + r + \" in new guessed \" + r.task); &#125; mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName, intent, r.getUriPermissionsLocked(), r.userId); if (sourceRecord != null &amp;&amp; sourceRecord.isRecentsActivity()) &#123; r.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE); &#125; if (newTask) &#123; EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.userId, r.task.taskId); &#125; ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task); targetStack.mLastPausedActivity = null; // 上面这部分代码很多，各种启动模式、栈的处理啊，我们就不继续看了，接着看下面的启动。 targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); if (!launchTaskBehind) &#123; // Don't set focus on an activity that's going to the back. mService.setFocusedActivityLocked(r, \"startedActivity\"); &#125; return ActivityManager.START_SUCCESS;&#125; 继续看targetStack.startActivityLocked()方法,这里targetStack就是ActivityStack类:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) &#123; TaskRecord rTask = r.task; final int taskId = rTask.taskId; // mLaunchTaskBehind tasks get placed at the back of the task stack. if (!r.mLaunchTaskBehind &amp;&amp; (taskForIdLocked(taskId) == null || newTask)) &#123; // Last activity in task had been removed or ActivityManagerService is reusing task. // Insert or replace. // Might not even be in. insertTaskAtTop(rTask, r); mWindowManager.moveTaskToTop(taskId); &#125; TaskRecord task = null; if (!newTask) &#123; // If starting in an existing task, find where that is... boolean startIt = true; for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; task = mTaskHistory.get(taskNdx); if (task.getTopActivity() == null) &#123; // All activities in task are finishing. continue; &#125; if (task == r.task) &#123; // Here it is! Now, if this is not yet visible to the // user, then just add it without starting; it will // get started when the user navigates back to it. if (!startIt) &#123; if (DEBUG_ADD_REMOVE) Slog.i(TAG, \"Adding activity \" + r + \" to task \" + task, new RuntimeException(\"here\").fillInStackTrace()); task.addActivityToTop(r); r.putInHistory(); mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); if (VALIDATE_TOKENS) &#123; validateAppTokensLocked(); &#125; ActivityOptions.abort(options); return; &#125; break; &#125; else if (task.numFullscreen &gt; 0) &#123; startIt = false; &#125; &#125; &#125; // Place a new activity at top of stack, so it is next to interact // with the user. // If we are not placing the new activity frontmost, we do not want // to deliver the onUserLeaving callback to the actual frontmost // activity if (task == r.task &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) &#123; mStackSupervisor.mUserLeaving = false; if (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING, \"startActivity() behind front, mUserLeaving=false\"); &#125; task = r.task; // Slot the activity into the history stack and proceed if (DEBUG_ADD_REMOVE) Slog.i(TAG, \"Adding activity \" + r + \" to stack to task \" + task, new RuntimeException(\"here\").fillInStackTrace()); task.addActivityToTop(r); task.setFrontOfTask(); r.putInHistory(); if (!isHomeStack() || numActivities() &gt; 0) &#123; // We want to show the starting preview window if we are // switching to a new task, or the next activity's process is // not currently running. boolean showStartingIcon = newTask; ProcessRecord proc = r.app; if (proc == null) &#123; proc = mService.mProcessNames.get(r.processName, r.info.applicationInfo.uid); &#125; if (proc == null || proc.thread == null) &#123; showStartingIcon = true; &#125; if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION, \"Prepare open transition: starting \" + r); if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) &#123; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, keepCurTransition); mNoAnimActivities.add(r); &#125; else &#123; mWindowManager.prepareAppTransition(newTask ? r.mLaunchTaskBehind ? AppTransition.TRANSIT_TASK_OPEN_BEHIND : AppTransition.TRANSIT_TASK_OPEN : AppTransition.TRANSIT_ACTIVITY_OPEN, keepCurTransition); mNoAnimActivities.remove(r); &#125; mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); boolean doShow = true; if (newTask) &#123; // Even though this activity is starting fresh, we still need // to reset it to make sure we apply affinities to move any // existing activities from other tasks in to it. // If the caller has requested that the target task be // reset, then do so. if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; resetTaskIfNeededLocked(r, r); doShow = topRunningNonDelayedActivityLocked(null) == r; &#125; &#125; else if (options != null &amp;&amp; new ActivityOptions(options).getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123; doShow = false; &#125; if (r.mLaunchTaskBehind) &#123; // Don't do a starting window for mLaunchTaskBehind. More importantly make sure we // tell WindowManager that r is visible even though it is at the back of the stack. mWindowManager.setAppVisibility(r.appToken, true); ensureActivitiesVisibleLocked(null, 0); &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123; // Figure out if we are transitioning from another activity that is // \"has the same starting icon\" as the next one. This allows the // window manager to keep the previous window it had previously // created, if it still had one. ActivityRecord prev = mResumedActivity; if (prev != null) &#123; // We don't want to reuse the previous starting preview if: // (1) The current activity is in a different task. if (prev.task != r.task) &#123; prev = null; &#125; // (2) The current activity is already displayed. else if (prev.nowVisible) &#123; prev = null; &#125; &#125; mWindowManager.setAppStartingWindow( r.appToken, r.packageName, r.theme, mService.compatibilityInfoForPackageLocked( r.info.applicationInfo), r.nonLocalizedLabel, r.labelRes, r.icon, r.logo, r.windowFlags, prev != null ? prev.appToken : null, showStartingIcon); r.mStartingWindowShown = true; &#125; &#125; else &#123; // If this is the first activity, don't do any fancy animations, // because there is nothing for it to animate on top of. mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); ActivityOptions.abort(options); options = null; &#125; if (VALIDATE_TOKENS) &#123; validateAppTokensLocked(); &#125; if (doResume) &#123; mStackSupervisor.resumeTopActivitiesLocked(this, r, options); &#125;&#125; 在Android应用程序框架层中，是由ActivityManagerService组件负责为Android应用程序创建新的进程的，它本来也是运行在一个独立的进程之中，不过这个进程是在系统启动的过程中创建的。 ActivityManagerService组件一般会在什么情况下会为应用程序创建一个新的进程呢？当系统决定要在一个新的进程中启动一个Activity或者Service时，它就会创建一个新的进程了， 然后在这个新的进程中启动这个Activity或者Service 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android HttpURLConnection源码分析","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/HttpURLConnection详解/","text":"Android HttpURLConnection源码分析之前写过HttpURLConnection与HttpClient的区别及选择。后来又分析了Volley的源码。最近又遇到了问题，想在Volley中针对HttpURLConnection添加连接池的功能，开始有点懵了，不知道HttpURLConnection要怎么加连接池，虽然感觉这是没必要的，但是心底确拿不出依据。所以研究下HttpURLConnection的源码进行分析。 在使用的时候都是通过URL.openConnection()来获取HttpURLConnection对象，然后调用其connect方法进行链接，所以先从URL.penConnection()入手:12345678/** * Returns a new connection to the resource referred to by this URL. * * @throws IOException if an error occurs while opening the connection. */public URLConnection openConnection() throws IOException &#123; return streamHandler.openConnection(this);&#125; 接下来就要看一下streamHandler究竟是何方神圣？我们搜一下他的赋值，实在setupStreamHandler方法中进行的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Sets the receiver's stream handler to one which is appropriate for its * protocol. * * &lt;p&gt;Note that this will overwrite any existing stream handler with the new * one. Senders must check if the streamHandler is null before calling the * method if they do not want this behavior (a speed optimization). * * @throws MalformedURLException if no reasonable handler is available. */void setupStreamHandler() &#123; // Check for a cached (previously looked up) handler for // the requested protocol. streamHandler = streamHandlers.get(protocol); if (streamHandler != null) &#123; return; &#125; // If there is a stream handler factory, then attempt to // use it to create the handler. if (streamHandlerFactory != null) &#123; streamHandler = streamHandlerFactory.createURLStreamHandler(protocol); if (streamHandler != null) &#123; streamHandlers.put(protocol, streamHandler); return; &#125; &#125; // Check if there is a list of packages which can provide handlers. // If so, then walk this list looking for an applicable one. String packageList = System.getProperty(\"java.protocol.handler.pkgs\"); ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); if (packageList != null &amp;&amp; contextClassLoader != null) &#123; for (String packageName : packageList.split(\"\\\\|\")) &#123; String className = packageName + \".\" + protocol + \".Handler\"; try &#123; Class&lt;?&gt; c = contextClassLoader.loadClass(className); streamHandler = (URLStreamHandler) c.newInstance(); if (streamHandler != null) &#123; streamHandlers.put(protocol, streamHandler); &#125; return; &#125; catch (IllegalAccessException ignored) &#123; &#125; catch (InstantiationException ignored) &#123; &#125; catch (ClassNotFoundException ignored) &#123; &#125; &#125; &#125; // Fall back to a built-in stream handler if the user didn't supply one if (protocol.equals(\"file\")) &#123; streamHandler = new FileHandler(); &#125; else if (protocol.equals(\"ftp\")) &#123; streamHandler = new FtpHandler(); &#125; else if (protocol.equals(\"http\")) &#123; // 判断一下如果是HTTP协议，就会创建HtppHandler。看到这里明白了，原来使用的是okhttp. try &#123; String name = \"com.android.okhttp.HttpHandler\"; streamHandler = (URLStreamHandler) Class.forName(name).newInstance(); &#125; catch (Exception e) &#123; throw new AssertionError(e); &#125; &#125; else if (protocol.equals(\"https\")) &#123; try &#123; String name = \"com.android.okhttp.HttpsHandler\"; streamHandler = (URLStreamHandler) Class.forName(name).newInstance(); &#125; catch (Exception e) &#123; throw new AssertionError(e); &#125; &#125; else if (protocol.equals(\"jar\")) &#123; streamHandler = new JarHandler(); &#125; if (streamHandler != null) &#123; streamHandlers.put(protocol, streamHandler); &#125;&#125; 这里我们就以HTTP协议为例说一下所以找到okhttp HttpHandler.openConnection()方法:12345678910111213141516171819202122232425262728293031323334353637/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.squareup.okhttp;import java.io.IOException;import java.net.Proxy;import java.net.URL;import java.net.URLConnection;import java.net.URLStreamHandler;public final class HttpHandler extends URLStreamHandler &#123; @Override protected URLConnection openConnection(URL url) throws IOException &#123; // 调用了OKHttpClient()的方法 return new OkHttpClient().open(url); &#125; @Override protected URLConnection openConnection(URL url, Proxy proxy) throws IOException &#123; if (url == null || proxy == null) &#123; throw new IllegalArgumentException(\"url == null || proxy == null\"); &#125; return new OkHttpClient().setProxy(proxy).open(url); &#125; @Override protected int getDefaultPort() &#123; return 80; &#125;&#125; 接下来就悲剧了，因为我找不到OkHttpClient()类中有open方法。仔细查看了文档后发现在OKHttp1.6.0的时候该方法就已经已经过时了。123@Deprecatedpublic HttpURLConnection open(URL url)Deprecated. moved to OkUrlFactory.open. 那我们怎么往下分析呢？很显然Android sdk中使用的OkHttp不是最新版。所以我们可以使用1.5.0版本的OKHttp接着分析。在项目build.gradle中进行配置 compile ‘com.squareup.okhttp:okhttp:1.5.0’ 然后开始愉快的查看源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443package com.squareup.okhttp;import com.squareup.okhttp.internal.Util;import com.squareup.okhttp.internal.http.HttpAuthenticator;import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;import com.squareup.okhttp.internal.http.ResponseCacheAdapter;import com.squareup.okhttp.internal.okio.ByteString;import com.squareup.okhttp.internal.tls.OkHostnameVerifier;import java.io.IOException;import java.net.CookieHandler;import java.net.HttpURLConnection;import java.net.Proxy;import java.net.ProxySelector;import java.net.ResponseCache;import java.net.URL;import java.net.URLConnection;import java.net.URLStreamHandler;import java.net.URLStreamHandlerFactory;import java.security.GeneralSecurityException;import java.util.ArrayList;import java.util.List;import java.util.concurrent.TimeUnit;import javax.net.ssl.HostnameVerifier;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSocketFactory;/** Configures and creates HTTP connections. */public final class OkHttpClient implements URLStreamHandlerFactory, Cloneable &#123; private final RouteDatabase routeDatabase; private Proxy proxy; private List&lt;Protocol&gt; protocols; private ProxySelector proxySelector; private CookieHandler cookieHandler; private OkResponseCache responseCache; private SSLSocketFactory sslSocketFactory; private HostnameVerifier hostnameVerifier; private OkAuthenticator authenticator; private ConnectionPool connectionPool; private boolean followProtocolRedirects = true; private int connectTimeout; private int readTimeout; public OkHttpClient() &#123; routeDatabase = new RouteDatabase(); &#125; /** * Sets the default connect timeout for new connections. A value of 0 means no timeout. * * @see URLConnection#setConnectTimeout(int) */ public void setConnectTimeout(long timeout, TimeUnit unit) &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(\"timeout &lt; 0\"); &#125; if (unit == null) &#123; throw new IllegalArgumentException(\"unit == null\"); &#125; long millis = unit.toMillis(timeout); if (millis &gt; Integer.MAX_VALUE) &#123; throw new IllegalArgumentException(\"Timeout too large.\"); &#125; connectTimeout = (int) millis; &#125; /** Default connect timeout (in milliseconds). */ public int getConnectTimeout() &#123; return connectTimeout; &#125; /** * Sets the default read timeout for new connections. A value of 0 means no timeout. * * @see URLConnection#setReadTimeout(int) */ public void setReadTimeout(long timeout, TimeUnit unit) &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(\"timeout &lt; 0\"); &#125; if (unit == null) &#123; throw new IllegalArgumentException(\"unit == null\"); &#125; long millis = unit.toMillis(timeout); if (millis &gt; Integer.MAX_VALUE) &#123; throw new IllegalArgumentException(\"Timeout too large.\"); &#125; readTimeout = (int) millis; &#125; /** Default read timeout (in milliseconds). */ public int getReadTimeout() &#123; return readTimeout; &#125; /** * Sets the HTTP proxy that will be used by connections created by this * client. This takes precedence over &#123;@link #setProxySelector&#125;, which is * only honored when this proxy is null (which it is by default). To disable * proxy use completely, call &#123;@code setProxy(Proxy.NO_PROXY)&#125;. */ public OkHttpClient setProxy(Proxy proxy) &#123; this.proxy = proxy; return this; &#125; public Proxy getProxy() &#123; return proxy; &#125; /** * Sets the proxy selection policy to be used if no &#123;@link #setProxy proxy&#125; * is specified explicitly. The proxy selector may return multiple proxies; * in that case they will be tried in sequence until a successful connection * is established. * * &lt;p&gt;If unset, the &#123;@link ProxySelector#getDefault() system-wide default&#125; * proxy selector will be used. */ public OkHttpClient setProxySelector(ProxySelector proxySelector) &#123; this.proxySelector = proxySelector; return this; &#125; public ProxySelector getProxySelector() &#123; return proxySelector; &#125; /** * Sets the cookie handler to be used to read outgoing cookies and write * incoming cookies. * * &lt;p&gt;If unset, the &#123;@link CookieHandler#getDefault() system-wide default&#125; * cookie handler will be used. */ public OkHttpClient setCookieHandler(CookieHandler cookieHandler) &#123; this.cookieHandler = cookieHandler; return this; &#125; public CookieHandler getCookieHandler() &#123; return cookieHandler; &#125; /** * Sets the response cache to be used to read and write cached responses. */ public OkHttpClient setResponseCache(ResponseCache responseCache) &#123; return setOkResponseCache(toOkResponseCache(responseCache)); &#125; public ResponseCache getResponseCache() &#123; return responseCache instanceof ResponseCacheAdapter ? ((ResponseCacheAdapter) responseCache).getDelegate() : null; &#125; public OkHttpClient setOkResponseCache(OkResponseCache responseCache) &#123; this.responseCache = responseCache; return this; &#125; public OkResponseCache getOkResponseCache() &#123; return responseCache; &#125; /** * Sets the socket factory used to secure HTTPS connections. * * &lt;p&gt;If unset, a lazily created SSL socket factory will be used. */ public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) &#123; this.sslSocketFactory = sslSocketFactory; return this; &#125; public SSLSocketFactory getSslSocketFactory() &#123; return sslSocketFactory; &#125; /** * Sets the verifier used to confirm that response certificates apply to * requested hostnames for HTTPS connections. * * &lt;p&gt;If unset, the * &#123;@link javax.net.ssl.HttpsURLConnection#getDefaultHostnameVerifier() * system-wide default&#125; hostname verifier will be used. */ public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) &#123; this.hostnameVerifier = hostnameVerifier; return this; &#125; public HostnameVerifier getHostnameVerifier() &#123; return hostnameVerifier; &#125; /** * Sets the authenticator used to respond to challenges from the remote web * server or proxy server. * * &lt;p&gt;If unset, the &#123;@link java.net.Authenticator#setDefault system-wide default&#125; * authenticator will be used. */ public OkHttpClient setAuthenticator(OkAuthenticator authenticator) &#123; this.authenticator = authenticator; return this; &#125; public OkAuthenticator getAuthenticator() &#123; return authenticator; &#125; /** * Sets the connection pool used to recycle HTTP and HTTPS connections. * * &lt;p&gt;If unset, the &#123;@link ConnectionPool#getDefault() system-wide * default&#125; connection pool will be used. */ public OkHttpClient setConnectionPool(ConnectionPool connectionPool) &#123; this.connectionPool = connectionPool; return this; &#125; public ConnectionPool getConnectionPool() &#123; return connectionPool; &#125; /** * Configure this client to follow redirects from HTTPS to HTTP and from HTTP * to HTTPS. * * &lt;p&gt;If unset, protocol redirects will be followed. This is different than * the built-in &#123;@code HttpURLConnection&#125;'s default. */ public OkHttpClient setFollowProtocolRedirects(boolean followProtocolRedirects) &#123; this.followProtocolRedirects = followProtocolRedirects; return this; &#125; public boolean getFollowProtocolRedirects() &#123; return followProtocolRedirects; &#125; public RouteDatabase getRoutesDatabase() &#123; return routeDatabase; &#125; /** * @deprecated OkHttp 1.5 enforces an enumeration of &#123;@link Protocol protocols&#125; * that can be selected. Please switch to &#123;@link #setProtocols(java.util.List)&#125;. */ @Deprecated public OkHttpClient setTransports(List&lt;String&gt; transports) &#123; List&lt;Protocol&gt; protocols = new ArrayList&lt;Protocol&gt;(transports.size()); for (int i = 0, size = transports.size(); i &lt; size; i++) &#123; try &#123; Protocol protocol = Util.getProtocol(ByteString.encodeUtf8(transports.get(i))); protocols.add(protocol); &#125; catch (IOException e) &#123; throw new IllegalArgumentException(e); &#125; &#125; return setProtocols(protocols); &#125; /** * Configure the protocols used by this client to communicate with remote * servers. By default this client will prefer the most efficient transport * available, falling back to more ubiquitous protocols. Applications should * only call this method to avoid specific compatibility problems, such as web * servers that behave incorrectly when SPDY is enabled. * * &lt;p&gt;The following protocols are currently supported: * &lt;ul&gt; * &lt;li&gt;&lt;a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616.html\"&gt;http/1.1&lt;/a&gt; * &lt;li&gt;&lt;a href=\"http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1\"&gt;spdy/3.1&lt;/a&gt; * &lt;li&gt;&lt;a href=\"http://tools.ietf.org/html/draft-ietf-httpbis-http2-09\"&gt;HTTP-draft-09/2.0&lt;/a&gt; * &lt;/ul&gt; * * &lt;p&gt;&lt;strong&gt;This is an evolving set.&lt;/strong&gt; Future releases may drop * support for transitional protocols (like spdy/3.1), in favor of their * successors (spdy/4 or http/2.0). The http/1.1 transport will never be * dropped. * * &lt;p&gt;If multiple protocols are specified, &lt;a * href=\"https://technotes.googlecode.com/git/nextprotoneg.html\"&gt;NPN&lt;/a&gt; will * be used to negotiate a transport. Future releases may use another mechanism * (such as &lt;a href=\"http://tools.ietf.org/html/draft-friedl-tls-applayerprotoneg-02\"&gt;ALPN&lt;/a&gt;) * to negotiate a transport. * * @param protocols the protocols to use, in order of preference. The list * must contain \"http/1.1\". It must not contain null. */ public OkHttpClient setProtocols(List&lt;Protocol&gt; protocols) &#123; protocols = Util.immutableList(protocols); if (!protocols.contains(Protocol.HTTP_11)) &#123; throw new IllegalArgumentException(\"protocols doesn't contain http/1.1: \" + protocols); &#125; if (protocols.contains(null)) &#123; throw new IllegalArgumentException(\"protocols must not contain null\"); &#125; this.protocols = Util.immutableList(protocols); return this; &#125; /** * @deprecated OkHttp 1.5 enforces an enumeration of &#123;@link Protocol * protocols&#125; that can be selected. Please switch to &#123;@link * #getProtocols()&#125;. */ @Deprecated public List&lt;String&gt; getTransports() &#123; List&lt;String&gt; transports = new ArrayList&lt;String&gt;(protocols.size()); for (int i = 0, size = protocols.size(); i &lt; size; i++) &#123; transports.add(protocols.get(i).name.utf8()); &#125; return transports; &#125; public List&lt;Protocol&gt; getProtocols() &#123; return protocols; &#125; public HttpURLConnection open(URL url) &#123; return open(url, proxy); &#125; HttpURLConnection open(URL url, Proxy proxy) &#123; String protocol = url.getProtocol(); // 将该对象clone后设置一些其他的属性返回，里面会设置一个默认的连接池。 OkHttpClient copy = copyWithDefaults(); copy.proxy = proxy; // 返回了HttpURLConnectionImpl，并且把clone后的OKHttpClient对象传递进去。 if (protocol.equals(\"http\")) return new HttpURLConnectionImpl(url, copy); if (protocol.equals(\"https\")) return new HttpsURLConnectionImpl(url, copy); throw new IllegalArgumentException(\"Unexpected protocol: \" + protocol); &#125; /** * Returns a shallow copy of this OkHttpClient that uses the system-wide * default for each field that hasn't been explicitly configured. */ OkHttpClient copyWithDefaults() &#123; OkHttpClient result = clone(); if (result.proxySelector == null) &#123; result.proxySelector = ProxySelector.getDefault(); &#125; if (result.cookieHandler == null) &#123; result.cookieHandler = CookieHandler.getDefault(); &#125; if (result.responseCache == null) &#123; result.responseCache = toOkResponseCache(ResponseCache.getDefault()); &#125; if (result.sslSocketFactory == null) &#123; result.sslSocketFactory = getDefaultSSLSocketFactory(); &#125; if (result.hostnameVerifier == null) &#123; result.hostnameVerifier = OkHostnameVerifier.INSTANCE; &#125; if (result.authenticator == null) &#123; result.authenticator = HttpAuthenticator.SYSTEM_DEFAULT; &#125; if (result.connectionPool == null) &#123; // 会给OkHttpClient设置一个默认的连接池 result.connectionPool = ConnectionPool.getDefault(); &#125; if (result.protocols == null) &#123; result.protocols = Util.HTTP2_SPDY3_AND_HTTP; &#125; return result; &#125; /** * Java and Android programs default to using a single global SSL context, * accessible to HTTP clients as &#123;@link SSLSocketFactory#getDefault()&#125;. If we * used the shared SSL context, when OkHttp enables NPN for its SPDY-related * stuff, it would also enable NPN for other usages, which might crash them * because NPN is enabled when it isn't expected to be. * &lt;p&gt; * This code avoids that by defaulting to an OkHttp created SSL context. The * significant drawback of this approach is that apps that customize the * global SSL context will lose these customizations. */ private synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123; if (sslSocketFactory == null) &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, null, null); sslSocketFactory = sslContext.getSocketFactory(); &#125; catch (GeneralSecurityException e) &#123; throw new AssertionError(); // The system has no TLS. Just give up. &#125; &#125; return sslSocketFactory; &#125; /** Returns a shallow copy of this OkHttpClient. */ @Override public OkHttpClient clone() &#123; try &#123; return (OkHttpClient) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); &#125; &#125; private OkResponseCache toOkResponseCache(ResponseCache responseCache) &#123; return responseCache == null || responseCache instanceof OkResponseCache ? (OkResponseCache) responseCache : new ResponseCacheAdapter(responseCache); &#125; /** * Creates a URLStreamHandler as a &#123;@link URL#setURLStreamHandlerFactory&#125;. * * &lt;p&gt;This code configures OkHttp to handle all HTTP and HTTPS connections * created with &#123;@link URL#openConnection()&#125;: &lt;pre&gt; &#123;@code * * OkHttpClient okHttpClient = new OkHttpClient(); * URL.setURLStreamHandlerFactory(okHttpClient); * &#125;&lt;/pre&gt; */ public URLStreamHandler createURLStreamHandler(final String protocol) &#123; if (!protocol.equals(\"http\") &amp;&amp; !protocol.equals(\"https\")) return null; return new URLStreamHandler() &#123; @Override protected URLConnection openConnection(URL url) &#123; return open(url); &#125; @Override protected URLConnection openConnection(URL url, Proxy proxy) &#123; return open(url, proxy); &#125; @Override protected int getDefaultPort() &#123; if (protocol.equals(\"http\")) return 80; if (protocol.equals(\"https\")) return 443; throw new AssertionError(); &#125; &#125;; &#125;&#125; 接着看一下HttpURLConnectionImpl类,它是HttpURLConnection的子类：123public class HttpURLConnectionImpl extends HttpURLConnection &#123; .....&#125; 到这里new URL(url).openConnection()方法已经分析完了，其实就是返回了一个HtppURLConnectionImpl对象。 我们在使用HttpURLConnection都是这样使用：123456789101112String url = \"http://www.baidu.com\"URL url = new URL(url);HttpURLConnection connection = (HttpURLConnection)url.openConnection();// 设置一些请求头等参数...connection.connect();// 然后调用一些其他的获取结果或者状态的方法。...connection.getResponseCode();connection.getOuoputStream();connection.getInputStream();.... 上面分析了new URL().openConnection()那我们这里就接着分析第二步了，就是调用connect()方法的处理:这里看一下HttpURLConnectionImpl.connect()方法：1234567@Override public final void connect() throws IOException &#123;initHttpEngine();boolean success;do &#123; success = execute(false);&#125; while (!success);&#125; 接着看一下initHttpEngine()方法的实现:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private void initHttpEngine() throws IOException &#123; if (httpEngineFailure != null) &#123; throw httpEngineFailure; &#125; else if (httpEngine != null) &#123; return; &#125; connected = true; try &#123; if (doOutput) &#123; if (method.equals(\"GET\")) &#123; // they are requesting a stream to write to. This implies a POST method method = \"POST\"; &#125; else if (!HttpMethod.hasRequestBody(method)) &#123; // If the request method is neither POST nor PUT nor PATCH, then you're not writing throw new ProtocolException(method + \" does not support writing\"); &#125; &#125; // 将newHttpEngine方法的返回值赋值给HttpEngine的成员变量。 httpEngine = newHttpEngine(method, null, null); &#125; catch (IOException e) &#123; httpEngineFailure = e; throw e; &#125; &#125; private HttpEngine newHttpEngine(String method, Connection connection, RetryableSink requestBody) &#123; Request.Builder builder = new Request.Builder() .url(getURL()) .method(method, null /* No body; that's passed separately. */); Headers headers = requestHeaders.build(); for (int i = 0; i &lt; headers.size(); i++) &#123; builder.addHeader(headers.name(i), headers.value(i)); &#125; boolean bufferRequestBody; if (fixedContentLength != -1) &#123; bufferRequestBody = false; builder.header(\"Content-Length\", Long.toString(fixedContentLength)); &#125; else if (chunkLength &gt; 0) &#123; bufferRequestBody = false; builder.header(\"Transfer-Encoding\", \"chunked\"); &#125; else &#123; bufferRequestBody = true; &#125; Request request = builder.build(); // If we're currently not using caches, make sure the engine's client doesn't have one. OkHttpClient engineClient = client; if (engineClient.getOkResponseCache() != null &amp;&amp; !getUseCaches()) &#123; engineClient = client.clone().setOkResponseCache(null); &#125; // 将之前通过构造函数传递进来的OkHttpClient对象clone一份后再传递给HttpEngine return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody); &#125; 到这里我们知道他会创建一个HttpEngine类，我们先不管它，接着看一下execute()方法的内部实现：12345678910111213141516171819202122232425262728293031/*** Sends a request and optionally reads a response. Returns true if the* request was successfully executed, and false if the request can be* retried. Throws an exception if the request failed permanently.*/private boolean execute(boolean readResponse) throws IOException &#123;try &#123; // 调用了HttpEngine的sendRequest方法。 httpEngine.sendRequest(); route = httpEngine.getRoute(); handshake = httpEngine.getConnection() != null ? httpEngine.getConnection().getHandshake() : null; // 读取结果，我们先不分析这里，等把sendRequest部分全部分析完成后再回来分析readResponse()部分。 if (readResponse) &#123; httpEngine.readResponse(); &#125; return true;&#125; catch (IOException e) &#123; HttpEngine retryEngine = httpEngine.recover(e); if (retryEngine != null) &#123; httpEngine = retryEngine; return false; &#125; // Give up; recovery is not possible. httpEngineFailure = e; throw e;&#125;&#125; 到这里，可以大胆的猜测一下了HttpEngine应该就是实际在Socket链接上进行数据收发的类。 当然这只是猜测，接着看一下它的实现:123456789101112131415161718/** * Handles a single HTTP request/response pair. Each HTTP engine follows this * lifecycle: * &lt;ol&gt; * &lt;li&gt;It is created. * &lt;li&gt;The HTTP request message is sent with sendRequest(). Once the request * is sent it is an error to modify the request headers. After * sendRequest() has been called the request body can be written to if * it exists. * &lt;li&gt;The HTTP response message is read with readResponse(). After the * response has been read the response headers and body can be read. * All responses have a response body input stream, though in some * instances this stream is empty. * &lt;/ol&gt; * * &lt;p&gt;The request and response may be served by the HTTP response cache, by the * network, or by both in the event of a conditional GET. */ 文档验证了我们的想法。因为它内部实现代码比较多，所以就不全部贴了，按照重要的一步步分析，既然上面调用了sendRequest()方法，这里就从他入手： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*** Figures out what the response source will be, and opens a socket to that* source if necessary. Prepares the request headers and gets ready to start* writing the request body if it exists.*/public final void sendRequest() throws IOException &#123; if (responseSource != null) return; // Already sent. if (transport != null) throw new IllegalStateException(); // 设置一些请求头，正式这个方法内部默认设置了`Keep-Alive`的值，也就是在Android Level 9之前因为Bug，我们需要关闭它的具体处理位置。 prepareRawRequestHeaders(); // 处理cache OkResponseCache responseCache = client.getOkResponseCache(); Response cacheResponse = responseCache != null ? responseCache.get(request) : null; long now = System.currentTimeMillis(); CacheStrategy cacheStrategy = new CacheStrategy.Factory(now, request, cacheResponse).get(); responseSource = cacheStrategy.source; request = cacheStrategy.request; if (responseCache != null) &#123; // 记录下当前的请求是来自网络请求还是来时缓存中的数据。 responseCache.trackResponse(responseSource); &#125; if (responseSource != ResponseSource.NETWORK) &#123; validatingResponse = cacheStrategy.response; &#125; if (cacheResponse != null &amp;&amp; !responseSource.usesCache()) &#123; closeQuietly(cacheResponse.body()); // We don't need this cached response. Close it. &#125; if (responseSource.requiresConnection()) &#123; // Open a connection unless we inherited one from a redirect. if (connection == null) &#123; // 调用connect方法，内部会重新创建一个connection，连接到服务器、重定向或者通过代理。 connect(); &#125; // 通过Connection创建一个HttpTransport类。这个和后面的connection类一起看， Transport接口提供了一个用户写Request头和数据的输出流。 transport = (Transport) connection.newTransport(this); // Create a request body if we don't have one already. We'll already have // one if we're retrying a failed POST. if (hasRequestBody() &amp;&amp; requestBodyOut == null) &#123; // 通过transport创建一个请求体的输出流，requestBodyOut是Sink接口的实现类，其实就是将请求头和请求体发送给服务器。这部分跟下去内容比较多，就不往下跟了。 // 到这里就已经完成了与服务器的连接功能，并且把请求内容发送给服务器。请求部分就执行完了，可以回去了，还知道开头是哪吗？哈哈。接下来的就是从服务器接口读取返回数据了。 requestBodyOut = transport.createRequestBody(request); &#125; &#125; else &#123; // We're using a cached response. Recycle a connection we may have inherited from a redirect. if (connection != null) &#123; // 回收connection，这里就看到了连接池，这个client就是构造函数中传递进来的OKHttpClient client.getConnectionPool().recycle(connection); connection = null; &#125; // No need for the network! Promote the cached response immediately. this.response = validatingResponse; if (validatingResponse.body() != null) &#123; initContentStream(validatingResponse.body().source()); &#125; &#125;&#125; 接着看一下connect()方法：1234567891011121314151617181920212223242526272829303132333435363738/** Connect to the origin server either directly or via a proxy. */private void connect() throws IOException &#123; if (connection != null) throw new IllegalStateException(); if (routeSelector == null) &#123; String uriHost = request.url().getHost(); if (uriHost == null || uriHost.length() == 0) &#123; throw new UnknownHostException(request.url().toString()); &#125; SSLSocketFactory sslSocketFactory = null; HostnameVerifier hostnameVerifier = null; if (request.isHttps()) &#123; sslSocketFactory = client.getSslSocketFactory(); hostnameVerifier = client.getHostnameVerifier(); &#125; Address address = new Address(uriHost, getEffectivePort(request.url()), sslSocketFactory, hostnameVerifier, client.getAuthenticator(), client.getProxy(), client.getProtocols()); // RoteSeclector类介绍. Selects routes to connect to an origin server. Each connection requires a // choice of proxy server, IP address, and TLS mode. Connections may also be // recycled.注意他把OkHttpClient中的connection pool传递进来了。 routeSelector = new RouteSelector(address, request.uri(), client.getProxySelector(), client.getConnectionPool(), Dns.DEFAULT, client.getRoutesDatabase()); &#125; // roteSeclecrot.next()方法的注释Returns the next route address to attempt.这一步非常重要。 connection = routeSelector.next(request.method()); if (!connection.isConnected()) &#123; // connection 进行连接了啊。他里面会用Socket开始连了。。后面我们再细看。简单的说Connection管理了Socket，后面我们要重点看这个类。 connection.connect(client.getConnectTimeout(), client.getReadTimeout(), getTunnelConfig()); if (connection.isSpdy()) client.getConnectionPool().share(connection); client.getRoutesDatabase().connected(connection.getRoute()); &#125; else if (!connection.isSpdy()) &#123; connection.updateReadTimeout(client.getReadTimeout()); &#125; route = connection.getRoute();&#125; 接下来我们要先看一下routeSelector.next()方法如何返回connection对象，然后在看Connection.connect()方法：123456789101112131415161718192021222324252627282930313233343536373839404142/*** Returns the next route address to attempt.** @throws NoSuchElementException if there are no more routes to attempt.*/public Connection next(String method) throws IOException &#123; // 使用连接池获取Connection的地方。pool就是OkHttpClient中的连接池。 // Always prefer pooled connections over new connections. for (Connection pooled; (pooled = pool.get(address)) != null; ) &#123; // 匹配get方法，或者判断是否可读，http1.x是通过判断socket是否关闭来判断是否可读的。 if (method.equals(\"GET\") || pooled.isReadable()) return pooled; // 不满足重用，就关闭。 pooled.close(); &#125; // Compute the next route to attempt. if (!hasNextTlsMode()) &#123; if (!hasNextInetSocketAddress()) &#123; if (!hasNextProxy()) &#123; if (!hasNextPostponed()) &#123; throw new NoSuchElementException(); &#125; return new Connection(pool, nextPostponed()); &#125; lastProxy = nextProxy(); resetNextInetSocketAddress(lastProxy); &#125; lastInetSocketAddress = nextInetSocketAddress(); resetNextTlsMode(); &#125; boolean modernTls = nextTlsMode() == TLS_MODE_MODERN; Route route = new Route(address, lastProxy, lastInetSocketAddress, modernTls); if (routeDatabase.shouldPostpone(route)) &#123; postponedRoutes.add(route); // We will only recurse in order to skip previously failed routes. They will be // tried last. return next(method); &#125; // 没有的话也会去创建，并把OkHttpClient中的连接池传递进去。 return new Connection(pool, route);&#125; 再看一下Connection类的实现以及其connect()方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public final class Connection implements Closeable &#123; private final ConnectionPool pool; private final Route route; private Socket socket; private InputStream in; private OutputStream out; private BufferedSource source; private BufferedSink sink; private boolean connected = false; private HttpConnection httpConnection; private SpdyConnection spdyConnection; private int httpMinorVersion = 1; // Assume HTTP/1.1 private long idleStartTimeNs; private Handshake handshake; private int recycleCount; // 传递进来的连接池。 public Connection(ConnectionPool pool, Route route) &#123; this.pool = pool; this.route = route; &#125; public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException &#123; if (connected) throw new IllegalStateException(\"already connected\"); socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket(); // 连socket了，内部调用了socket.connect()方法。Connects this socket to the given remote host address and port specified // by the SocketAddress &#123;@code remoteAddr&#125; with the specified timeout. The // connecting method will block until the connection is established or an // error occurred. Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout); socket.setSoTimeout(readTimeout); in = socket.getInputStream(); out = socket.getOutputStream(); if (route.address.sslSocketFactory != null) &#123; // 完成TLS握手和验证 upgradeToTls(tunnelRequest); &#125; else &#123; initSourceAndSink(); // 创建HttpConnection.A socket connection that can be used to send HTTP/1.1 messages. // 这个HttpConnection有什么用呢？就是下面的newTransport方法中会用。而且还要把连接池传递进去？ httpConnection = new HttpConnection(pool, this, source, sink); &#125; // 这样就已经连接上了 connected = true; &#125; // 该方法决定了使用的协议是SPDY还是HTTP /** Returns the transport appropriate for this connection. */ public Object newTransport(HttpEngine httpEngine) throws IOException &#123; return (spdyConnection != null) ? new SpdyTransport(httpEngine, spdyConnection) : new HttpTransport(httpEngine, httpConnection); &#125;&#125; 到这里就已经把发送请求到服务器的部分全部分析完了，就想上面所说的我们应该回去了，回去分析发送完请求后的部分。我们这个分析是在HttpURLConnectionImpl.execute()方法中的HttpEngine.sendRequest()方法开始一直分析下来的，所以我们还是要回到HttpURLConnectionImpl.execute()方法中.123456789101112131415161718192021222324252627private boolean execute(boolean readResponse) throws IOException &#123;try &#123; // 上面已经把sendRequest部分全部分析完了，该方法会与服务器通过Socket建立连接并把请求部分发送给服务器。 httpEngine.sendRequest(); route = httpEngine.getRoute(); handshake = httpEngine.getConnection() != null ? httpEngine.getConnection().getHandshake() : null; if (readResponse) &#123; // 发送完请求之后该干什么呢？ 当然是读取返回数据了。。。 没错就是它。但是不要忘了在connect()方法传递过来的时候这个值是false。 // 所以这一步在这里是不执行的，但是我们也分析下，方便以后理解。那这个值什么时候是true呢？就是在getResponse()方法中。 httpEngine.readResponse(); &#125; return true;&#125; catch (IOException e) &#123; HttpEngine retryEngine = httpEngine.recover(e); if (retryEngine != null) &#123; httpEngine = retryEngine; return false; &#125; // Give up; recovery is not possible. httpEngineFailure = e; throw e;&#125;&#125; 接着看HttpEngine.readResponse()方法吧。注释说的非常明白。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*** Flushes the remaining request header and body, parses the HTTP response* headers and starts reading the HTTP response body if it exists.*/public final void readResponse() throws IOException &#123;if (response != null) return;if (responseSource == null) throw new IllegalStateException(\"call sendRequest() first!\");if (!responseSource.requiresConnection()) return;// Flush the request body if there's data outstanding.if (bufferedRequestBody != null &amp;&amp; bufferedRequestBody.buffer().size() &gt; 0) &#123; bufferedRequestBody.flush();&#125;if (sentRequestMillis == -1) &#123; if (OkHeaders.contentLength(request) == -1 &amp;&amp; requestBodyOut instanceof RetryableSink) &#123; // We might not learn the Content-Length until the request body has been buffered. long contentLength = ((RetryableSink) requestBodyOut).contentLength(); request = request.newBuilder() .header(\"Content-Length\", Long.toString(contentLength)) .build(); &#125; transport.writeRequestHeaders(request);&#125;if (requestBodyOut != null) &#123; if (bufferedRequestBody != null) &#123; // This also closes the wrapped requestBodyOut. bufferedRequestBody.close(); &#125; else &#123; requestBodyOut.close(); &#125; if (requestBodyOut instanceof RetryableSink) &#123; transport.writeRequestBody((RetryableSink) requestBodyOut); &#125;&#125;transport.flushRequest();response = transport.readResponseHeaders() .request(request) .handshake(connection.getHandshake()) .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis)) .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis())) .setResponseSource(responseSource) .build();connection.setHttpMinorVersion(response.httpMinorVersion());receiveHeaders(response.headers());if (responseSource == ResponseSource.CONDITIONAL_CACHE) &#123; // 检查缓存是否可用，如果可用就用当前缓存的response。并且释放该连接。 if (validatingResponse.validate(response)) &#123; transport.emptyTransferStream(); releaseConnection(); response = combine(validatingResponse, response); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). OkResponseCache responseCache = client.getOkResponseCache(); responseCache.trackConditionalCacheHit(); responseCache.update(validatingResponse, cacheableResponse()); if (validatingResponse.body() != null) &#123; initContentStream(validatingResponse.body().source()); &#125; return; &#125; else &#123; closeQuietly(validatingResponse.body()); &#125;&#125;if (!hasResponseBody()) &#123; // Don't call initContentStream() when the response doesn't have any content. responseTransferSource = transport.getTransferStream(cacheRequest); responseBody = responseTransferSource; return;&#125;// 设置cacheRequest的值maybeCache();// 设置返回数据了，transport这里也就是HttpTransport。他的getTransferStream返回的是一个Source接口的实现类。也就是返回的数据。initContentStream(transport.getTransferStream(cacheRequest));&#125; 先看一下maybeCache()方法：12345678910111213private void maybeCache() throws IOException &#123;OkResponseCache responseCache = client.getOkResponseCache();if (responseCache == null) return;// Should we cache this response for this request?if (!CacheStrategy.isCacheable(response, request)) &#123; responseCache.maybeRemove(request); return;&#125;// Offer this request to the cache.cacheRequest = responseCache.put(cacheableResponse());&#125; 再看一下initContentStream()方法：1234567891011121314151617181920212223242526272829/*** Initialize the response content stream from the response transfer source.* These two sources are the same unless we're doing transparent gzip, in* which case the content source is decompressed.** &lt;p&gt;Whenever we do transparent gzip we also strip the corresponding headers.* We strip the Content-Encoding header to prevent the application from* attempting to double decompress. We strip the Content-Length header because* it is the length of the compressed content, but the application is only* interested in the length of the uncompressed content.** &lt;p&gt;This method should only be used for non-empty response bodies. Response* codes like \"304 Not Modified\" can include \"Content-Encoding: gzip\" without* a response body and we will crash if we attempt to decompress the zero-byte* source.*/private void initContentStream(Source transferSource) throws IOException &#123;responseTransferSource = transferSource;if (transparentGzip &amp;&amp; \"gzip\".equalsIgnoreCase(response.header(\"Content-Encoding\"))) &#123; // 没有结果时response为null，有结果了就会给他赋值。 response = response.newBuilder() .removeHeader(\"Content-Encoding\") .removeHeader(\"Content-Length\") .build(); responseBody = new GzipSource(transferSource);&#125; else &#123; responseBody = transferSource;&#125;&#125; 到这里又执行完了，responseBody已经被赋值了，他是一个Source接口的实现类。也就是说到这里，这次网络请求就完成了，也收到了服务器返回的数据。 也就是说到这里我们已经分析了: 12HttpURLConnection connection = (HttpURLConnection)new URL(url).openConnection();connection.connect(); 接下来就是分析connection.getResponseCode()以及connection.getOutputStream()这两个方法了。先看一下getResponseCode()方法： 1234@Override public final int getResponseCode() throws IOException &#123;// 看到了吗？这里就是刚才我们说的execute()方法的参数什么时候会为true的地方。return getResponse().getResponse().code();&#125; 那我们接着看一下getResponse()方法，其实就是直接读取响应头的响应值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*** Aggressively tries to get the final HTTP response, potentially making* many HTTP requests in the process in order to cope with redirects and* authentication.*/private HttpEngine getResponse() throws IOException &#123;initHttpEngine();// 如果已经有返回数据了就直接返回if (httpEngine.hasResponse()) &#123; return httpEngine;&#125;while (true) &#123; // 参数为true了。 if (!execute(true)) &#123; continue; &#125; Retry retry = processResponseHeaders(); if (retry == Retry.NONE) &#123; httpEngine.releaseConnection(); return httpEngine; &#125; // The first request was insufficient. Prepare for another... String retryMethod = method; Sink requestBody = httpEngine.getRequestBody(); // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM // redirect should keep the same method, Chrome, Firefox and the // RI all issue GETs when following any redirect. int responseCode = httpEngine.getResponse().code(); if (responseCode == HTTP_MULT_CHOICE || responseCode == HTTP_MOVED_PERM || responseCode == HTTP_MOVED_TEMP || responseCode == HTTP_SEE_OTHER) &#123; retryMethod = \"GET\"; requestHeaders.removeAll(\"Content-Length\"); requestBody = null; &#125; if (requestBody != null &amp;&amp; !(requestBody instanceof RetryableSink)) &#123; throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode); &#125; if (retry == Retry.DIFFERENT_CONNECTION) &#123; httpEngine.releaseConnection(); &#125; Connection connection = httpEngine.close(); httpEngine = newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);&#125;&#125; 接着看一下getOutputStream()的源码：123456789101112131415@Override public final OutputStream getOutputStream() throws IOException &#123;// 看到了吗？他内部会先去调用connect()方法connect(); // 这里可能有人会有说，getOutputStream和request body有什么关系，应该是response body才对啊。// 不要弄混了啊，getOutputStream是要把post请求的数据输入给请求。BufferedSink sink = httpEngine.getBufferedRequestBody();if (sink == null) &#123; throw new ProtocolException(\"method does not support a request body: \" + method);&#125; else if (httpEngine.hasResponse()) &#123; throw new ProtocolException(\"cannot write request body after response has been read\");&#125;return sink.outputStream();&#125; 顺便再看一下getInputStream()方法： 123456789101112131415161718192021@Override public final InputStream getInputStream() throws IOException &#123;if (!doInput) &#123; throw new ProtocolException(\"This protocol does not support input\");&#125;// 它也会直接调用getResponse()方法，这个比较好理解。HttpEngine response = getResponse();// if the requested file does not exist, throw an exception formerly the// Error page from the server was returned if the requested file was// text/html this has changed to return FileNotFoundException for all// file typesif (getResponseCode() &gt;= HTTP_BAD_REQUEST) &#123; throw new FileNotFoundException(url.toString());&#125;InputStream result = response.getResponseBodyBytes();if (result == null) &#123; throw new ProtocolException(\"No response body exists; responseCode=\" + getResponseCode());&#125;return result;&#125; 再顺便看一下HttpURLConnection.disconnect()方法，因为这个方法可能很多人不清楚该不该调用他,不过注释说的很明白了：12345678910111213141516/** * Releases this connection so that its resources may be either reused or * closed. * * &lt;p&gt;Unlike other Java implementations, this will not necessarily close * socket connections that can be reused. You can disable all connection * reuse by setting the &#123;@code http.keepAlive&#125; system property to &#123;@code * false&#125; before issuing any HTTP requests. */@Override public final void disconnect() &#123;// Calling disconnect() before a connection exists should have no effect.if (httpEngine != null) &#123; // 调用HttpEngine.close()方法 httpEngine.close();&#125;&#125; 看一下HttpEngine.close()方法:12345678910111213141516171819202122232425262728293031323334353637/*** Release any resources held by this engine. If a connection is still held by* this engine, it is returned.*/public final Connection close() &#123;if (bufferedRequestBody != null) &#123; // This also closes the wrapped requestBodyOut. closeQuietly(bufferedRequestBody);&#125; else if (requestBodyOut != null) &#123; closeQuietly(requestBodyOut);&#125;// If this engine never achieved a response body, its connection cannot be reused.if (responseBody == null) &#123; closeQuietly(connection); connection = null; return null;&#125;// Close the response body. This will recycle the connection if it is eligible.closeQuietly(responseBody);// Clear the buffer held by the response body input stream adapter.closeQuietly(responseBodyBytes);// HttpTransport.canReuseConnection()用于判断该Connection是否可复用// Close the connection if it cannot be reused.if (transport != null &amp;&amp; !transport.canReuseConnection()) &#123; closeQuietly(connection); connection = null; return null;&#125;Connection result = connection;connection = null;return result;&#125; 继续看一下closeQuietly(connection)方法：123456789101112131415/*** Closes &#123;@code closeable&#125;, ignoring any checked exceptions. Does nothing* if &#123;@code closeable&#125; is null.*/public static void closeQuietly(Closeable closeable) &#123;if (closeable != null) &#123; try &#123; // 这里也就是Connection的close()方法 closeable.close(); &#125; catch (RuntimeException rethrown) &#123; throw rethrown; &#125; catch (Exception ignored) &#123; &#125;&#125;&#125; 再接着看一下Connection.close()方法：1234@Override public void close() throws IOException &#123;// 直接调用了socket.close()方法。这些socket也关了。socket.close();&#125; 再看Socket.close()方法：1234567891011121314151617package com.squareup.okhttp;/** * Closes the socket. It is not possible to reconnect or rebind to this * socket thereafter which means a new socket instance has to be created. * * @throws IOException * if an error occurs while closing the socket. */public synchronized void close() throws IOException &#123; isClosed = true; isConnected = false; // RI compatibility: the RI returns the any address (but the original local port) after // close. localAddress = Inet4Address.ANY; impl.close();&#125; 到这里就都看完了，最后我们再看一下上面用到的连接池，也就是ConnectionPool类: 因为在上面的分析中，我们发现此类贯穿了很多类。它为OkHttpClient中的对象，后贯穿到HttpEngine、Connection、HttpConnection等。所以要分析下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251/** * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP * requests that share the same &#123;@link com.squareup.okhttp.Address&#125; may share a * &#123;@link com.squareup.okhttp.Connection&#125;. This class implements the policy of * which connections to keep open for future use. * * &lt;p&gt;The &#123;@link #getDefault() system-wide default&#125; uses system properties for * tuning parameters: * &lt;ul&gt; * &lt;li&gt;&#123;@code http.keepAlive&#125; true if HTTP and SPDY connections should be * pooled at all. Default is true. * &lt;li&gt;&#123;@code http.maxConnections&#125; maximum number of idle connections to * each to keep in the pool. Default is 5. * &lt;li&gt;&#123;@code http.keepAliveDuration&#125; Time in milliseconds to keep the * connection alive in the pool before closing it. Default is 5 minutes. * This property isn't used by &#123;@code HttpURLConnection&#125;. * &lt;/ul&gt; * * &lt;p&gt;The default instance &lt;i&gt;doesn't&lt;/i&gt; adjust its configuration as system * properties are changed. This assumes that the applications that set these * parameters do so before making HTTP connections, and that this class is * initialized lazily. */public class ConnectionPool &#123; private static final int MAX_CONNECTIONS_TO_CLEANUP = 2; private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min // 这个就是getDefault方法所返回的默认连接池。 private static final ConnectionPool systemDefault; static &#123; String keepAlive = System.getProperty(\"http.keepAlive\"); // 存活时间 String keepAliveDuration = System.getProperty(\"http.keepAliveDuration\"); // 最大空闲连接数 String maxIdleConnections = System.getProperty(\"http.maxConnections\"); long keepAliveDurationMs = keepAliveDuration != null ? Long.parseLong(keepAliveDuration) : DEFAULT_KEEP_ALIVE_DURATION_MS; if (keepAlive != null &amp;&amp; !Boolean.parseBoolean(keepAlive)) &#123; systemDefault = new ConnectionPool(0, keepAliveDurationMs); &#125; else if (maxIdleConnections != null) &#123; systemDefault = new ConnectionPool(Integer.parseInt(maxIdleConnections), keepAliveDurationMs); &#125; else &#123; systemDefault = new ConnectionPool(5, keepAliveDurationMs); &#125; &#125; /** The maximum number of idle connections for each address. */ private final int maxIdleConnections; private final long keepAliveDurationNs; private final LinkedList&lt;Connection&gt; connections = new LinkedList&lt;Connection&gt;(); // 连接的有效性检测是所有连接池都面临的一个通用问题，大部分HTTP服务器为了控制资源开销，并不会永久的维护一个长连接，而是一段时间就会关闭该连接。 // 放回连接池的连接，如果在服务器端已经关闭，客户端是无法检测到这个状态变化而及时的关闭Socket的。这就造成了线程从连接池中获取的连接不一定是有效的。 // 这个问题的一个解决方法就是在每次请求之前检查该连接是否已经存在了过长时间，可能已过期。但是这个方法会使得每次请求都增加额外的开销。 // 所以通过下面的任务来执行清理过期的连接。 /** We use a single background thread to cleanup expired connections. */ private final ExecutorService executorService = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), Util.threadFactory(\"OkHttp ConnectionPool\", true)); private final Runnable connectionsCleanupRunnable = new Runnable() &#123; @Override public void run() &#123; List&lt;Connection&gt; expiredConnections = new ArrayList&lt;Connection&gt;(MAX_CONNECTIONS_TO_CLEANUP); int idleConnectionCount = 0; synchronized (ConnectionPool.this) &#123; for (ListIterator&lt;Connection&gt; i = connections.listIterator(connections.size()); i.hasPrevious(); ) &#123; Connection connection = i.previous(); if (!connection.isAlive() || connection.isExpired(keepAliveDurationNs)) &#123; i.remove(); expiredConnections.add(connection); if (expiredConnections.size() == MAX_CONNECTIONS_TO_CLEANUP) break; &#125; else if (connection.isIdle()) &#123; idleConnectionCount++; &#125; &#125; for (ListIterator&lt;Connection&gt; i = connections.listIterator(connections.size()); i.hasPrevious() &amp;&amp; idleConnectionCount &gt; maxIdleConnections; ) &#123; Connection connection = i.previous(); if (connection.isIdle()) &#123; expiredConnections.add(connection); i.remove(); --idleConnectionCount; &#125; &#125; &#125; for (Connection expiredConnection : expiredConnections) &#123; Util.closeQuietly(expiredConnection); &#125; &#125; &#125;; public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) &#123; this.maxIdleConnections = maxIdleConnections; this.keepAliveDurationNs = keepAliveDurationMs * 1000 * 1000; &#125; /** * Returns a snapshot of the connections in this pool, ordered from newest to * oldest. Waits for the cleanup callable to run if it is currently scheduled. */ List&lt;Connection&gt; getConnections() &#123; waitForCleanupCallableToRun(); synchronized (this) &#123; return new ArrayList&lt;Connection&gt;(connections); &#125; &#125; /** * Blocks until the executor service has processed all currently enqueued * jobs. */ private void waitForCleanupCallableToRun() &#123; try &#123; executorService.submit(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;).get(); &#125; catch (Exception e) &#123; throw new AssertionError(); &#125; &#125; public static ConnectionPool getDefault() &#123; return systemDefault; &#125; /** Returns total number of connections in the pool. */ public synchronized int getConnectionCount() &#123; return connections.size(); &#125; /** Returns total number of spdy connections in the pool. */ public synchronized int getSpdyConnectionCount() &#123; int total = 0; for (Connection connection : connections) &#123; if (connection.isSpdy()) total++; &#125; return total; &#125; /** Returns total number of http connections in the pool. */ public synchronized int getHttpConnectionCount() &#123; int total = 0; for (Connection connection : connections) &#123; if (!connection.isSpdy()) total++; &#125; return total; &#125; /** Returns a recycled connection to &#123;@code address&#125;, or null if no such connection exists. */ public synchronized Connection get(Address address) &#123; Connection foundConnection = null; for (ListIterator&lt;Connection&gt; i = connections.listIterator(connections.size()); i.hasPrevious(); ) &#123; Connection connection = i.previous(); if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() &gt;= keepAliveDurationNs) &#123; continue; &#125; i.remove(); if (!connection.isSpdy()) &#123; // 不是spdy连接 try &#123; // Platforml类对当前Android平台做了适配。 Platform.get().tagSocket(connection.getSocket()); &#125; catch (SocketException e) &#123; Util.closeQuietly(connection); // When unable to tag, skip recycling and close Platform.get().logW(\"Unable to tagSocket(): \" + e); continue; &#125; &#125; // 找到可复用的Connection foundConnection = connection; break; &#125; // 针对spdy连接，添加到连接池中 if (foundConnection != null &amp;&amp; foundConnection.isSpdy()) &#123; connections.addFirst(foundConnection); // Add it back after iteration. &#125; executorService.execute(connectionsCleanupRunnable); return foundConnection; &#125; /** * Gives &#123;@code connection&#125; to the pool. The pool may store the connection, * or close it, as its policy describes. * * &lt;p&gt;It is an error to use &#123;@code connection&#125; after calling this method. */ public void recycle(Connection connection) &#123; if (connection.isSpdy()) &#123; return; &#125; if (!connection.isAlive()) &#123; Util.closeQuietly(connection); return; &#125; try &#123; Platform.get().untagSocket(connection.getSocket()); &#125; catch (SocketException e) &#123; // When unable to remove tagging, skip recycling and close. Platform.get().logW(\"Unable to untagSocket(): \" + e); Util.closeQuietly(connection); return; &#125; synchronized (this) &#123; connections.addFirst(connection); connection.incrementRecycleCount(); connection.resetIdleStartTime(); &#125; executorService.execute(connectionsCleanupRunnable); &#125; /** * Shares the SPDY connection with the pool. Callers to this method may * continue to use &#123;@code connection&#125;. */ public void share(Connection connection) &#123; if (!connection.isSpdy()) throw new IllegalArgumentException(); executorService.execute(connectionsCleanupRunnable); if (connection.isAlive()) &#123; synchronized (this) &#123; connections.addFirst(connection); &#125; &#125; &#125; /** Close and remove all connections in the pool. */ public void evictAll() &#123; List&lt;Connection&gt; connections; synchronized (this) &#123; connections = new ArrayList&lt;Connection&gt;(this.connections); this.connections.clear(); &#125; for (int i = 0, size = connections.size(); i &lt; size; i++) &#123; Util.closeQuietly(connections.get(i)); &#125; &#125;&#125; 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"RxJava详解(上)","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/RxJava详解(上)/","text":"RxJava详解(上)年初的时候就想学习下RxJava然后写一些RxJava的教程，无奈发现已经年底了，然而我还么有写。今天有点时间，特别是发布了RxJava 2.0后，我决定动笔开始。 现在RxJava变的越来越流行了，很多项目中都使用了它。特别是大神JakeWharton等的加入，以及RxBinding、Retrofit、RxLifecycle等众多项目的，然开发越来越方便，但是上手比较难，不过一旦你入门后你就会发现真是太棒了。 RxJava简介在介绍RxJava之前先说一下Rx。Rx的全称是Reactive Extensions，直译过来就是响应式扩展。 Rx基于观察者模式，它是一种编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。Rx已经渗透到了各个语言中，有了Rx所以才有了RxJava、Rx.NET、RxJS、RxSwift、Rx.rb、RxPHP等等， 这里先列举一下相关的官网: Rx RxJava RxAndroid RxJava在GitHub上的介绍是：a library for composing asynchronous and event-based programs by using observable sequences for the Java VM.翻译过来也就是一个基于事件和程序在Java VM上使用可观测的序列来组成异步的库。RxJava的本质就是一个实现异步操作的库，它的优势就是简洁，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 其实一句话总结一下RxJava的作用就是：异步 这里可能会有人想不就是个异步吗，至于辣么矫情么?用AsyncTask、Handler甚至自定义一个BigAsyncTask分分钟搞定。 但是RxJava的好处是简洁。异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android创造的AsyncTask和Handler其实都是为了让异步代码更加简洁。虽然RxJava的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 ####扩展的观察者模式 RxJava的异步实现，是通过一种扩展的观察者模式来实现的。 观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如A不需要每过2ms就检查一次B的状态），而是采用注册(Register)或者称为订阅(Subscribe)的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android开发中一个比较典型的例子是点击监听器OnClickListener。对设置OnClickListener来说，View是被观察者，OnClickListener是观察者，二者通过 setOnClickListener()方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework就会将点击事件发送给已经注册的OnClickListener。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷『你在作案的时候务必通知我』。 OnClickListener的模式大致如下图： 如图所示，通过setOnClickListener()方法，Button持有OnClickListener的引用（这一过程没有在图上画出）；当用户点击时，Button自动调用OnClickListener的onClick() 方法。另外，如果把这张图中的概念抽象出来（Button -&gt; 被观察者、OnClickListener -&gt; 观察者、setOnClickListener() -&gt; 订阅，onClick() -&gt; 事件），就由专用的观察者模式（例如只用于监听控件点击）转变成了通用的观察者模式。如下图： 而RxJava作为一个工具库，使用的就是通用形式的观察者模式。 ####RxJava的观察者模式 RxJava的基本概念： Observable(可观察者，即被观察者)、 Observer(观察者)、 subscribe()(订阅)、事件。 Observable和Observer通过subscribe() 方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer。 与传统观察者模式不同，RxJava的事件回调方法除了普通事件onNext()(相当于onClick()/onEvent())之外，还定义了两个特殊的事件：onCompleted()和onError():但是RxJava与传统的观察者设计模式有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。 onCompleted(): 事件队列完结。 RxJava不仅把每个事件单独处理，还会把它们看做一个队列。RxJava规定，当不会再有新的onNext()发出时，需要触发onCompleted() 方法作为标志。 onError(): 事件队列异常。 在事件处理过程中出异常时，onError()会被触发，同时队列自动终止，不允许再有事件发出。 在一个正确运行的事件序列中, onCompleted()和onError()有且只有一个，并且是事件序列中的最后一个。需要注意的是onCompleted()和onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 RxJava的观察者模式大致如下图： ####基本实现 基于上面的概念， RxJava的基本实现主要有三点: 创建Observable Observable即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava使用Observable.create()方法来创建一个Observable，并为它定义事件触发规则。 创建Observer即观察者，它决定事件触发的时候将有怎样的行为。 RxJava中的Observer接口的实现方式: 12345678910111213141516Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 除了Observer接口之外，RxJava还内置了一个实现了Observer的抽象类:Subscriber。Subscriber对Observer接口进行了一些扩展，但他们的基本使用方式是完全一样的。 12345678910111213141516Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 不仅基本使用方式一样，实质上，在RxJava的subscribe()过程中，Observer也总是会先被转换成一个Subscriber再使用。所以如果你只想使用基本功能，选择Observer和 Subscriber是完全一样的。它们的区别对于使用者来说主要有两点： onStart(): 这是Subscriber增加的方法。它会在subscribe()刚开始而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart()就不适用了，因为它总是在subscribe() 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用doOnSubscribe()方法，具体可以在后面的文中看到。 unsubscribe(): 这是Subscriber所实现的另一个接口Subscription的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用isUnsubscribed()先判断一下状态。 unsubscribe()这个方法很重要，因为在subscribe()之后,Observable会持有 Subscriber的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如onPause()、onStop()等方法中）调用unsubscribe()来解除引用关系，以避免内存泄露的发生。所以后续讲解时我们有时会用Subscriber来代替Observer。 调用subscribe()方法(订阅) 创建了一个Observable和Observer之后，再用subscribe()方法将它们联结起来，整条链子就可以工作了。代码形式很简单： 123observable.subscribe(observer); // 或者：observable.subscribe(subscriber); 有人可能会注意到，subscribe()这个方法有点怪：它看起来是observalbe订阅了observer/subscriber而不是observer/subscriber订阅了observalbe，这看起来就像『杂志订阅了读者』一样颠倒了对象关系。这让人读起来有点别扭，不过如果把API设计成observer.subscribe(observable)/subscriber.subscribe(observable) ，虽然更加符合思维逻辑，但对流式API的设计就造成影响了，比较起来明显是得不偿失的。 RxJava入门示例一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onComplete()或者Subscriber.onError()结束。 ####Hello World 1234compile &apos;io.reactivex:rxandroid:1.2.1&apos;// Because RxAndroid releases are few and far between, it is recommended you also// explicitly depend on RxJava&apos;s latest version for bug fixes and new features.compile &apos;io.reactivex:rxjava:1.2.3&apos; 1234567891011121314151617181920212223242526272829303132// 创建被观察者、数据源Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; // 可以看到，这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable //被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用三次 onNext() 和一次 // onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。 Log.i(\"@@@\", \"call\"); subscriber.onNext(\"Hello \"); subscriber.onNext(\"World !\"); subscriber.onCompleted(); &#125;&#125;);// 创建观察者Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(\"@@@\", \"onCompleted\"); &#125; @Override public void onError(Throwable e) &#123; Log.i(\"@@@\", \"onError\"); &#125; @Override public void onNext(String s) &#123; Log.i(\"@@@\", \"onNext : \" + s); &#125;&#125;;// 关联或者叫订阅更合适。observable.subscribe(subscriber); 一旦subscriber订阅了observable，observable就会调用subscriber对象的onNext和onComplete方法，subscriber就会打印出Hello World. Observable.subscribe(Subscriber)的内部实现是这样的（仅核心代码）： 123456// 注意：这不是`subscribe()`的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。public Subscription subscribe(Subscriber subscriber) &#123; subscriber.onStart(); onSubscribe.call(subscriber); return subscriber;&#125; 可以看到subscriber()做了3件事： 调用Subscriber.onStart()。这个方法在前面已经介绍过，是一个可选的准备方法。 调用Observable中的onSubscribe.call(Subscriber)。在这里，事件发送的逻辑开始运行。从这也可以看出，在RxJava中，Observable 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当subscribe()方法执行的时候。 将传入的Subscriber作为Subscription返回。这是为了方便unsubscribe(). 整个过程中对象间的关系如下图： 讲到这里很多人肯定会骂傻X,这TM简洁你妹啊…，这里只是个入门Hello World，真正的简洁等你看完全部介绍后就明白了。 RxJava内置了很多简化创建Observable对象的函数，比如Observable.just()就是用来创建只发出一个事件就结束的Observable对象，上面创建Observable对象的代码可以简化为一行 1Observable&lt;String&gt; observable = Observable.just(\"Hello \", \"World !\"); 接下来看看如何简化Subscriber，上面的例子中，我们其实并不关心onComplete()和onError，我们只需要在onNext的时候做一些处理，这时候就可以使用Action1类。 123456Action1&lt;String&gt; action1 = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(\"@@@\", \"call : \" + s); &#125;&#125;; Observable.subscribe()方法有一个重载版本，接受三个Action1类型的参数 所以上面的代码最终可以写成这样: 123456Observable.just(\"Hello \", \"World !\").subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(\"@@@\", \"call : \" + s); &#125;&#125;); 这里顺便多提一些subscribe()的多个Action参数：1234567891011121314151617181920212223Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; // onNext() @Override public void call(String s) &#123; Log.d(tag, s); &#125;&#125;;Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; // onError() @Override public void call(Throwable throwable) &#123; // Error handling &#125;&#125;;Action0 onCompletedAction = new Action0() &#123; // onCompleted() @Override public void call() &#123; Log.d(tag, \"completed\"); &#125;&#125;;observable.subscribe(onNextAction, onErrorAction, onCompletedAction); 简单解释一下这段代码中出现的Action1和Action0。Action0是RxJava的一个接口，它只有一个方法call()，这个方法是无参无返回值的；由于onCompleted() 方法也是无参无返回值的，因此Action0可以被当成一个包装对象，将onCompleted()的内容打包起来将自己作为一个参数传入subscribe()以实现不完整定义的回调。这样其实也可以看做将 onCompleted()方法作为参数传进了subscribe()，相当于其他某些语言中的『闭包』。Action1也是一个接口，它同样只有一个方法call(T param)，这个方法也无返回值，但有一个参数；与Action0同理，由于onNext(T obj)和onError(Throwable error)也是单参数无返回值的，因此Action1可以将onNext(obj)和onError(error)打包起来传入subscribe()以实现不完整定义的回调。事实上，虽然Action0和Action1在API中使用最广泛，但RxJava是提供了多个ActionX形式的接口(例如Action2, Action3)的，它们可以被用以包装不同的无返回值的方法。 假设我们的Observable是第三方提供的，它提供了大量的用户数据给我们，而我们需要从用户数据中筛选部分有用的信息，那我们该怎么办呢？从Observable中去修改肯定是不现实的？那从Subscriber中进行修改呢？ 这样好像是可以完成的。但是这种方式并不好，因为我们希望Subscriber越轻量越好，因为很有可能我们需要在主线程中去执行Subscriber。另外，根据响应式函数编程的概念，Subscribers更应该做的事情是响应，响应Observable发出的事件，而不是去修改。那该怎么办呢？ 这就要用到下面的部分要讲的操作符。 操作符(Operators)RxJava提供了对事件序列进行变换的支持，这是它的核心功能之一.所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。操作符就是为了解决对Observable对象的变换的问题，操作符用于在Observable和最终的Subscriber之间修改Observable发出的事件。RxJava提供了很多很有用的操作符。比如map操作符，就是用来把把一个事件转换为另一个事件的。 ####map Returns an Observable that applies a specified function to each item emitted by the source Observable and emits the results of these function applications. 12345678910111213Observable&lt;String&gt; just = Observable.just(\"Hello \", \"World !\");Observable&lt;String&gt; map = just.map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s + \"@@@\"; &#125;&#125;);map.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(\"@@@\", s); &#125;&#125;); 上面的代码打印出的结果是:1212-12 15:51:22.184 472-472/com.charon.rxjavastudydemo I/@@@: Hello @@@12-12 15:51:22.184 472-472/com.charon.rxjavastudydemo I/@@@: World !@@@ map()操作符就是用于变换Observable对象的，map操作符返回一个Observable对象，这样就可以实现链式调用，在一个Observable对象上多次使用map操作符，最终将最简洁的数据传递给Subscriber对象。 map操作符更有趣的一点是它不必返回Observable对象返回的类型，你可以使用map操作符返回一个发出新的数据类型的Observable对象。比如上面的例子中，Subscriber并不关心返回的字符串，而是想要字符串的hash值。 12345678910111213Observable&lt;String&gt; just = Observable.just(\"Hello \", \"World !\");Observable&lt;Integer&gt; map = just.map(new Func1&lt;String, Integer&gt;() &#123; @Override public Integer call(String s) &#123; return s.hashCode(); &#125;&#125;);map.subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(\"@@@\", \"\" + integer); &#125;&#125;); 上面部分的打印结果是:1212-12 15:54:35.515 8521-8521/com.charon.rxjavastudydemo I/@@@: -213706811412-12 15:54:35.516 8521-8521/com.charon.rxjavastudydemo I/@@@: -1105126669 map()的示意图： 通过上面的部分我们可以得知: Observable和Subscriber可以做任何事情 Observable可以是一个数据库查询，Subscriber用来显示查询结果；Observable可以是屏幕上的点击事件，Subscriber用来响应点击事件；Observable可以是一个网络请求，Subscriber用来显示请求结果。 Observable和Subscriber是独立于中间的变换过程的。 在Observable和Subscriber中间 可以增减任何数量的map。整个系统是高度可组合的，操作数据是一个很简单的过程。 ####flatmap Returns an Observable that emits items based on applying a function that you supply to each item emitted by the source Observable, where that function returns an Observable, and then merging those resulting Observables and emitting the results of this merger. flatMap()是一个很有用但非常难理解的变换，首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单： 12345678910111213141516Student[] students = ...;Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String name) &#123; Log.d(tag, name); &#125; ...&#125;;Observable.from(students) .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student student) &#123; return student.getName(); &#125; &#125;) .subscribe(subscriber); 很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢?(需求的区别在于，每个学生只有一个名字，但却有多个课程)首先可以这样实现： 1234567891011121314Student[] students = ...;Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() &#123; @Override public void onNext(Student student) &#123; List&lt;Course&gt; courses = student.getCourses(); for (int i = 0; i &lt; courses.size(); i++) &#123; Course course = courses.get(i); Log.d(tag, course.getName()); &#125; &#125; ...&#125;;Observable.from(students) .subscribe(subscriber); 依然很简单。那么如果我不想在Subscriber中使用for循环，而是希望Subscriber中直接传入单个的Course对象呢(这对于代码复用很重要),用map()显然是不行的，因为map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个Student转化成多个Course呢？ 这个时候，就需要用flatMap()了：12345678910111213141516Student[] students = ...;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123; @Override public void onNext(Course course) &#123; Log.d(tag, course.getName()); &#125; ...&#125;;Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(subscriber); map与flatmap在功能上是一致的,它也是把传入的参数转化之后返回另一个对象。区别在于flatmap是通过中间Observable来进行，而map是直接执行.flatMap()中返回的是个 Observable对象，并且这个Observable对象并不是被直接发送到了Subscriber的回调方法中。 flatMap()的原理是这样的: 使用传入的事件对象创建一个Observable对象 并不发送这个Observable而是将它激活，于是它开始发送事件 每一个创建出来的Observable发送的事件，都被汇入同一个Observable,而这个Observable负责将这些事件统一交给Subscriber 的回调方法。 这三个步骤，把事件拆成了两级，通过一组新创建的Observable将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是flatMap()所谓的flat。 flatMap()就是根据你的规则，将Observable转换之后再发射出去，注意最后的顺序很可能是错乱的，如果要保证顺序的一致性，要使用concatMap()由于可以在嵌套的Observable中添加异步代码flatMap()也常用于嵌套的异步操作，例如嵌套的网络请求(Retrofit + RxJava) flatMap()示意图： ####throttleFirst() 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤。例如按钮的点击监听器:123RxView.clickEvents(button); // RxBinding 代码` .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber); // 妈妈再也不怕我的用户手抖点开两个重复的界面啦。 ####from convert various other objects and data types into Observables from()接收一个集合作为输入，然后每次输出一个元素给subscriber. 1234567List&lt;String&gt; s = Arrays.asList(\"Java\", \"Android\", \"Ruby\", \"Ios\", \"Swift\");Observable.from(s).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(\"@@@\", s); &#125;&#125;); ####filter 返回满足过滤条件的数据。 12345678910111213Observable.from(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer &lt; 5; &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(\"@@@\", \"integer=\" + integer); //1,2,3,4 &#125; &#125;); ####timer Timer会在指定时间后发射一个数字0，该操作符运行在Computation Scheduler。 1234567Observable.timer(3, TimeUnit.SECONDS).observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.i(\"@@@\", \"aLong=\" + aLong); // 延时3s &#125; &#125;); ####interval 创建一个按固定时间间隔发射整数序列的Observable.interval默认在computation调度器上执行。 1234567Observable.interval(1, TimeUnit.SECONDS, AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.i(\"@@@\", \"aLong=\" + aLong); //从0递增，间隔1s 0,1,2,3.... &#125; &#125;); ####Repeat 重复执行 等等…就不继续介绍了，到时候查下文档就好了。 是不是感觉没什么乱用，那就继续看下一部分吧。 更多内容请看下一篇文章RxJava详解(下).md) 参考: RxJava Wiki Grokking RxJava, Part 1: The Basics NotRxJava When Not to Use RxJava 给 Android 开发者的 RxJava 详解 Google Agera 从入门到放弃 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Zipalign优化","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Zipalign优化/","text":"Zipalign优化Zipalign优化工具是SDK中自带的优化工具,在android-sdk-windows\\build-tools\\23.0.1，在我们上传Google Pay的时候都会遇到您上传的Apk没有经过Zipalign处理的失败提示，就是说如果你的apk没有使用zipalign优化，那google play是拒绝给你上架的，从这里能看出zipalign优化是多么滴重要。 12345zipalign is an archive alignment tool that provides important optimization to Android application (.apk) files. The purpose is to ensure that all uncompressed data starts with a particular alignment relative to the start of the file. Specifically, it causes all uncompressed data within the .apk, such as images or raw files, to be aligned on 4-byte boundaries. This allows all portions to be accessed directly with mmap() even if they contain binary data with alignment restrictions. The benefit is a reduction in the amount of RAM consumed when running the application. 123456Caution: zipalign must only be performed after the .apk file has been signed with your private key. If you perform zipalign before signing, then the signing procedure will undo the alignment. Also, do not make alterations to the aligned package. Alterations to the archive, such as renaming or deleting entries, will potentially disrupt the alignment of the modified entry and all later entries. And any files added to an &quot;aligned&quot; archive will not be aligned. 大意就是它提供了一个灰常重要滴功能来确保所有未压缩的数据都从文件的开始位置以指定的4字节对齐方式排列，例如图片或者raw文件。当然好处也是大大的，就是能够减少内存的资源消耗。最后他还特意提醒了你一下就是已经在对apk签完名之后再用zipalign优化，如果你在之前用，那无效。 废多看用法: 首先我要检查下我的apk到底用没用过zipalign优化呢? zipalign -c -v 4 test.apk 这个4是神马呢？就是４个字节的队列方式 命令一顿执行，然后打出来了Verification failed，我不想再解释了。 如何使用?zipalign -f -v 4 test.apk zip.apk就是把当前的test.apk使用zipalign优化，优化完成后的是zip.apk Flag: -f : overwrite existing outfile.zip -v : verbose output -c : confirm the alignment of the given file 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android Touch事件分发详解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Android Touch事件分发详解/","text":"Android Touch事件分发详解先说一些基本的知识，方便后面分析源码时能更好理解。 所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、历史记录、第几个手指等. 事件类型分为ACTION_DOWN,ACTION_UP,ACTION_MOVE,ACTION_POINTER_DOWN,ACTION_POINTER_UP,ACTION_CANCEL, 每个一个完整的事件以ACTION_DOWN开始ACTION_UP结束，并且ACTION_CANCEL只能由代码引起.一般对于CANCEL的处理和UP的相同。CANCEL的一个简单例子：手指在移动的过程中突然移动到了边界外，那么这时ACTION_UP事件了，所以这是的CANCEL和UP的处理是一致的。 事件的处理分别为dispatchTouchEveent()分发事件(TextView等这种最小的View中不会有该方式)、onInterceptTouchEvent()拦截事件(ViewGroup中拦截事件)、onTouchEvent()消费事件. 事件从Activity.dispatchTouchEveent()开始传递，只要没有停止拦截，就会从最上层(ViewGroup)开始一直往下传递，子View通过onTouchEvent()消费事件。(隧道式向下分发). 如果时间从上往下一直传递到最底层的子View，但是该View没有消费该事件，那么该事件会反序网上传递(从该View传递给自己的ViewGroup，然后再传给更上层的ViewGroup直至传递给Activity.onTouchEvent()).(冒泡式向上处理). 如果View没有消费ACTION_DOWN事件，之后其他的MOVE、UP等事件都不会传递过来. 事件由父View(ViewGroup)传递给子View,ViewGroup可以通过onInterceptTouchEvent()方法对事件进行拦截，停止其往下传递，如果拦截(返回true)后该事件会直接走到该ViewGroup中的onTouchEvent()中，不会再往下传递给子View.如果从DOWN开始，之后的MOVE、UP都会直接在该ViewGroup.onTouchEvent()中进行处理。如果子View之前在处理某个事件，但是后续被ViewGroup拦截，那么子View会接收到ACTION_CANCEL. OnTouchListener优先于onTouchEvent()对事件进行消费。 TouchTarget是保存手指点击区域属性的一个类，手指的所有移动过程都会被它记录下来, 包含被touch的View。 废话不多说，直接上源码，源码妥妥的是最新版5.0：我们先从Activity.dispatchTouchEveent()说起： 12345678910111213141516171819/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 代码一看能感觉出来DOWN事件比较特殊。我们继续走到onUserInteraction()代码中.123456789101112131415161718192021/** * Called whenever a key, touch, or trackball event is dispatched to the * activity. Implement this method if you wish to know that the user has * interacted with the device in some way while your activity is running. * This callback and &#123;@link #onUserLeaveHint&#125; are intended to help * activities manage status bar notifications intelligently; specifically, * for helping activities determine the proper time to cancel a notfication. * * &lt;p&gt;All calls to your activity's &#123;@link #onUserLeaveHint&#125; callback will * be accompanied by calls to &#123;@link #onUserInteraction&#125;. This * ensures that your activity will be told of relevant user activity such * as pulling down the notification pane and touching an item there. * * &lt;p&gt;Note that this callback will be invoked for the touch down action * that begins a touch gesture, but may not be invoked for the touch-moved * and touch-up actions that follow. * * @see #onUserLeaveHint() */public void onUserInteraction() &#123;&#125; 但是该方法是空方法，没有具体实现。 我们往下看getWindow().superDispatchTouchEvent(ev).getWindow()获取到当前Window对象，表示顶层窗口，管理界面的显示和事件的响应；每个Activity 均会创建一个PhoneWindow对象，是Activity和整个View系统交互的接口，但是该类是一个抽象类。从文档中可以看到The only existing implementation of this abstract class is android.policy.PhoneWindow, which you should instantiate when needing a Window.，所以我们找到PhoneWindow类，查看它的superDispatchTouchEvent()方法。1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 该方法又是调用了mDecor.superDispatchTouchEvent(event), mDecor是什么呢？ 从名字中我们大概也能猜出来是当前窗口最顶层的DecorView，Window界面的最顶层的View对象。12// This is the top-level view of the window, containing the window decor.private DecorView mDecor; 讲到这里不妨就提一下DecorView.123private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123; ...&#125; 它集成子FrameLayout所有很多时候我们在用布局工具查看的时候发现Activity的布局FrameLayout的。就是这个原因。好了，我们接着看DecorView中的superDispatchTouchEvent()方法。123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125; 是调用了super.dispatchTouchEveent()，而DecorView的父类是FrameLayout所以我们找到FrameLayout.dispatchTouchEveent().我们看到FrameLayout中没有重写dispatchTouchEveent()方法，所以我们再找到FrameLayout的父类ViewGroup.看ViewGroup.dispatchTouchEveent()实现。新大陆浮现了…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314/** * &#123;@inheritDoc&#125; */@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; // Consistency verifier for debugging purposes.是调试使用的，我们不用管这里了。 if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; boolean handled = false; // onFilterTouchEventForSecurity()用安全机制来过滤触摸事件，true为不过滤分发下去，false则销毁掉该事件。 // 方法具体实现是去判断是否被其它窗口遮挡住了，如果遮挡住就要过滤掉该事件。 if (onFilterTouchEventForSecurity(ev)) &#123; // 没有被其它窗口遮住 final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // 下面这一块注释说的很清楚了，就是在`Down`的时候把所有的状态都重置，作为一个新事件的开始。 // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); // 如果是`Down`，那么`mFirstTouchTarget`到这里肯定是`null`.因为是新一系列手势的开始。 // `mFirstTouchTarget`是处理第一个事件的目标。 &#125; // 检查是否拦截该事件(如果`onInterceptTouchEvent()`返回true就拦截该事件) // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; // 标记事件不允许被拦截， 默认是`false`， 该值可以通过`requestDisallowInterceptTouchEvent(true)`方法来设置， // 通知父`View`不要拦截该`View`上的事件。 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; // 判断该`ViewGroup`是否要拦截该事件。`onInterceptTouchEvent()`方法默认返回`false`即不拦截。 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; // 子`View`通知父`View`不要拦截。这样就不会走到上面`onInterceptTouchEvent()`方法中了， // 所以父`View`就不会拦截该事件。 intercepted = false; &#125; &#125; else &#123; // 注释比较清楚了，就是没有目标来处理该事件，而且也不是一个新的事件`Down`事件(新事件的开始), // 我们应该拦截下他。 // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // Check for cancelation.检查当前是否是`Cancel`事件或者是有`Cancel`标记。 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. 这行代码为是否需要将当前的触摸事件分发给多个子`View`， // 默认为`true`，分发给多个`View`（比如几个子`View`位置重叠）。默认是true final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; // 保存当前要分发给的目标 TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; // 如果没取消也不拦截，进入方法内部 if (!canceled &amp;&amp; !intercepted) &#123; // 下面这部分代码的意思其实就是找到该事件位置下的`View`(可见或者是在动画中的View), 并且与`pointID`关联。 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); // 遍历找子`View`进行分发了。 final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // `canViewReceivePointerEvents()`方法会去判断这个`View`是否可见或者在播放动画， // 只有这两种情况下可以接受事件的分发 // `isTransformedTouchPointInView`判断这个事件的坐标值是否在该`View`内。 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; continue; &#125; // 找到该`View`对应的在`mFristTouchTarget`中的存储的目标， 判断这个`View`可能已经不是之前`mFristTouchTarget`中的`View`了。 // 如果找不到就返回null, 这种情况是用于多点触摸， 比如在同一个`View`上按下了多跟手指。 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child View已经接受了这个事件了 // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; // 找到该View了，不用再循环找了 break; &#125; resetCancelNextUpFlag(child); // 如果上面没有break，只有newTouchTarget为null，说明上面我们找到的Child View和之前的肯定不是同一个了， // 是新增的， 比如多点触摸的时候，一个手指按在了这个`View`上，另一个手指按在了另一个`View`上。 // 这时候我们就看child是否分发该事件。dispatchTransformedTouchEvent如果child为null，就直接该ViewGroup出来事件 // 如果child不为null，就调用child.dispatchTouchEvent if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // 如果这个Child View能分发，那我们就要把之前存储的值改变成现在的Child View。 // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); // 赋值成现在的Child View对应的值，并且会把`mFirstTouchTarget`也改成该值(mFristTouchTarget`与`newTouchTarget`是一样的)。 newTouchTarget = addTouchTarget(child, idBitsToAssign); // 分发给子`View`了，不用再继续循环了 alreadyDispatchedToNewTouchTarget = true; break; &#125; &#125; if (preorderedList != null) preorderedList.clear(); &#125; // `newTouchTarget == null`就是没有找到新的可以分发该事件的子`View`，那我们只能用上一次的分发对象了。 if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // DOWN事件在上面会去找touch target // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // dispatchTransformedTouchEvent方法中如果child为null，那么就调用super.dispatchTouchEvent(transformedEvent);否则调用child.dispatchTouchEvent(transformedEvent)。 // `super.dispatchTouchEvent()`也就是说，此时`Viewgroup`处理`touch`消息跟普通`view`一致。普通`View`类内部会调用`onTouchEvent()`方法 // No touch targets so treat this as an ordinary view. 自己处理 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // 分发 // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; // 找到了新的子`View`，并且这个是新加的对象，上面已经处理过了。 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; // 否则都调用dispatchTransformedTouchEvent处理，传递给child final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; // 正常分发 if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; // 如果是onInterceptTouchEvent返回true就会遍历mFirstTouchTarget全部给销毁，这就是为什么onInterceptTouchEvent返回true，之后所有的时间都不会再继续分发的了。 if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; // 当某个手指抬起的时候，清除他相关的数据。 final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled;&#125;``` 接下来还要说说`dispatchTransformedTouchEvent()`方法，虽然上面也说了大体功能，但是看一下源码能说明另一个问题： ```java/** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); // 这就是为什么时间被拦截之后，之前处理过该事件的`View`会收到`CANCEL`. if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; // 子`View`去处理，如果子`View`仍然是`ViewGroup`那还是同样的处理，如果子`View`是普通`View`，普通`View`的`dispatchTouchEveent()`会调用`onTouchEvent()`. handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) &#123; return false; &#125; // If the number of pointers is the same and we don't need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // Perform any necessary transformations and dispatch. if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled;&#125; 上面讲了ViewGroup的dispatchTouchEveent()有些地方会调用super.dispatchTouchEveent()，而ViewGroup的父类就是View，接下来我们看一下View.dispatchTouchEveent()方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */public boolean dispatchTouchEvent(MotionEvent event) &#123; boolean result = false; // 调试用 if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; // 判断该`View`是否被其它`View`遮盖住。 if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; // 先执行`listener`. result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; // 执行`onTouchEvent()`. result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; 通过上面的分析我们看到View.dispatchTouchEvent()里面会调用到onTouchEvent()来消耗事件。那么onTouchEvent()是如何处理的呢？下面我们看一下View.onTouchEvent()源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/** * Implement this method to handle touch screen motion events. * &lt;p&gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * &#123;@link #performClick()&#125;. This will ensure consistent system behavior, * including: * &lt;ul&gt; * &lt;li&gt;obeying click sound preferences * &lt;li&gt;dispatching OnClickListener calls * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when * accessibility features are enabled * &lt;/ul&gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; // 对disable按钮的处理，注释说的比较明白，一个disable但是clickable的view仍然会消耗事件,只是不响应而已。 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; // 关于TouchDelegate,文档中是这样说的The delegate to handle touch events that are physically in this view // but should be handled by another view. 就是说如果两个View, View2在View1中，View1比较大，如果我们想点击 // View1的时候，让View2去响应点击事件，这时候就需要使用TouchDelegate来设置。 // 简单的理解就是如果这个View有自己的时间委托处理人，就交给委托人处理。 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; // 这个View可点击 switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: // 最好先看DOWN后再看MOVE最后看UP。 // PFLAG_PREPRESSED 表示在一个可滚动的容器中,要稍后才能确定是按下还是滚动. // PFLAG_PRESSED 表示不是在一个可滚动的容器中,已经可以确定按下这一操作. boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // 处理点击或长按事件 // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) // 如果现在还没获取到焦点，就再获取一次焦点 focusTaken = requestFocus(); &#125; // 在前面`DOWN`事件的时候会延迟显示`View`的`pressed`状态,用户可能在我们还没有显示按下状态效果时就不按了.我们还是得在进行实际的点击操作时,让用户看到效果。 if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress) &#123; // 判断不是长按 // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; // PerformClick就是个Runnable,里面执行performClick()方法。performClick()方法中怎么执行呢？我们在后面再说。 if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; // 取消按下状态，UnsetPressedState也是个Runnable,里面执行setPressed(false) if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; // performButtonActionOnTouchDown()处理鼠标右键菜单，有些View显示右键菜单就直接弹菜单.一般设备用不到鼠标，所以返回false。 if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. // 就是遍历下View层级，判断这个View是不是在一个能scroll的View中。 if (isInScrollingContainer) &#123; // 因为用户可能是点击或者是滚动，所以我们不能立马判断，先给用户设置一个要点击的事件。 mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); // 发送一个延时的操作，用于判断用户到底是点击还是滚动。其实就是在tapTimeout中如果用户没有滚动，那就是点击了。 postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // 设置成点击状态 // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); // 检查是否是长按，就是过一段时间后如果还在按住，那就是长按了。长按的时间是ViewConfiguration.getLongPressTimeout() // 也就是500毫秒 checkForLongClick(0); &#125; break; case MotionEvent.ACTION_CANCEL: // 取消按下状态，移动点击消息，移动长按消息。 setPressed(false); removeTapCallback(); removeLongPressCallback(); break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons， 检查是否移动到View外面了。 if (!pointInView(x, y, mTouchSlop)) &#123; // 移动到区域外面去了，就要取消点击。 // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false;&#125; 上面讲了Touch事件的分发和处理，随便说一下点击事件:我们平时使用的时候都知道给View设置点击事件是setOnClickListener()123456789101112131415/** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */public void setOnClickListener(OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; // `getListenerInfo()`就是判断成员变量`mListenerInfo`是否是null，不是就返回，是的话就初始化一个。 getListenerInfo().mOnClickListener = l;&#125; 那什么地方会调用mListenerInfo.mOnClickListener呢？12345678910111213141516171819202122/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 讲到这里就明白了。onTouchEvent()中的ACTION_UP中会调用performClick()方法。 到这里，就全部分析完了，这一块还是比较麻烦的，中间查了很多资料，有些地方自己可能也理解的不太对，如果有哪里理解的不对的地方，还请大家指出来。谢谢。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"volley-retrofit-okhttp之我们该如何选择网路框架","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/volley-retrofit-okhttp之我们该如何选择网路框架/","text":"volley-retrofit-okhttp之我们该如何选择网路框架说起Volley、Retrofit、OkHttp相信基本没有人不知道。当然这里把OkHttp放进来可能有些不恰当。因为OkHttp的官方介绍是An HTTP+HTTP/2 client for Android and Java applications。也就是说OkHttp是基于http协议封装的一套请求客户端。它是真正的网络请求部分，与HttpClient、HttpUrlConnection是一样的，但是显然它的效率非常高(说到这里顺便提一嘴，从Android 4.4开始HttpUrlConnection内部默认使用的也是OkHttp，具体请参考之前的文章HttpUrlConnection详解)。而Volley、Retrofit是控制请求的队列、切换、解析、缓存等逻辑。所以Volley和Retrofit都可以结合OkHttp来使用。 在Android开发中有很多网络请求框架，但是比较过来比较过去，最后最倾向的就是这两个: Volley:Google发布的网络请求框架，专门为移动设备定制，小而美。 Retrofit:良心企业 Square由大神JakeWharton主导的开源项目,是基于OkHttp封装的一套Resetful网络请求框架。Type-safe HTTP client for Android and Java by Square, Inc. 有关Volley的介绍请看之前发布的文章Volley源码分析 这里就不分别介绍他俩了，直接说各自的优缺点: Retrofit使用起来更简单。而Volley配置起来会稍微麻烦，因为Volley可以使用HttpClient、HttpUrlConnection、OkHttp我们需要根据自己的需求去配置。而Retrofit只能结合OkHttp使用。 Retrofit依赖于OkHttp，从而会导致它的包大小会比Volley的大。 Volley有很好的内存缓存管理，它在解析之前会将整个相应部分都加载到内存中，所以它对于小的网络请求非常合适，但是不支持post大数据，所以不适合上传文件。而Retrofit使用的是硬盘缓存，所以相比起从缓存这块来讲Retrofit可能会更慢一些。 Retrofit依赖于OkHttp，而OkHttp自身会避免同时两次请求同一个请求。所以Retrofit同样会和Volley一样去避免重复的请求，只不过它是在网络层来处理的。 Volley在网络请求部分默认依赖于Apache HttpClient。而Apache HttpClient从API 23开始已经在Android中被移除并废弃了。这就是为什么很多开发者会认为Volley已经过时了，因为Volley并没有迁移到新的未废弃的代码。 默认情况下Volley会在DefaultRetryPolicy中会将读取和连接的超时时间设置为2.5s，并且对每次请求失败或者超时都有一次自动重试。 所以对于一些服务器响应可能会超过2s的请求，开发者需要格外的小心下。Retrofit的默认超时时间是10s，而且它对失败或者超时的操作不会自动重试。 很多开发者都会说Retrofit会比Volley更快。因为有人专门去测试过，其实这里是不严谨的。因为Volley可以结合使用HttpUrlConnection、HttpClient、OkHttp等来使用，而Retrofit是用OkHttp一起，所以如果你让Volley结合OkHttp之后再来测试你就会发现总体来说其实他们不相上下。 Volley实现了很完善的Activity声明周期管理。 虽然Volley之前也有一些问题，但是它们也都被各个大神修复。 所以综合起来说使用Volley+OKHttp的组合是非常不错的，既可以保证速度又可以满足对缓存、重试等的处理。但是如果你是RxJava的使用者那你可能会更偏向于使用Retrofit，因为Retrofit可以无缝结合RxJava使用。目前主流的一套框架就是Retrofit + OkHttp + RxJava + Dagger2，但是对使用者的要求也相对要高些。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"AndroidStudio中进行ndk开发","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/AndroidStudio中进行ndk开发/","text":"AndroidStudio中进行ndk开发 创建工程，声明native方法。 12345private native void startDaemon(String serviceName, int sdkVersion); static &#123; System.loadLibrary(\"daemon\"); &#125; 生成class文件。 执行Build-Make Project命令，生成class文件。所在目录为app_path/build/intermediates/classes/debug 执行javah生成.h文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 C:\\Users\\Administrator&gt;javah -help 用法: javah [options] &lt;classes&gt; 其中, [options] 包括: -o &lt;file&gt; 输出文件 (只能使用 -d 或 -o 之一) -d &lt;dir&gt; 输出目录 -v -verbose 启用详细输出 -h --help -? 输出此消息 -version 输出版本信息 -jni 生成 JNI 样式的标头文件 (默认值) -force 始终写入输出文件 -classpath &lt;path&gt; 从中加载类的路径 -cp &lt;path&gt; 从中加载类的路径 -bootclasspath &lt;path&gt; 从中加载引导类的路径 ``` 在`Studio Terminal`中进入到`src/main`目录下执行`javah`命令: `javah -d jni -classpath &lt;SDK_android.jar&gt;;&lt;APP_classes&gt; &lt;class&gt;` `F:\\DaemonService\\app\\src\\main&gt;javah -d jni -classpath C:\\develop\\android-sdk-windows\\platforms\\android-22\\android.jar;..\\..\\build\\intermediates\\classes\\debug com.charonchui.daemonservice.service.DaemonService` 执行完成后就会在`src/main/jni`目录下生成`com_charonchui_daemonservice_service_DaemonService.h`文件。- 在`module/src/main/jni`目录下创建对应的`.c`文件。- 配置`ndk`路径，在项目右键`Moudle Setting`中设置。 ![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/studio_ndk_jni.png?raw=true) - 在`build.gradle`中配置`ndk`选项 ```java android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.1&quot; defaultConfig &#123; applicationId &quot;com.charonchui.daemonservice&quot; minSdkVersion 8 targetSdkVersion 23 versionCode 1 versionName &quot;1.0&quot; ndk &#123; moduleName &quot;uninstall_feedback&quot; // 配置so名字 ldLibs &quot;log&quot; // abiFilters &quot;armeabi&quot;, &quot;x86&quot; // 默认就是全部的，加了配置才会生成选中的 &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125; &#125; 这里可能会出现错误: Error: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental. Set &quot;android.useDeprecatedNdk=true&quot; in gradle.properties to continue using the current NDK integration. 解决方法就是在gradle.properties文件中添加android:useDeprecatedNdk=true就可以了。 `Error:Execution failed for task ‘:app:compileDebugNdk’. com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process ‘command ‘E:\\android-ndk-r10\\ndk-build.cmd’’ finished with non-zero exit value 2解决方法就是在jni目录建一个任意名字的.c`空文件就可以了。 执行Build 然后就可以在app/build/intermediates/ndk/debug/obj/local下看到所有架构的so了。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"AndroidStudio提高Build速度","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/AndroidStudio提高Build速度/","text":"AndroidStudio提高Build速度Android Studio自动发布以来，凭借其强大的功能，很快让开发者都投入到它的阵营下。但是也问题，就是Build速度太慢了。 之前也根据网上的资料，修改了一些配置，但是一次二分多种有时候还是让人抓狂。今天索性记录一下。首先看一下Google+关于该问题的讨论。 使用daemon及parallel模式 在下面的目录中创建一个名为gradle.properties的文件: /home/&lt;username&gt;/.gradle/ (Linux) /Users/&lt;username&gt;/.gradle/ (Mac) C:\\Users\\&lt;username&gt;\\.gradle (Windows) 文件的内容为: 12org.gradle.daemon=trueorg.gradle.parallel=true 经过上面的这一步修改是对所有工程都有效果的，如果你只想对某一个工程配置的话，那就在该工程目录下的`gralde.properties`中进行配置。 123456789101112131415161718# Project-wide Gradle settings.# IDE (e.g. Android Studio) users:# Gradle settings configured through the IDE *will override*# any settings specified in this file.# For more details on how to configure your build environment visit# http://www.gradle.org/docs/current/userguide/build_environment.html# Specifies the JVM arguments used for the daemon process.# The setting is particularly useful for tweaking memory settings.# Default value: -Xmx10248m -XX:MaxPermSize=256m# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8# When configured, Gradle will run in incubating parallel mode.# This option should only be used with decoupled projects. More details, visit# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects# org.gradle.parallel=true 打开时默认如上。我们给加添加上面的配置就好。 当然你也可以通过`Studio`的设置中进行修改。 ![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/studio_speed.png?raw=true) 使用offline模式 下一步就是开始offline模式，因为我们经常会在gradle中使用一下依赖库时用+这样的话就能保证你的依赖库是最新的版本，但是这样在每次build的时候都会去检查是不是最新的版本，所以就会耗时。 在开发过程中是不建议使用动态版本的，在Studio中使用动态版本的gradle中间中使用ALT+ENTER键进行修复。 详细有关为什么不要使用动态版本的介绍，请参考Don’t use dynamic versions for your dependencies 增加内存使用SSD 首先是增大内存, Mac中在Applications中找到Sutio然后右键显示包内容Contents/bin/studio.vmoptions。 打开该文件后修改就可以了，我是的是: 1234567891011## *DO NOT* modify this file directly. If there is a value that you would like to override,# please add it to your user specific configuration file.## See http://tools.android.com/tech-docs/configuration#-Xms1024m-Xmx4096m-XX:MaxPermSize=768m-XX:ReservedCodeCacheSize=768m-XX:+UseCompressedOops 我没看见DO NOT的提示- -! Xms 是JVN启动起始时的堆内存，堆内存是分配给对象的内容。 Xmx 是能使用的最大堆内存。 使用Instant Run Instantt Run放在这里说可能不合适，但是用他确实能大大的减少运行时间。 如果还不了解的话可以参考Instant Run 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"butterknife源码详解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/butterknife源码详解/","text":"butterknife源码详解作为Android开发者，大家肯定都知道大名鼎鼎的butterknife。它大大的提高了开发效率，虽然在很早之前就开始使用它了，但是只知道是通过注解的方式实现的，却一直没有仔细的学习下大牛的代码。最近在学习运行时注解，决定今天来系统的分析下butterknife的实现原理。 如果你之前不了解Annotation，那强烈建议你先看注解使用. 废多看图: 从图中可以很直观的看出它的module结构，以及使用示例代码。 它的目录和我们在注解使用这篇文章中介绍的一样，大体也是分为三个部分: app : butterknife api : butterknife-annotations compiler : butterknife-compiler 通过示例代码我们大体能预料到对应的功能实现: @BindView(R2.id.hello) Button hello; BindView注解的作用就是通过value指定的值然后去调用findViewById()来找到对应的控件，然后将该控件赋值给使用该注解的变量。 @OnClick(R2.id.hello) void sayHello() {...} OnClick注解也是通过指定的id来找到对应控件后，然后对其设置onClickListener并调用使用该注解的方法。 最后不要忘了ButterKnife.bind(this);该方法也是后面我们要分析的突破点。 当然Butterknife的功能是非常强大的，我们在这里只是用这两个简单的例子来进行分析说明。 那我们就来查看BindView和Onclik注解的源码:12345@Retention(CLASS) @Target(FIELD)public @interface BindView &#123; /** View ID to which the field will be bound. */ @IdRes int value();&#125; 作用在变量上的编译时注解。对该注解的值value()使用android.support.annotation中的IdRes注解，来表明该值只能是资源类型的id。 123456789101112131415@Target(METHOD)@Retention(CLASS)@ListenerClass( targetType = \"android.view.View\", setter = \"setOnClickListener\", type = \"butterknife.internal.DebouncingOnClickListener\", method = @ListenerMethod( name = \"doClick\", parameters = \"android.view.View\" ))public @interface OnClick &#123; /** View IDs to which the method will be bound. */ @IdRes int[] value() default &#123; View.NO_ID &#125;;&#125; 作用到方法上的编译时注解。我们发现该注解还使用了ListenerClass注解，当然从上面的声明中可以很容易看出它的作用。 那我们就继续简单的看一下ListenerClass`注解的实现: 12345678910111213141516171819202122232425262728@Retention(RUNTIME) @Target(ANNOTATION_TYPE)public @interface ListenerClass &#123; String targetType(); /** Name of the setter method on the &#123;@linkplain #targetType() target type&#125; for the listener. */ String setter(); /** * Name of the method on the &#123;@linkplain #targetType() target type&#125; to remove the listener. If * empty &#123;@link #setter()&#125; will be used by default. */ String remover() default \"\"; /** Fully-qualified class name of the listener type. */ String type(); /** Enum which declares the listener callback methods. Mutually exclusive to &#123;@link #method()&#125;. */ Class&lt;? extends Enum&lt;?&gt;&gt; callbacks() default NONE.class; /** * Method data for single-method listener callbacks. Mutually exclusive with &#123;@link #callbacks()&#125; * and an error to specify more than one value. */ ListenerMethod[] method() default &#123; &#125;; /** Default value for &#123;@link #callbacks()&#125;. */ enum NONE &#123; &#125;&#125; 作用到注解类型的运行时注解。 有了之前注解使用这篇文章的基础，我们知道对于编译时注解肯定是要通过自定义AbstractProcessor来解析的，所以接下来我们要去butterknife-compiler module中找一下对应的类。通过名字我们就能很简单的找到:123456package butterknife.compiler;@AutoService(Processor.class)public final class ButterKnifeProcessor extends AbstractProcessor &#123; ...&#125; 通过AutoService注解我们很容易看出来Butterknife也使用了Google Auto。当然它肯定也都用了javaopet和android-apt，这里我们就不去分析了。其他的一些方法我们就不继续看了，我们接下来看一下具体的核心处理方法，也就是ButterKnifeProcessor.process()方法:1234567891011121314151617181920@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123; // 查找、解析出所有的注解 Map&lt;TypeElement, BindingClass&gt; targetClassMap = findAndParseTargets(env); // 将注解后要生成的相关代码信息保存到BindingClass类中 for (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingClass bindingClass = entry.getValue(); // 输出生成的类 for (JavaFile javaFile : bindingClass.brewJava()) &#123; try &#123; javaFile.writeTo(filer); &#125; catch (IOException e) &#123; error(typeElement, \"Unable to write view binder for type %s: %s\", typeElement, e.getMessage()); &#125; &#125; &#125; return true; &#125; 从process()方法来看，我们需要主要分析两个部分: findAndParseTargets()：查找、解析所有的注解 bindingClass.brewJava()：生成代码 #####第一步:findAndParseTargets() 先查看findAndParseTargets()方法的实现,里面解析的类型比较多，我们就以BindView为例进行说明:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125private Map&lt;TypeElement, BindingClass&gt; findAndParseTargets(RoundEnvironment env) &#123; Map&lt;TypeElement, BindingClass&gt; targetClassMap = new LinkedHashMap&lt;&gt;(); Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;(); scanForRClasses(env); // Process each @BindArray element. for (Element element : env.getElementsAnnotatedWith(BindArray.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceArray(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindArray.class, e); &#125; &#125; // Process each @BindBitmap element. for (Element element : env.getElementsAnnotatedWith(BindBitmap.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceBitmap(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindBitmap.class, e); &#125; &#125; // Process each @BindBool element. for (Element element : env.getElementsAnnotatedWith(BindBool.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceBool(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindBool.class, e); &#125; &#125; // Process each @BindColor element. for (Element element : env.getElementsAnnotatedWith(BindColor.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceColor(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindColor.class, e); &#125; &#125; // Process each @BindDimen element. for (Element element : env.getElementsAnnotatedWith(BindDimen.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceDimen(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindDimen.class, e); &#125; &#125; // Process each @BindDrawable element. for (Element element : env.getElementsAnnotatedWith(BindDrawable.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceDrawable(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindDrawable.class, e); &#125; &#125; // Process each @BindInt element. for (Element element : env.getElementsAnnotatedWith(BindInt.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceInt(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindInt.class, e); &#125; &#125; // Process each @BindString element. for (Element element : env.getElementsAnnotatedWith(BindString.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceString(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindString.class, e); &#125; &#125; // Process each @BindView element. for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123; // 检查一下合法性 if (!SuperficialValidation.validateElement(element)) continue; try &#123; // 进行解析 parseBindView(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindView.class, e); &#125; &#125; // Process each @BindViews element. for (Element element : env.getElementsAnnotatedWith(BindViews.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseBindViews(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindViews.class, e); &#125; &#125; // Process each annotation that corresponds to a listener. for (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123; findAndParseListener(env, listener, targetClassMap, erasedTargetNames); &#125; // Try to find a parent binder for each. for (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123; TypeElement parentType = findParentType(entry.getKey(), erasedTargetNames); if (parentType != null) &#123; BindingClass bindingClass = entry.getValue(); BindingClass parentBindingClass = targetClassMap.get(parentType); bindingClass.setParent(parentBindingClass); &#125; &#125; return targetClassMap; &#125; 继续看一下parseBindView()方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void parseBindView(Element element, Map&lt;TypeElement, BindingClass&gt; targetClassMap, Set&lt;TypeElement&gt; erasedTargetNames) &#123; TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); // Start by verifying common generated code restrictions. boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, \"fields\", element) || isBindingInWrongPackage(BindView.class, element); // Verify that the target type extends from View. TypeMirror elementType = element.asType(); if (elementType.getKind() == TypeKind.TYPEVAR) &#123; TypeVariable typeVariable = (TypeVariable) elementType; elementType = typeVariable.getUpperBound(); &#125; // 必须是View类型或者接口 if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123; error(element, \"@%s fields must extend from View or be an interface. (%s.%s)\", BindView.class.getSimpleName(), enclosingElement.getQualifiedName(), element.getSimpleName()); hasError = true; &#125; if (hasError) &#123; return; &#125; // 通过注解的value拿到id // Assemble information on the field. int id = element.getAnnotation(BindView.class).value(); BindingClass bindingClass = targetClassMap.get(enclosingElement); if (bindingClass != null) &#123; // 之前已经绑定过该id ViewBindings viewBindings = bindingClass.getViewBinding(getId(id)); if (viewBindings != null &amp;&amp; viewBindings.getFieldBinding() != null) &#123; FieldViewBinding existingBinding = viewBindings.getFieldBinding(); error(element, \"Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)\", BindView.class.getSimpleName(), id, existingBinding.getName(), enclosingElement.getQualifiedName(), element.getSimpleName()); return; &#125; &#125; else &#123; // 没有绑定过该id的话就去生成代码 bindingClass = getOrCreateTargetClass(targetClassMap, enclosingElement); &#125; String name = element.getSimpleName().toString(); TypeName type = TypeName.get(elementType); boolean required = isFieldRequired(element); FieldViewBinding binding = new FieldViewBinding(name, type, required); // 用BindingClass添加代码 bindingClass.addField(getId(id), binding); // Add the type-erased version to the valid binding targets set. erasedTargetNames.add(enclosingElement); &#125; 终于进入生成代码的阶段了，继续看一下getOrCreateTargetClass()的实现:12345678910111213141516171819202122private BindingClass getOrCreateTargetClass(Map&lt;TypeElement, BindingClass&gt; targetClassMap, TypeElement enclosingElement) &#123; BindingClass bindingClass = targetClassMap.get(enclosingElement); if (bindingClass == null) &#123; TypeName targetType = TypeName.get(enclosingElement.asType()); if (targetType instanceof ParameterizedTypeName) &#123; targetType = ((ParameterizedTypeName) targetType).rawType; &#125; // 得到包名、类名 String packageName = getPackageName(enclosingElement); String className = getClassName(enclosingElement, packageName); // 用包名、类名和_ViewBinder等拼接成要生成的类的全名，这里会有两个类:$$_ViewBinder和$$_ViewBinding ClassName binderClassName = ClassName.get(packageName, className + \"_ViewBinder\"); ClassName unbinderClassName = ClassName.get(packageName, className + \"_ViewBinding\"); boolean isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL); // 将要生成的类名,$$_ViewBinder和$$_ViewBinding封装给BindingClass类 bindingClass = new BindingClass(targetType, binderClassName, unbinderClassName, isFinal); targetClassMap.put(enclosingElement, bindingClass); &#125; return bindingClass; &#125; 继续看一下BindingClass.addField():123void addField(Id id, FieldViewBinding binding) &#123; getOrCreateViewBindings(id).setFieldBinding(binding); &#125; 继续看getOrCreateViewBindings()以及setFieldBinding()方法:12345678private ViewBindings getOrCreateViewBindings(Id id) &#123; ViewBindings viewId = viewIdMap.get(id); if (viewId == null) &#123; viewId = new ViewBindings(id); viewIdMap.put(id, viewId); &#125; return viewId; &#125; 然后看ViewBindings.setFieldBinding()方法:123456public void setFieldBinding(FieldViewBinding fieldBinding) &#123; if (this.fieldBinding != null) &#123; throw new AssertionError(); &#125; this.fieldBinding = fieldBinding; &#125; 看到这里就把findAndParseTargets()方法分析完了。大体总结一下就是把一些变量、参数等初始化到了BindingClass类中。也就是说上面process()方法中的第一步已经分析完了，下面我们来继续看第二部分. #####第二步:bindingClass.brewJava() 继续查看BindingClass.brewJava()方法的实现:123456789101112131415161718192021222324Collection&lt;JavaFile&gt; brewJava() &#123; TypeSpec.Builder result = TypeSpec.classBuilder(binderClassName) .addModifiers(PUBLIC, FINAL) .addSuperinterface(ParameterizedTypeName.get(VIEW_BINDER, targetTypeName)); result.addMethod(createBindMethod(targetTypeName)); List&lt;JavaFile&gt; files = new ArrayList&lt;&gt;(); if (isGeneratingUnbinder()) &#123; // 生成$$_ViewBinding类 files.add(JavaFile.builder(unbinderClassName.packageName(), createUnbinderClass()) .addFileComment(\"Generated code from Butter Knife. Do not modify!\") .build() ); &#125; else if (!isFinal) &#123; result.addMethod(createBindToTargetMethod()); &#125; // 生成$$_ViewBinder类 files.add(JavaFile.builder(binderClassName.packageName(), result.build()) .addFileComment(\"Generated code from Butter Knife. Do not modify!\") .build()); return files; &#125; 看到这里感觉不用再继续分析了，该方法就是使用javaopet来生成对应$$_ViewBinder.java类。 到这里我们已经知道在编译的过程中会去生成一个对应的$$_ViewBinder.java文件，该类实现了ViewBinder接口。它内部会去生成对应findViewByid()以及setOnClickListener()等方法的代码，它生成了该类后如何去调用呢？我们也没有发现new $$_ViewBinder的方法。不要忘了上面我们看到的ButterKnife.bind(this);。接下来我们看一下ButterKnife.bind(this);方法的实现: 123456789101112131415161718192021/** * BindView annotated fields and methods in the specified &#123;@link Activity&#125;. The current content * view is used as the view root. * * @param target Target activity for view binding. */ @NonNull @UiThread public static Unbinder bind(@NonNull Activity target) &#123; return getViewBinder(target).bind(Finder.ACTIVITY, target, target); &#125; /** * BindView annotated fields and methods in the specified &#123;@link View&#125;. The view and its children * are used as the view root. * * @param target Target view for view binding. */ @NonNull @UiThread public static Unbinder bind(@NonNull View target) &#123; return getViewBinder(target).bind(Finder.VIEW, target, target); &#125; 调用了getViewBinder()的bind()方法，继续看getViewBinder()方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344static final Map&lt;Class&lt;?&gt;, ViewBinder&lt;Object&gt;&gt; BINDERS = new LinkedHashMap&lt;&gt;();...@NonNull @CheckResult @UiThread static ViewBinder&lt;Object&gt; getViewBinder(@NonNull Object target) &#123; Class&lt;?&gt; targetClass = target.getClass(); if (debug) Log.d(TAG, \"Looking up view binder for \" + targetClass.getName()); return findViewBinderForClass(targetClass); &#125; @NonNull @CheckResult @UiThread private static ViewBinder&lt;Object&gt; findViewBinderForClass(Class&lt;?&gt; cls) &#123; // BINDERS是一个Map集合。也就是说它内部使用Map缓存了一下，先去内存中取 ViewBinder&lt;Object&gt; viewBinder = BINDERS.get(cls); if (viewBinder != null) &#123; if (debug) Log.d(TAG, \"HIT: Cached in view binder map.\"); return viewBinder; &#125; // 内存中没有缓存该类 String clsName = cls.getName(); // 通过类名判断下是不是系统的组件 if (clsName.startsWith(\"android.\") || clsName.startsWith(\"java.\")) &#123; if (debug) Log.d(TAG, \"MISS: Reached framework class. Abandoning search.\"); return NOP_VIEW_BINDER; &#125; //noinspection TryWithIdenticalCatches Resolves to API 19+ only type. try &#123; // 通过反射获取到对应通过编译时注解生成的$_ViewBinder类的实例 Class&lt;?&gt; viewBindingClass = Class.forName(clsName + \"_ViewBinder\"); //noinspection unchecked viewBinder = (ViewBinder&lt;Object&gt;) viewBindingClass.newInstance(); if (debug) Log.d(TAG, \"HIT: Loaded view binder class.\"); &#125; catch (ClassNotFoundException e) &#123; if (debug) Log.d(TAG, \"Not found. Trying superclass \" + cls.getSuperclass().getName()); viewBinder = findViewBinderForClass(cls.getSuperclass()); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(\"Unable to create view binder for \" + clsName, e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(\"Unable to create view binder for \" + clsName, e); &#125; // 通过反射来操作毕竟会影响性能，所以这里通过Map缓存的方式来进行优化 BINDERS.put(cls, viewBinder); return viewBinder; &#125; 到这里就彻底分析完了ButterKnife.bind(this);的实现，它其实就相当于new了一个$_ViewBinder类的实例。当然这样用起来是非常方便的，毕竟我们手动的去new类多不合理，虽然他里面用到了反射会影响一点点性能，但是他通过内存缓存的方式优化了，我感觉这种方式是利大于弊的。 那$_ViewBinder类里面都是什么内容呢？ 我们去看一下该类的代码，但是它生成的代码在哪里呢？ 开始看一下SimpleActivity_ViewBinder.bind()方法:123456public final class SimpleActivity_ViewBinder implements ViewBinder&lt;SimpleActivity&gt; &#123; @Override public Unbinder bind(Finder finder, SimpleActivity target, Object source) &#123; return new SimpleActivity_ViewBinding&lt;&gt;(target, finder, source); &#125;&#125; 接着看SimpleActivity_ViewBinding类:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class SimpleActivity_ViewBinding&lt;T extends SimpleActivity&gt; implements Unbinder &#123; protected T target; private View view2130968578; private View view2130968579; public SimpleActivity_ViewBinding(final T target, Finder finder, Object source) &#123; this.target = target; View view; target.title = finder.findRequiredViewAsType(source, R.id.title, \"field 'title'\", TextView.class); target.subtitle = finder.findRequiredViewAsType(source, R.id.subtitle, \"field 'subtitle'\", TextView.class); view = finder.findRequiredView(source, R.id.hello, \"field 'hello', method 'sayHello', and method 'sayGetOffMe'\"); target.hello = finder.castView(view, R.id.hello, \"field 'hello'\", Button.class); view2130968578 = view; view.setOnClickListener(new DebouncingOnClickListener() &#123; @Override public void doClick(View p0) &#123; target.sayHello(); &#125; &#125;); view.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View p0) &#123; return target.sayGetOffMe(); &#125; &#125;); view = finder.findRequiredView(source, R.id.list_of_things, \"field 'listOfThings' and method 'onItemClick'\"); target.listOfThings = finder.castView(view, R.id.list_of_things, \"field 'listOfThings'\", ListView.class); view2130968579 = view; ((AdapterView&lt;?&gt;) view).setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; p0, View p1, int p2, long p3) &#123; target.onItemClick(p2); &#125; &#125;); target.footer = finder.findRequiredViewAsType(source, R.id.footer, \"field 'footer'\", TextView.class); target.headerViews = Utils.listOf( finder.findRequiredView(source, R.id.title, \"field 'headerViews'\"), finder.findRequiredView(source, R.id.subtitle, \"field 'headerViews'\"), finder.findRequiredView(source, R.id.hello, \"field 'headerViews'\")); &#125; @Override public void unbind() &#123; T target = this.target; if (target == null) throw new IllegalStateException(\"Bindings already cleared.\"); target.title = null; target.subtitle = null; target.hello = null; target.listOfThings = null; target.footer = null; target.headerViews = null; view2130968578.setOnClickListener(null); view2130968578.setOnLongClickListener(null); view2130968578 = null; ((AdapterView&lt;?&gt;) view2130968579).setOnItemClickListener(null); view2130968579 = null; this.target = null; &#125;&#125; 可以看到他内部会通过findViewByid()等来找到对应的View，然后将其赋值给target.xxxx，所以这样就相当于把所有的控件以及事件都给初始化了，以后就可以直接使用了，通过这里也可以看到我们在使用注解的时候不要把控件或者方法声明为private的。 总结一下: ButterKnifeProcessor会生成$$_ViewBinder类并实现了ViewBinder接口。 $$_ViewBinder类中包含了所有对应的代码，会通过注解去解析到id等，然后通过findViewById()等方法找到对应的控件，并且复制给调用该方法的来中的变量。这样就等同于我们直接 使用View v = findViewByid(R.id.xx)来进行初始化控件。 上面虽然生成了$$_ViewBinder类，但是如何去调用呢？ 就是在调用ButterKnife.bind(this)时执行，该方法会通过反射去实例化对应的$$_ViewBinder类，并且调用该类的bind()方法。 Butterknife除了在Butterknife.bind()方法中使用反射之外，其他注解的处理都是通过编译时注解使用，所以不会影响效率。 使用Butterknife是不要将变量声明为private类型，因为$$_ViewBinder类中会去直接调用变量赋值，如果声明为private将无法赋值。 1@BindView(R2.id.title) TextView title; 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"View绘制过程详解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/View绘制过程详解/","text":"View绘制过程详解界面窗口的根布局是DecorView，该类继承自FrameLayout.说到View绘制，想到的就是从这里入手，而FrameLayout继承自ViewGroup。感觉绘制肯定会在ViewGroup或者View中，但是木有找到。发现ViewGroup实现ViewParent接口，而ViewParent有一个实现类是ViewRootImpl， ViewGruop中会使用ViewRootImpl…123456789101112/** * The top of a view hierarchy, implementing the needed protocol between View * and the WindowManager. This is for the most part an internal implementation * detail of &#123;@link WindowManagerGlobal&#125;. * * &#123;@hide&#125; */@SuppressWarnings(&#123;\"EmptyCatchBlock\", \"PointlessBooleanExpression\"&#125;)public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, HardwareRenderer.HardwareDrawCallbacks &#123; &#125; View的绘制过程从ViewRootImpl.performTraversals()方法开始。首先先说明一下，这部分代码比较多，逻辑也比较麻烦，很容易弄晕，如果感觉看起来费劲，就跳过这一块，直接到下面的Measure、Layout、Draw部分开始看。我也没有全部弄清楚，我只是把里面的步骤标注了下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125private void performTraversals() &#123; // ... 此处省略源代码N行 // 是否需要Measure if (!mStopped) &#123; boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123; // 这里是获取widthMeasureSpec,这俩参数不是一般的尺寸数值，而是将模式和尺寸组合在一起的数值. // getRootMeasureSpec方法内部会使用MeasureSpec.makeMeasureSpec()方法来组装一个MeasureSpec， // 当lp.width参数等于MATCH_PARENT的时候，MeasureSpec的specMode就等于EXACTLY，当lp.width等于WRAP_CONTENT的时候，MeasureSpec的specMode就等于AT_MOST。 // 并且MATCH_PARENT和WRAP_CONTENT时的specSize都是等于windowSize的，也就意味着根视图总是会充满全屏的。 int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); if (DEBUG_LAYOUT) Log.v(TAG, \"Ooops, something changed! mWidth=\" + mWidth + \" measuredWidth=\" + host.getMeasuredWidth() + \" mHeight=\" + mHeight + \" measuredHeight=\" + host.getMeasuredHeight() + \" coveredInsetsChanged=\" + contentInsetsChanged); // 调用PerformMeasure方法。 // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // Implementation of weights from WindowManager.LayoutParams // We just grow the dimensions as needed and re-measure if // needs be int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; if (lp.horizontalWeight &gt; 0.0f) &#123; width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; &#125; if (lp.verticalWeight &gt; 0.0f) &#123; height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; &#125; if (measureAgain) &#123; if (DEBUG_LAYOUT) Log.v(TAG, \"And hey let's measure once more: width=\" + width + \" height=\" + height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; layoutRequested = true; &#125; &#125; final boolean didLayout = layoutRequested &amp;&amp; !mStopped; boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; // 是否需要Layout if (didLayout) &#123; // 调用performLayout方法。 performLayout(lp, desiredWindowWidth, desiredWindowHeight); // By this point all views have been sized and positioned // We can compute the transparent area if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123; // start out transparent // TODO: AVOID THAT CALL BY CACHING THE RESULT? host.getLocationInWindow(mTmpLocation); mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1], mTmpLocation[0] + host.mRight - host.mLeft, mTmpLocation[1] + host.mBottom - host.mTop); host.gatherTransparentRegion(mTransparentRegion); if (mTranslator != null) &#123; mTranslator.translateRegionInWindowToScreen(mTransparentRegion); &#125; if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123; mPreviousTransparentRegion.set(mTransparentRegion); mFullRedrawNeeded = true; // reconfigure window manager try &#123; mWindowSession.setTransparentRegion(mWindow, mTransparentRegion); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; if (DBG) &#123; System.out.println(\"======================================\"); System.out.println(\"performTraversals -- after setFrame\"); host.debug(); &#125; &#125; // 是否需要Draw if (!cancelDraw &amp;&amp; !newSurface) &#123; if (!skipDraw || mReportNextDraw) &#123; if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).startChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; // 调用performDraw方法 performDraw(); &#125; &#125; else &#123; if (viewVisibility == View.VISIBLE) &#123; // Try again scheduleTraversals(); &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).endChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; &#125; mIsInTraversal = false;&#125; 从上面源码可以看出,performTraversals()方法中会依次做三件事： performMeasure(), 内部是mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);测量View大小。这里顺便提一下，这个mView是什么？它就是Window最顶成的View(DecorView),它是FrameLayout的子类。 performLayout(), 内部是mView.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());视图布局，确定View位置。 performDraw(), 内部是draw(fullRedrawNeeded); 绘制界面。 至此View绘制的三个过程已经展现： MeasureperformMeasure方法如下：12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 在performMeasure()方法中会调用View.measure()方法， 源码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * &lt;p&gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * &lt;/p&gt; * * &lt;p&gt; * The actual measurement work of a view is performed in * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses. * &lt;/p&gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); &#125; // Suppress sign extension for the low bytes long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL; if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) &#123; // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // 调用onMeasure方法 // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123; // 重写onMeausre方法的时，必须调用setMeasuredDimension或者super.onMeasure方法，不然就会走到这里报错。 // setMeasuredDimension中回去改变mPrivateFlags的值 throw new IllegalStateException(\"onMeasure() did not set the\" + \" measured dimension by calling\" + \" setMeasuredDimension()\"); &#125; mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; &#125; mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension&#125; 在measure方法中会调用onMeasure方法。ViewGroup的子类会重写该方法来进行测量大小，因为mView是DecorView，而DecorView是FrameLayout的子类。所以我们看一下FrameLayout.onMeasure方法：FrameLayout.onMeasure源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * &#123;@inheritDoc&#125; */@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int count = getChildCount(); final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; // 调用该方法去测量每个子View measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) &#123; if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) &#123; mMatchParentChildren.add(child); &#125; &#125; &#125; &#125; // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) &#123; maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); &#125; setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); int childWidthMeasureSpec; int childHeightMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) &#123; childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin, MeasureSpec.EXACTLY); &#125; else &#123; childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); &#125; if (lp.height == LayoutParams.MATCH_PARENT) &#123; childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin, MeasureSpec.EXACTLY); &#125; else &#123; childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); &#125; child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; &#125;&#125; 我们看到内部会调用measureChildWithMargins()方法,该方法源码如下：12345678910111213141516171819202122232425262728/** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding * and margins. The child must have MarginLayoutParams The heavy lifting is * done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param widthUsed Extra space that has been used up by the parent * horizontally (possibly by other children of the parent) * @param parentHeightMeasureSpec The height requirements for this view * @param heightUsed Extra space that has been used up by the parent * vertically (possibly by other children of the parent) */protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 里面就是对该子View调用了measure方法，我们假设这个View已经不是ViewGroup了，就会又和上面一样，又调用onMeasure方法，下面我们直接看一下View.onMeasure()方法：View.onMeasure()方法的源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * &lt;p&gt; * Measure the view and its content to determine the measured width and the * measured height. This method is invoked by &#123;@link #measure(int, int)&#125; and * should be overriden by subclasses to provide accurate and efficient * measurement of their contents. * &lt;/p&gt; * * &lt;p&gt; * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you * &lt;em&gt;must&lt;/em&gt; call &#123;@link #setMeasuredDimension(int, int)&#125; to store the * measured width and height of this view. Failure to do so will trigger an * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by * &#123;@link #measure(int, int)&#125;. Calling the superclass' * &#123;@link #onMeasure(int, int)&#125; is a valid use. * &lt;/p&gt; * * &lt;p&gt; * The base class implementation of measure defaults to the background size, * unless a larger size is allowed by the MeasureSpec. Subclasses should * override &#123;@link #onMeasure(int, int)&#125; to provide better measurements of * their content. * &lt;/p&gt; * * &lt;p&gt; * If this method is overridden, it is the subclass's responsibility to make * sure the measured height and width are at least the view's minimum height * and width (&#123;@link #getSuggestedMinimumHeight()&#125; and * &#123;@link #getSuggestedMinimumWidth()&#125;). * &lt;/p&gt; * * @param widthMeasureSpec horizontal space requirements as imposed by the parent. * The requirements are encoded with * &#123;@link android.view.View.MeasureSpec&#125;. * @param heightMeasureSpec vertical space requirements as imposed by the parent. * The requirements are encoded with * &#123;@link android.view.View.MeasureSpec&#125;. * * @see #getMeasuredWidth() * @see #getMeasuredHeight() * @see #setMeasuredDimension(int, int) * @see #getSuggestedMinimumHeight() * @see #getSuggestedMinimumWidth() * @see android.view.View.MeasureSpec#getMode(int) * @see android.view.View.MeasureSpec#getSize(int) */protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 如果不重写onMeasure方法，默认会调用getDefaultSize获取大小，下面会说getDefaultSize这个方法。 setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; setMeasuredDimension()方法如下：123456789101112131415161718192021222324/** * &lt;p&gt;This method must be called by &#123;@link #onMeasure(int, int)&#125; to store the * measured width and measured height. Failing to do so will trigger an * exception at measurement time.&lt;/p&gt; * * @param measuredWidth The measured width of this view. May be a complex * bit mask as defined by &#123;@link #MEASURED_SIZE_MASK&#125; and * &#123;@link #MEASURED_STATE_TOO_SMALL&#125;. * @param measuredHeight The measured height of this view. May be a complex * bit mask as defined by &#123;@link #MEASURED_SIZE_MASK&#125; and * &#123;@link #MEASURED_STATE_TOO_SMALL&#125;. */protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; &#125; setMeasuredDimensionRaw(measuredWidth, measuredHeight);&#125; setMeasuredDimensionRaw()方法如下：1234567891011121314151617181920/** * Sets the measured dimension without extra processing for things like optical bounds. * Useful for reapplying consistent values that have already been cooked with adjustments * for optical bounds, etc. such as those from the measurement cache. * * @param measuredWidth The measured width of this view. May be a complex * bit mask as defined by &#123;@link #MEASURED_SIZE_MASK&#125; and * &#123;@link #MEASURED_STATE_TOO_SMALL&#125;. * @param measuredHeight The measured height of this view. May be a complex * bit mask as defined by &#123;@link #MEASURED_SIZE_MASK&#125; and * &#123;@link #MEASURED_STATE_TOO_SMALL&#125;. */private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123; // 赋值给mMeasuredWidth，getMeasuredWidth就会调用该值。 mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; // 这就是重写onMeasure方法时如果不调用setMeasuredDimension方法时为什么会报错的原因。 mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;&#125; 我们接着看一下上面用到的getDefaultSize()方法，源码如下：1234567891011121314151617181920212223242526/** * Utility to return a default size. Uses the supplied size if the * MeasureSpec imposed no constraints. Will get larger if allowed * by the MeasureSpec. * * @param size Default size for this view * @param measureSpec Constraints imposed by the parent * @return The size this view should be. */public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; // measureSpec值用于获取宽度(高度)的规格和大小，解析出对应的size和mode int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; getDefaultSize方法又会使用到MeasureSpec类，文档中对MeasureSpec是这样介绍的A MeasureSpec is comprised of a size and a mode. There are three possible modes: MeasureSpec.EXACTLY The parent has determined an exact size for the child. The child is going to be given those bounds regardless of how big it wants to be. 理解成MATCH_PARENT或者在布局中指定了宽高值，如layout:width=’50dp’ MeasureSpec.AT_MOST The child can be as large as it wants up to the specified size.理解成WRAP_CONTENT,这是的值是父View可以允许的最大的值，只要不超过这个值都可以。 MeasureSpec.UNSPECIFIED The parent has not imposed any constraint on the child. It can be whatever size it wants. 这种情况比较少，一般用不到。 这里简单总结一下上面的过程:12345678910111213141516171819202122performMeasure() &#123; - 1.调用View.measure方法 mView.measure(): - 2.measure内部会调用onMeasure方法,但是因为这里mView是DecorView，所以会调用FrameLayout的onMeasure方法。 onMeasure(FrameLayout) - 3. 内部设置ViewGroup的宽高 setMeasuredDimension 并且对每个子View进行遍历测量 for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); - 4. 对每个子View调用measureChildWithMargins方法 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); -5. measureChildWithMargins内部调用子View的measure方法 meausre - 6. measure方法内部又调用onMeasure方法 onMeasure(View) - 7. onMeasure方法内部调用setMeasuredDimension setMeasuredDimension - 8. setMeasuredDimension内部调用setMeasuredDimensionRaw setMeasuredDimensionRaw &#125;&#125; 从上面代码中能看到measure是final的，我们可以重写onMeasure来实现measure过程。到这里基本都讲完了，我们在开发中会按照需要重写onMeasure方法，然后调用setMeasuredDimension方法设置大小，ps:譬如我们设置了setMeasuredDimension(10, 10),那么不管布局中怎么设置这个View的大小都是没用的，最后显示出来大小都是10*10。 LayoutperformLayout方法源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123; Log.v(TAG, \"Laying out \" + host + \" to (\" + host.getMeasuredWidth() + \", \" + host.getMeasuredHeight() + \")\"); &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"layout\"); try &#123; // 把刚才测量的宽高设置进来 host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) &#123; // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) &#123; // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = validLayoutRequesters.get(i); Log.w(\"View\", \"requestLayout() improperly called by \" + view + \" during layout: running second layout pass\"); view.requestLayout(); &#125; measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop'd validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) &#123; final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() &#123; @Override public void run() &#123; int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = finalRequesters.get(i); Log.w(\"View\", \"requestLayout() improperly called by \" + view + \" during second layout pass: posting in next frame\"); view.requestLayout(); &#125; &#125; &#125;); &#125; &#125; &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; mInLayout = false;&#125; 内部会调用layout()方法，因为host是mView，ViewGroup中重写了layout方法，并调用了super.layout.所以我们直接看View.layout()方法，该方法源码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Assign a size and position to a view and all of its * descendants * * &lt;p&gt;This is the second phase of the layout mechanism. * (The first is measuring). In this phase, each parent calls * layout on all of its children to position them. * This is typically done using the child measurements * that were stored in the measure pass().&lt;/p&gt; * * &lt;p&gt;Derived classes should not override this method. * Derived classes with children should override * onLayout. In that method, they should * call layout on each of their children.&lt;/p&gt; * * @param l Left position, relative to parent * @param t Top position, relative to parent * @param r Right position, relative to parent * @param b Bottom position, relative to parent */@SuppressWarnings(&#123;\"unchecked\"&#125;)public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; // 这部分是判断这个View的大小是否已经发生了变化，来判断是否需要重绘。 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; // 内部调用onLayout方法 onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;&#125; 这里会调用onLayout方法，同样因为mView是FrameLayout的子类，所以我们要看FrameLayout的onLayout方法，这里我们先看一下ViewGroup.onLayout方法:123456/** * &#123;@inheritDoc&#125; */@Overrideprotected abstract void onLayout(boolean changed, int l, int t, int r, int b); 是个抽象方法，所以ViewGroup的子类都需要实现该方法。我们看一下FrameLayout.onLayout方法,源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 /** * &#123;@inheritDoc&#125; */@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125;void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); mForegroundBoundsChanged = true; for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) &#123; gravity = DEFAULT_CHILD_GRAVITY; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) &#123; childLeft = parentRight - width - lp.rightMargin; break; &#125; case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; &#125; switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; //调用子View的layout方法 child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125;&#125; 而View.layout方法，又会调用到View.onLayout方法，我们假设这个子View不是ViewGroup.看一下View.onLayout方法源码如下：123456789101112131415/** * Called from layout when this view should * assign a size and position to each of its children. * * Derived classes with children should override * this method and call layout on each of * their children. * @param changed This is a new size or position for this view * @param left Left position, relative to parent * @param top Top position, relative to parent * @param right Right position, relative to parent * @param bottom Bottom position, relative to parent */protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; 是一个空方法，这是因为Layout需要ViewGroup来控制进行。 这里也总结一下layout的过程。12345678910111213141516private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; - 1. host.layout host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); -2. layout方法会分别调用setFrame()和onLayout()方法 setFrame() onLayout() -3. 因为host是mView也就是DecorView也就是FrameLayout的子类。FrameLayout的onLayout方法如下 for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (child.getVisibility() != GONE) &#123; -4. 遍历每个子View，并分别调用layout方法。 child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125;&#125; Draw绘制阶段是从ViewRootImpl中的performDraw方法开始的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void performDraw() &#123; if (mAttachInfo.mDisplayState == Display.STATE_OFF &amp;&amp; !mReportNextDraw) &#123; return; &#125; final boolean fullRedrawNeeded = mFullRedrawNeeded; mFullRedrawNeeded = false; mIsDrawing = true; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"draw\"); try &#123; // 开始draw了 draw(fullRedrawNeeded); &#125; finally &#123; mIsDrawing = false; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; // For whatever reason we didn't create a HardwareRenderer, end any // hardware animations that are now dangling if (mAttachInfo.mPendingAnimatingRenderNodes != null) &#123; final int count = mAttachInfo.mPendingAnimatingRenderNodes.size(); for (int i = 0; i &lt; count; i++) &#123; mAttachInfo.mPendingAnimatingRenderNodes.get(i).endAllAnimators(); &#125; mAttachInfo.mPendingAnimatingRenderNodes.clear(); &#125; if (mReportNextDraw) &#123; mReportNextDraw = false; if (mAttachInfo.mHardwareRenderer != null) &#123; mAttachInfo.mHardwareRenderer.fence(); &#125; if (LOCAL_LOGV) &#123; Log.v(TAG, \"FINISHED DRAWING: \" + mWindowAttributes.getTitle()); &#125; if (mSurfaceHolder != null &amp;&amp; mSurface.isValid()) &#123; mSurfaceHolderCallback.surfaceRedrawNeeded(mSurfaceHolder); SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks(); if (callbacks != null) &#123; for (SurfaceHolder.Callback c : callbacks) &#123; if (c instanceof SurfaceHolder.Callback2) &#123; ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded( mSurfaceHolder); &#125; &#125; &#125; &#125; try &#123; mWindowSession.finishDrawing(mWindow); &#125; catch (RemoteException e) &#123; &#125; &#125;&#125; 内部会调用draw方法，draw方法源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150private void draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; if (!surface.isValid()) &#123; return; &#125; if (DEBUG_FPS) &#123; trackFPS(); &#125; if (!sFirstDrawComplete) &#123; synchronized (sFirstDrawHandlers) &#123; sFirstDrawComplete = true; final int count = sFirstDrawHandlers.size(); for (int i = 0; i&lt; count; i++) &#123; mHandler.post(sFirstDrawHandlers.get(i)); &#125; &#125; &#125; scrollToRectOrFocus(null, false); if (mAttachInfo.mViewScrollChanged) &#123; mAttachInfo.mViewScrollChanged = false; mAttachInfo.mTreeObserver.dispatchOnScrollChanged(); &#125; boolean animating = mScroller != null &amp;&amp; mScroller.computeScrollOffset(); final int curScrollY; if (animating) &#123; curScrollY = mScroller.getCurrY(); &#125; else &#123; curScrollY = mScrollY; &#125; if (mCurScrollY != curScrollY) &#123; mCurScrollY = curScrollY; fullRedrawNeeded = true; &#125; final float appScale = mAttachInfo.mApplicationScale; final boolean scalingRequired = mAttachInfo.mScalingRequired; int resizeAlpha = 0; if (mResizeBuffer != null) &#123; long deltaTime = SystemClock.uptimeMillis() - mResizeBufferStartTime; if (deltaTime &lt; mResizeBufferDuration) &#123; float amt = deltaTime/(float) mResizeBufferDuration; amt = mResizeInterpolator.getInterpolation(amt); animating = true; resizeAlpha = 255 - (int)(amt*255); &#125; else &#123; disposeResizeBuffer(); &#125; &#125; final Rect dirty = mDirty; if (mSurfaceHolder != null) &#123; // The app owns the surface, we won't draw. dirty.setEmpty(); if (animating) &#123; if (mScroller != null) &#123; mScroller.abortAnimation(); &#125; disposeResizeBuffer(); &#125; return; &#125; if (fullRedrawNeeded) &#123; mAttachInfo.mIgnoreDirtyState = true; dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); &#125; if (DEBUG_ORIENTATION || DEBUG_DRAW) &#123; Log.v(TAG, \"Draw \" + mView + \"/\" + mWindowAttributes.getTitle() + \": dirty=&#123;\" + dirty.left + \",\" + dirty.top + \",\" + dirty.right + \",\" + dirty.bottom + \"&#125; surface=\" + surface + \" surface.isValid()=\" + surface.isValid() + \", appScale:\" + appScale + \", width=\" + mWidth + \", height=\" + mHeight); &#125; mAttachInfo.mTreeObserver.dispatchOnDraw(); int xOffset = 0; int yOffset = curScrollY; final WindowManager.LayoutParams params = mWindowAttributes; final Rect surfaceInsets = params != null ? params.surfaceInsets : null; if (surfaceInsets != null) &#123; xOffset -= surfaceInsets.left; yOffset -= surfaceInsets.top; // Offset dirty rect for surface insets. dirty.offset(surfaceInsets.left, surfaceInsets.right); &#125; if (!dirty.isEmpty() || mIsAnimating) &#123; if (mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123; // Draw with hardware renderer. mIsAnimating = false; boolean invalidateRoot = false; if (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123; mHardwareYOffset = yOffset; mHardwareXOffset = xOffset; mAttachInfo.mHardwareRenderer.invalidateRoot(); &#125; mResizeAlpha = resizeAlpha; dirty.setEmpty(); mBlockResizeBuffer = false; mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this); &#125; else &#123; // If we get here with a disabled &amp; requested hardware renderer, something went // wrong (an invalidate posted right before we destroyed the hardware surface // for instance) so we should just bail out. Locking the surface with software // rendering at this point would lock it forever and prevent hardware renderer // from doing its job when it comes back. // Before we request a new frame we must however attempt to reinitiliaze the // hardware renderer if it's in requested state. This would happen after an // eglTerminate() for instance. if (mAttachInfo.mHardwareRenderer != null &amp;&amp; !mAttachInfo.mHardwareRenderer.isEnabled() &amp;&amp; mAttachInfo.mHardwareRenderer.isRequested()) &#123; try &#123; mAttachInfo.mHardwareRenderer.initializeIfNeeded( mWidth, mHeight, mSurface, surfaceInsets); &#125; catch (OutOfResourcesException e) &#123; handleOutOfResourcesException(e); return; &#125; mFullRedrawNeeded = true; scheduleTraversals(); return; &#125; // draw的部分在这里。。。内部会用canvas去画 if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; if (animating) &#123; mFullRedrawNeeded = true; scheduleTraversals(); &#125;&#125; 我们看一下drawSoftware方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * @return true if drawing was successful, false if an error occurred */private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; final int left = dirty.left; final int top = dirty.top; final int right = dirty.right; final int bottom = dirty.bottom; canvas = mSurface.lockCanvas(dirty); // The dirty rectangle can be modified by Surface.lockCanvas() //noinspection ConstantConditions if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) &#123; attachInfo.mIgnoreDirtyState = true; &#125; // TODO: Do this in native canvas.setDensity(mDensity); &#125; catch (Surface.OutOfResourcesException e) &#123; handleOutOfResourcesException(e); return false; &#125; catch (IllegalArgumentException e) &#123; Log.e(TAG, \"Could not lock surface\", e); // Don't assume this is due to out of memory, it could be // something else, and if it is something else then we could // kill stuff (or ourself) for no reason. mLayoutRequested = true; // ask wm for a new surface next time. return false; &#125; try &#123; if (DEBUG_ORIENTATION || DEBUG_DRAW) &#123; Log.v(TAG, \"Surface \" + surface + \" drawing to bitmap w=\" + canvas.getWidth() + \", h=\" + canvas.getHeight()); //canvas.drawARGB(255, 255, 0, 0); &#125; // If this bitmap's format includes an alpha channel, we // need to clear it before drawing so that the child will // properly re-composite its drawing on a transparent // background. This automatically respects the clip/dirty region // or // If we are applying an offset, we need to clear the area // where the offset doesn't appear to avoid having garbage // left in the blank areas. if (!canvas.isOpaque() || yoff != 0 || xoff != 0) &#123; canvas.drawColor(0, PorterDuff.Mode.CLEAR); &#125; dirty.setEmpty(); mIsAnimating = false; attachInfo.mDrawingTime = SystemClock.uptimeMillis(); mView.mPrivateFlags |= View.PFLAG_DRAWN; if (DEBUG_DRAW) &#123; Context cxt = mView.getContext(); Log.i(TAG, \"Drawing: package:\" + cxt.getPackageName() + \", metrics=\" + cxt.getResources().getDisplayMetrics() + \", compatibilityInfo=\" + cxt.getResources().getCompatibilityInfo()); &#125; try &#123; canvas.translate(-xoff, -yoff); if (mTranslator != null) &#123; mTranslator.translateCanvas(canvas); &#125; canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0); attachInfo.mSetIgnoreDirtyState = false; // 内部会去调用View.draw()； mView.draw(canvas); &#125; finally &#123; if (!attachInfo.mSetIgnoreDirtyState) &#123; // Only clear the flag if it was not set during the mView.draw() call attachInfo.mIgnoreDirtyState = false; &#125; &#125; &#125; finally &#123; try &#123; surface.unlockCanvasAndPost(canvas); &#125; catch (IllegalArgumentException e) &#123; Log.e(TAG, \"Could not unlock surface\", e); mLayoutRequested = true; // ask wm for a new surface next time. //noinspection ReturnInsideFinallyBlock return false; &#125; if (LOCAL_LOGV) &#123; Log.v(TAG, \"Surface \" + surface + \" unlockCanvasAndPost\"); &#125; &#125; return true;&#125; 代码中调用了mView.draw()方法，所以我们看一下FrameLayout.draw()方法：12345678910111213141516171819202122232425262728293031323334/** * &#123;@inheritDoc&#125; */@Overridepublic void draw(Canvas canvas) &#123; super.draw(canvas); if (mForeground != null) &#123; final Drawable foreground = mForeground; if (mForegroundBoundsChanged) &#123; mForegroundBoundsChanged = false; final Rect selfBounds = mSelfBounds; final Rect overlayBounds = mOverlayBounds; final int w = mRight-mLeft; final int h = mBottom-mTop; if (mForegroundInPadding) &#123; selfBounds.set(0, 0, w, h); &#125; else &#123; selfBounds.set(mPaddingLeft, mPaddingTop, w - mPaddingRight, h - mPaddingBottom); &#125; final int layoutDirection = getLayoutDirection(); Gravity.apply(mForegroundGravity, foreground.getIntrinsicWidth(), foreground.getIntrinsicHeight(), selfBounds, overlayBounds, layoutDirection); foreground.setBounds(overlayBounds); &#125; foreground.draw(canvas); &#125;&#125; 内部调用了super.draw()，而ViewGroup没有重写该方法，所以直接看View的draw()方法.View.draw()方法如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201/** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * &#123;@link #onDraw(android.graphics.Canvas)&#125; instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered. */public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; // 这里注释说的很明白了，draw的6个步骤。 /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content, 调用onDraw方法绘制自身 * 4. Draw children, 调用dispatchDraw方法绘制子View * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // we're done... return; &#125; /* * Here we do the full fledged routine... * (this is an uncommon case where speed matters less, * this is why we repeat some of the tests that have been * done above) */ boolean drawTop = false; boolean drawBottom = false; boolean drawLeft = false; boolean drawRight = false; float topFadeStrength = 0.0f; float bottomFadeStrength = 0.0f; float leftFadeStrength = 0.0f; float rightFadeStrength = 0.0f; // Step 2, save the canvas' layers int paddingLeft = mPaddingLeft; final boolean offsetRequired = isPaddingOffsetRequired(); if (offsetRequired) &#123; paddingLeft += getLeftPaddingOffset(); &#125; int left = mScrollX + paddingLeft; int right = left + mRight - mLeft - mPaddingRight - paddingLeft; int top = mScrollY + getFadeTop(offsetRequired); int bottom = top + getFadeHeight(offsetRequired); if (offsetRequired) &#123; right += getRightPaddingOffset(); bottom += getBottomPaddingOffset(); &#125; final ScrollabilityCache scrollabilityCache = mScrollCache; final float fadeHeight = scrollabilityCache.fadingEdgeLength; int length = (int) fadeHeight; // clip the fade length if top and bottom fades overlap // overlapping fades produce odd-looking artifacts if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123; length = (bottom - top) / 2; &#125; // also clip horizontal fades if necessary if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123; length = (right - left) / 2; &#125; if (verticalEdges) &#123; topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength())); drawTop = topFadeStrength * fadeHeight &gt; 1.0f; bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength())); drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f; &#125; if (horizontalEdges) &#123; leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength())); drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f; rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength())); drawRight = rightFadeStrength * fadeHeight &gt; 1.0f; &#125; saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) &#123; final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; if (drawBottom) &#123; canvas.saveLayer(left, bottom - length, right, bottom, null, flags); &#125; if (drawLeft) &#123; canvas.saveLayer(left, top, left + length, bottom, null, flags); &#125; if (drawRight) &#123; canvas.saveLayer(right - length, top, right, bottom, null, flags); &#125; &#125; else &#123; scrollabilityCache.setFadeColor(solidColor); &#125; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); &#125; if (drawBottom) &#123; matrix.setScale(1, fadeHeight * bottomFadeStrength); matrix.postRotate(180); matrix.postTranslate(left, bottom); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, bottom - length, right, bottom, p); &#125; if (drawLeft) &#123; matrix.setScale(1, fadeHeight * leftFadeStrength); matrix.postRotate(-90); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, left + length, bottom, p); &#125; if (drawRight) &#123; matrix.setScale(1, fadeHeight * rightFadeStrength); matrix.postRotate(90); matrix.postTranslate(right, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(right - length, top, right, bottom, p); &#125; canvas.restoreToCount(saveCount); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125;&#125; 上面会调用onDraw和dispatchDraw方法。我们先看一下View.onDraw方法：1234567/** * Implement this to do your drawing. * * @param canvas the canvas on which the background will be drawn */protected void onDraw(Canvas canvas) &#123;&#125; 是空方法，这是也很好理解，因为每个View的展现都不一样，例如TextView、ProgressBar等，所以View不会去实现onDraw方法，具体是要子类去根据自己的显示要求实现该方法。 再看一下dispatchDraw方法，这个方法是用来绘制子View的，所以要看ViewGroup.dispatchDraw方法，View.dispatchDraw是空的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * &#123;@inheritDoc&#125; */@Overrideprotected void dispatchDraw(Canvas canvas) &#123; boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode); final int childrenCount = mChildrenCount; final View[] children = mChildren; int flags = mGroupFlags; if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) &#123; final boolean cache = (mGroupFlags &amp; FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE; final boolean buildCache = !isHardwareAccelerated(); for (int i = 0; i &lt; childrenCount; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123; final LayoutParams params = child.getLayoutParams(); attachLayoutAnimationParameters(child, params, i, childrenCount); bindLayoutAnimation(child); if (cache) &#123; child.setDrawingCacheEnabled(true); if (buildCache) &#123; child.buildDrawingCache(true); &#125; &#125; &#125; &#125; final LayoutAnimationController controller = mLayoutAnimationController; if (controller.willOverlap()) &#123; mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE; &#125; controller.start(); mGroupFlags &amp;= ~FLAG_RUN_ANIMATION; mGroupFlags &amp;= ~FLAG_ANIMATION_DONE; if (cache) &#123; mGroupFlags |= FLAG_CHILDREN_DRAWN_WITH_CACHE; &#125; if (mAnimationListener != null) &#123; mAnimationListener.onAnimationStart(controller.getAnimation()); &#125; &#125; int clipSaveCount = 0; final boolean clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK; if (clipToPadding) &#123; clipSaveCount = canvas.save(); canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop, mScrollX + mRight - mLeft - mPaddingRight, mScrollY + mBottom - mTop - mPaddingBottom); &#125; // We will draw our child's animation, let's reset the flag mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION; mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED; boolean more = false; final long drawingTime = getDrawingTime(); if (usingRenderNodeProperties) canvas.insertReorderBarrier(); // Only use the preordered list if not HW accelerated, since the HW pipeline will do the // draw reordering internally final ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties ? null : buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); for (int i = 0; i &lt; childrenCount; i++) &#123; int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; // 调用drawChild方法 more |= drawChild(canvas, child, drawingTime); &#125; &#125; if (preorderedList != null) preorderedList.clear(); // Draw any disappearing views that have animations if (mDisappearingChildren != null) &#123; final ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren; final int disappearingCount = disappearingChildren.size() - 1; // Go backwards -- we may delete as animations finish for (int i = disappearingCount; i &gt;= 0; i--) &#123; final View child = disappearingChildren.get(i); more |= drawChild(canvas, child, drawingTime); &#125; &#125; if (usingRenderNodeProperties) canvas.insertInorderBarrier(); if (debugDraw()) &#123; onDebugDraw(canvas); &#125; if (clipToPadding) &#123; canvas.restoreToCount(clipSaveCount); &#125; // mGroupFlags might have been updated by drawChild() flags = mGroupFlags; if ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) &#123; invalidate(true); &#125; if ((flags &amp; FLAG_ANIMATION_DONE) == 0 &amp;&amp; (flags &amp; FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &amp;&amp; mLayoutAnimationController.isDone() &amp;&amp; !more) &#123; // We want to erase the drawing cache and notify the listener after the // next frame is drawn because one extra invalidate() is caused by // drawChild() after the animation is over mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER; final Runnable end = new Runnable() &#123; public void run() &#123; notifyAnimationListener(); &#125; &#125;; post(end); &#125;&#125; 可以看到上面的方法中会调用drawChild方法，该方法如下：1234567891011121314/** * Draw one child of this View Group. This method is responsible for getting * the canvas in the right state. This includes clipping, translating so * that the child's scrolled origin is at 0, 0, and applying any animation * transformations. * * @param canvas The canvas on which to draw the child * @param child Who to draw * @param drawingTime The time at which draw is occurring * @return True if an invalidate() was issued */protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 这里也简单总结一下draw的过程：12345678910111213141516171819202122// 1. ViewRootImpl.performDraw()private void performDraw() &#123; // 2. ViewRootImpl.draw() draw(fullRedrawNeeded); // 3. ViewRootImpl.drawSoftware drawSoftware // 4. 内部调用mView.draw,也就是FrameLayout.draw(). mView.draw()(FrameLayout) // 5. FrameLayout.draw方法内部会调用super.draw方法，也就是View.draw方法. super.draw(canvas); // 6. View.draw方法内部会分别调用onDraw绘制自己以及dispatchDraw绘制子View. onDraw // 绘制子View dispatchDraw // 7. dispatchDraw方法内部会遍历所有子View. for (int i = 0; i &lt; childrenCount; i++) &#123; // 8. 对每个子View分别调用drawChild方法 drawChild() // 9. drawChild方法内部会对该子View调用draw方法，进行绘制。然后draw又会调用onDraw等，循环就开始了。 child.draw() &#125;&#125; 最后补充一个小问题： getWidth()与getMeasuredWidth()有什么区别呢？一般情况下这两个的值是相同的，getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到。而且getMeasureWidth()的值是通过setMeasuredDimension()设置的，但是getWidth()的值是通过视图右边的坐标减去左边的坐标计算出来的。如果我们在layout的时候将宽高不传getMeasureWidth的值，那么这时候getWidth()与getMeasuredWidth的值就不会再相同了，当然一般也不会这么干… 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"如何让Service常驻内存","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/如何让Service常驻内存/","text":"如何让Service常驻内存我非常鄙视这种行文，一个公司应该想到如何把产品做的更完善，而不是用这些技术来损害用户的利益，来获取自己肮脏的所谓的功能。 Service设置成START_STICKY，kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样 ​通过 startForeground将进程设置为前台进程，做前台服务，优先级和前台应用一个级别​，除非在系统内存非常缺，否则此进程不会被 kill 双进程Service：让2个进程互相保护，其中一个Service被清理后，另外没被清理的进程可以立即重启进程 QQ黑科技:在应用退到后台后，另起一个只有 1 像素的页面停留在桌面上，让自己保持前台状态，保护自己不被后台清理工具杀死 在已经root的设备下，修改相应的权限文件，将App伪装成系统级的应用（Android4.0系列的一个漏洞，已经确认可行） Android系统中当前进程(Process)fork出来的子进程，被系统认为是两个不同的进程。当父进程被杀死的时候，子进程仍然可以存活，并不受影响。 鉴于目前提到的在Android-Service层做双守护都会失败，我们可以fork出c进程，多进程守护。死循环在那检查是否还存在， 具体的思路如下（Android5.0以下可行） 用C编写守护进程(即子进程)，守护进程做的事情就是循环检查目标进程是否存在，不存在则启动它。 在NDK环境中将1中编写的C代码编译打包成可执行文件(BUILD_EXECUTABLE)。 主进程启动时将守护进程放入私有目录下，赋予可执行权限，启动它即可。 联系厂商，加入白名单 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Volley简介","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Volley源码分析/","text":"Volley源码分析 Volley简介 volley官方地址 在Google I/0 2013中发布了Volley.Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮。 这是Volley名称的由来:a burst or emission of many things or a large amount at once.Volley特别适合数据量不大但是通信频繁的场景。 Github上面已经有大神做了镜像，使用Gradle更方便。Volley On Github Volley使用 Volley的使用非常方便。 首先就是要构建一个RequestQueue的请求队列，它可以缓存所有Http请求，内部处理的非常完善，通常我们整个应用只需要一个RequestQueue对象即可。 创建StringRequest对象，并且传入相应的请求地址以及添加请求成功和失败的回调方法。这一步的意思就是创建一个新的网络请求。 将刚才新创建的StringRequest对象加入到RequestQueue队列中。这样就相当于会去执行该请求。等到执行成功后就可以在StringRequest中设置的回调方法里面获取到相应的结果。总结一下，其实挺像我们浏览器的操作，第一步打开浏览器，第二步输入URL地址第三步按回车去执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class HttpUtil &#123; private static HttpUtil instance; private RequestQueue mQueue; private HttpUtil(Context context) &#123; mQueue = Volley.newRequestQueue(context); &#125; public static synchronized HttpUtil getInstance(Context context) &#123; if (instance == null) &#123; instance = new HttpUtil(context.getApplicationContext()); &#125; return instance; &#125; public Request sendGetRequest(String url, final HttpListener listener) &#123; StringRequest stringRequest = new StringRequest(url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; if (listener != null) &#123; listener.onResponse(response); &#125; &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; if (listener != null) &#123; listener.onErrorResponse(error); &#125; &#125; &#125;); mQueue.add(stringRequest); return stringRequest; &#125; public Request sendPostRequest(String url, final Map&lt;String, String&gt; map, final HttpListener listener) &#123; final StringRequest stringRequest = new StringRequest(Request.Method.POST, url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; if (listener != null) &#123; listener.onResponse(response); &#125; &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; if (listener != null) &#123; listener.onErrorResponse(error); &#125; &#125; &#125;) &#123; @Override protected Map&lt;String, String&gt; getParams() throws AuthFailureError &#123; return map; &#125; &#125;; mQueue.add(stringRequest); return stringRequest; &#125; /** * Response listener of HttpUtil. */ public interface HttpListener &#123; void onResponse(String response); void onErrorResponse(VolleyError error); &#125;&#125; 到这里我们就简单的介绍了它的使用，当然还有一些其他的Request对象例如JsonRequest等，他们的使用方法都是一样的，这里就不再说明了。当然Volley里面还提供了对图片的处理，例如NetworkImageView空间和ImageRequest等，因为这里图片用到的不太多，所以暂时不去分析了。 接下来我们就从源码的角度去分析一下：这里我们都知道使用的时候最新要初始化一个RequestQueue所以，我们首先看一下Volley.newRequestQueue方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class Volley &#123; /** Default on-disk cache directory. */ private static final String DEFAULT_CACHE_DIR = \"volley\"; /** * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it. * You may set a maximum size of the disk cache in bytes. * * @param context A &#123;@link Context&#125; to use for creating the cache dir. * @param stack An &#123;@link HttpStack&#125; to use for the network, or null for default. * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size. * @return A started &#123;@link RequestQueue&#125; instance. */ public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) &#123; File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); String userAgent = \"volley/0\"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0); // 使用包名和versionCode作为userAgent userAgent = packageName + \"/\" + info.versionCode; &#125; catch (NameNotFoundException e) &#123; &#125; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; // 在9及以上Volleys使用HttpURLConnection，9一下使用HttpClient。这里是有原因的，因为在9之前HttpURLConnection有Bug。 // 那HttpClient那么好为什么不一直使用它，要在9及以后使用HttpURLConnection呢？这里也是有原因的。从9开始HttpURLConnection // 将自动添加`Accept-Encoding:gzip`头字段到`request`请求中，并做相应处理，一般我们请求都是字符串，所以压缩可以使数据大小大幅降低。 // 但是这也会带来问题的，之前开发中就遇到过。因为启用了压缩，所以`Content-Lenght`字段返回的是压缩后的大小。使用`getContentLength()` // 方法去分配解压缩后数据大小是错误的。应该从response中读取字节直到`InputStream.read()`返回-1为止。当时我们在开发下载时就遇到过这个 // 问题，在下载视频时没有问题，但是在下载小说的时候就会发现`content-length`返回值不对。 // 总结一下就是在9之前HttpClient的bug更少，而HttpURLConnection存在严重的Bug。但是从9开始HttpURLConnection更小巧，API更简单，压缩以及 // response cache的使用减少了网络流量，提高了网络速度，也就更省电，所以更适合在Android中使用 stack = new HurlStack(); &#125; else &#123; // Prior to Gingerbread, HttpUrlConnection was unreliable. // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); &#125; &#125; // 创建BasicNetwork对象，下面会介绍BasicNetwork(HttpStack)方法的内部实现 Network network = new BasicNetwork(stack); RequestQueue queue; if (maxDiskCacheBytes &lt;= -1) &#123; // 如果不指定大小的话，默认大小为5M // No maximum size specified queue = new RequestQueue(new DiskBasedCache(cacheDir), network); &#125; else &#123; // Disk cache size specified queue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network); &#125; queue.start(); return queue; &#125; /** * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it. * You may set a maximum size of the disk cache in bytes. * * @param context A &#123;@link Context&#125; to use for creating the cache dir. * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size. * @return A started &#123;@link RequestQueue&#125; instance. */ public static RequestQueue newRequestQueue(Context context, int maxDiskCacheBytes) &#123; return newRequestQueue(context, null, maxDiskCacheBytes); &#125; /** * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it. * * @param context A &#123;@link Context&#125; to use for creating the cache dir. * @param stack An &#123;@link HttpStack&#125; to use for the network, or null for default. * @return A started &#123;@link RequestQueue&#125; instance. */ public static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123; return newRequestQueue(context, stack, -1); &#125; /** * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it. * * @param context A &#123;@link Context&#125; to use for creating the cache dir. * @return A started &#123;@link RequestQueue&#125; instance. */ public static RequestQueue newRequestQueue(Context context) &#123; return newRequestQueue(context, null); &#125;&#125; 接着来看一上上面提到的new BasicNetwork(HttpStack)方法的实现,可以看到他内部的缓存大小是4k1234567891011121314151617181920212223private static int DEFAULT_POOL_SIZE = 4096;protected final HttpStack mHttpStack;protected final ByteArrayPool mPool;/** * @param httpStack HTTP stack to be used */public BasicNetwork(HttpStack httpStack) &#123; // If a pool isn't passed in, then build a small default pool that will give us a lot of // benefit and not use too much memory. this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));&#125;/** * @param httpStack HTTP stack to be used * @param pool a buffer pool that improves GC performance in copy operations */public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) &#123; mHttpStack = httpStack; mPool = pool;&#125; 接着我们还要分析一下RequestQueue的构造方法以及start()方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275/** * A request dispatch queue with a thread pool of dispatchers. * * Calling &#123;@link #add(Request)&#125; will enqueue the given Request for dispatch, * resolving from either cache or network on a worker thread, and then delivering * a parsed response on the main thread. *//** * A request dispatch queue with a thread pool of dispatchers. * * Calling &#123;@link #add(Request)&#125; will enqueue the given Request for dispatch, * resolving from either cache or network on a worker thread, and then delivering * a parsed response on the main thread. */public class RequestQueue &#123; /** Used for generating monotonically-increasing sequence numbers for requests. */ private AtomicInteger mSequenceGenerator = new AtomicInteger(); /** * Staging area for requests that already have a duplicate request in flight. * * &lt;ul&gt; * &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache * key.&lt;/li&gt; * &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request * is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt; * &lt;/ul&gt; */ private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;(); /** * The set of all requests currently being processed by this RequestQueue. A Request * will be in this set if it is waiting in any queue or currently being processed by * any dispatcher. */ private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;(); // cache队列 /** The cache triage queue. */ private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;(); // 网络请求队列 /** The queue of requests that are actually going out to the network. */ private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;(); /** Number of network request dispatcher threads to start. */ private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4; /** Cache interface for retrieving and storing responses. */ private final Cache mCache; /** Network interface for performing requests. */ private final Network mNetwork; /** Response delivery mechanism. */ private final ResponseDelivery mDelivery; /** The network dispatchers. */ private NetworkDispatcher[] mDispatchers; /** The cache dispatcher. */ private CacheDispatcher mCacheDispatcher; /** * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called. * * @param cache A Cache to use for persisting responses to disk * @param network A Network interface for performing HTTP requests * @param threadPoolSize Number of network dispatcher threads to create * @param delivery A ResponseDelivery interface for posting responses and errors */ public RequestQueue(Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) &#123; mCache = cache; mNetwork = network; mDispatchers = new NetworkDispatcher[threadPoolSize]; mDelivery = delivery; &#125; /** * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called. * * @param cache A Cache to use for persisting responses to disk * @param network A Network interface for performing HTTP requests * @param threadPoolSize Number of network dispatcher threads to create */ public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123; this(cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper()))); &#125; /** * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called. * * @param cache A Cache to use for persisting responses to disk * @param network A Network interface for performing HTTP requests */ public RequestQueue(Cache cache, Network network) &#123; // 默认大小为4 this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE); &#125; /** * Starts the dispatchers in this queue. */ public void start() &#123; stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. // 初始化RequestQueue之后就会调用start方法，内部会开启CacheDispatcher,也是Thread的子类，后面再看里面具体的run方法 mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. for (int i = 0; i &lt; mDispatchers.length; i++) &#123; // 创建4个(默认是4个)NetworkDispatcher一直去执行, NetworkDispatcher是Thread的子类，他会不断的去从mNetworkQueue中取出Requet并用 // 并用mNetwork去执行，执行完成后再使用mDelivery去分发相应的结果 NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125; // 就好像一个工厂一启动，里面就分配了5个搬运工，一个负责搬运cache里面的的请求，4个负责搬运network中的。启动后他们就开始待命 // 一旦有活来了，就开始去取出活开始干。 &#125; /** * Stops the cache and network dispatchers. */ public void stop() &#123; if (mCacheDispatcher != null) &#123; mCacheDispatcher.quit(); &#125; for (int i = 0; i &lt; mDispatchers.length; i++) &#123; if (mDispatchers[i] != null) &#123; mDispatchers[i].quit(); &#125; &#125; &#125; /** * Gets a sequence number. */ public int getSequenceNumber() &#123; return mSequenceGenerator.incrementAndGet(); &#125; /** * Gets the &#123;@link Cache&#125; instance being used. */ public Cache getCache() &#123; return mCache; &#125; /** * A simple predicate or filter interface for Requests, for use by * &#123;@link RequestQueue#cancelAll(RequestFilter)&#125;. */ public interface RequestFilter &#123; public boolean apply(Request&lt;?&gt; request); &#125; /** * Cancels all requests in this queue for which the given filter applies. * @param filter The filtering function to use */ public void cancelAll(RequestFilter filter) &#123; synchronized (mCurrentRequests) &#123; for (Request&lt;?&gt; request : mCurrentRequests) &#123; if (filter.apply(request)) &#123; request.cancel(); &#125; &#125; &#125; &#125; /** * Cancels all requests in this queue with the given tag. Tag must be non-null * and equality is by identity. */ public void cancelAll(final Object tag) &#123; if (tag == null) &#123; throw new IllegalArgumentException(\"Cannot cancelAll with a null tag\"); &#125; cancelAll(new RequestFilter() &#123; @Override public boolean apply(Request&lt;?&gt; request) &#123; return request.getTag() == tag; &#125; &#125;); &#125; /** * Adds a Request to the dispatch queue. * @param request The request to service * @return The passed-in request */ public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123; // Tag the request as belonging to this queue and add it to the set of current requests. request.setRequestQueue(this); synchronized (mCurrentRequests) &#123; // 添加到mCurrentRequests中，在执行完后的finish方法中会去移除该请求。 mCurrentRequests.add(request); &#125; // Process requests in the order they are added. request.setSequence(getSequenceNumber()); request.addMarker(\"add-to-queue\"); // 判断一下该请求能否进行缓存，如果不能缓存就直接添加到网络请求的队列中。这个能不能缓存是怎么判断的？其实就是根据Request中的一个变量来判断。 // 默认情况下所有的请求都是可以缓存的，可以通过Request.setShouldCache(false)方法，来将其设置为不可缓存状态。 // If the request is uncacheable, skip the cache queue and go straight to the network. if (!request.shouldCache()) &#123; mNetworkQueue.add(request); return request; &#125; // Insert request into stage if there's already a request with the same cache key in flight. synchronized (mWaitingRequests) &#123; String cacheKey = request.getCacheKey(); if (mWaitingRequests.containsKey(cacheKey)) &#123; // There is already a request in flight. Queue up. Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey); if (stagedRequests == null) &#123; stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;(); &#125; stagedRequests.add(request); mWaitingRequests.put(cacheKey, stagedRequests); if (VolleyLog.DEBUG) &#123; VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey); &#125; &#125; else &#123; // 如果能缓存，并且缓存线程中没有的时候就讲该请求添加到缓存队列中 // Insert 'null' queue for this cacheKey, indicating there is now a request in // flight. mWaitingRequests.put(cacheKey, null); mCacheQueue.add(request); &#125; return request; &#125; &#125; /** * Called from &#123;@link Request#finish(String)&#125;, indicating that processing of the given request * has finished. * * &lt;p&gt;Releases waiting requests for &lt;code&gt;request.getCacheKey()&lt;/code&gt; if * &lt;code&gt;request.shouldCache()&lt;/code&gt;.&lt;/p&gt; */ void finish(Request&lt;?&gt; request) &#123; // Remove from the set of requests currently being processed. synchronized (mCurrentRequests) &#123; mCurrentRequests.remove(request); &#125; if (request.shouldCache()) &#123; synchronized (mWaitingRequests) &#123; String cacheKey = request.getCacheKey(); Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey); if (waitingRequests != null) &#123; if (VolleyLog.DEBUG) &#123; VolleyLog.v(\"Releasing %d waiting requests for cacheKey=%s.\", waitingRequests.size(), cacheKey); &#125; // Process all queued up requests. They won't be considered as in flight, but // that's not a problem as the cache has been primed by 'request'. mCacheQueue.addAll(waitingRequests); &#125; &#125; &#125; &#125;&#125; 看到这里基本都能看的差不多了。官方文档中有句话说的很好，这里用他来总结一下A RequestQueue needs two things to do its job: a network to perform transport of the requests, and a cache to handle caching.顺便再上一张图: 总结完之后我们接着进行分析。因为默认情况下请求都是可缓存的，所以都会被添加到mCacheQueue中。添加该队列之后，就会被开始start方法所制定的cache搬运工去执行，所以我们要看一下CacheDispatcher的实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/** * Provides a thread for performing cache triage on a queue of requests. * * Requests added to the specified cache queue are resolved from cache. * Any deliverable response is posted back to the caller via a * &#123;@link ResponseDelivery&#125;. Cache misses and responses that require * refresh are enqueued on the specified network queue for processing * by a &#123;@link NetworkDispatcher&#125;. */public class CacheDispatcher extends Thread &#123; private static final boolean DEBUG = VolleyLog.DEBUG; /** The queue of requests coming in for triage. */ private final BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue; /** The queue of requests going out to the network. */ private final BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue; /** The cache to read from. */ private final Cache mCache; /** For posting responses. */ private final ResponseDelivery mDelivery; /** Used for telling us to die. */ private volatile boolean mQuit = false; /** * Creates a new cache triage dispatcher thread. You must call &#123;@link #start()&#125; * in order to begin processing. * * @param cacheQueue Queue of incoming requests for triage * @param networkQueue Queue to post requests that require network to * @param cache Cache interface to use for resolution * @param delivery Delivery interface to use for posting responses */ public CacheDispatcher( BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue, Cache cache, ResponseDelivery delivery) &#123; // 将CacheQueue以及networkQueue等传递进来。 mCacheQueue = cacheQueue; mNetworkQueue = networkQueue; mCache = cache; mDelivery = delivery; &#125; /** * Forces this dispatcher to quit immediately. If any requests are still in * the queue, they are not guaranteed to be processed. */ public void quit() &#123; mQuit = true; interrupt(); &#125; @Override public void run() &#123; if (DEBUG) VolleyLog.v(\"start new dispatcher\"); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // Make a blocking call to initialize the cache. /** * Performs any potentially long-running actions needed to initialize the cache; * will be called from a worker thread. */ mCache.initialize(); while (true) &#123; try &#123; // 从缓存队列中取出第一个请求 // Get a request from the cache triage queue, blocking until // at least one is available. final Request&lt;?&gt; request = mCacheQueue.take(); request.addMarker(\"cache-queue-take\"); // If the request has been canceled, don't bother dispatching it. if (request.isCanceled()) &#123; request.finish(\"cache-discard-canceled\"); continue; &#125; // Attempt to retrieve this item from cache. Cache.Entry entry = mCache.get(request.getCacheKey()); if (entry == null) &#123; // 如果缓存中找不到该请求，就把该请求添加到网络请求队列中。 request.addMarker(\"cache-miss\"); // Cache miss; send off to the network dispatcher. mNetworkQueue.put(request); continue; &#125; // 如果缓存中找到了该请求，接下来就判断该缓存是否过期。 // If it is completely expired, just send it to the network. if (entry.isExpired()) &#123; // 过期了也重新添加到网络请求中 request.addMarker(\"cache-hit-expired\"); request.setCacheEntry(entry); mNetworkQueue.put(request); continue; &#125; // 没有过期，就不用再请求了，直接从缓存中取出数据返回即可。 // We have a cache hit; parse its data for delivery back to the request. request.addMarker(\"cache-hit\"); // 这里的意思就是对数据进行解析，后面再看Request.parseNetworkResponse方法。 Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker(\"cache-hit-parsed\"); // 判断缓存数据是否需要刷新，以便使用mDelivery分发结果或者添加到网络请求队列中 if (!entry.refreshNeeded()) &#123; // Completely unexpired cache hit. Just deliver the response. mDelivery.postResponse(request, response); &#125; else &#123; // Soft-expired cache hit. We can deliver the cached response, // but we need to also send the request to the network for // refreshing. request.addMarker(\"cache-hit-refresh-needed\"); request.setCacheEntry(entry); // Mark the response as intermediate. response.intermediate = true; // Post the intermediate response back to the user and have // the delivery then forward the request along to the network. mDelivery.postResponse(request, response, new Runnable() &#123; @Override public void run() &#123; try &#123; mNetworkQueue.put(request); &#125; catch (InterruptedException e) &#123; // Not much we can do about this. &#125; &#125; &#125;); &#125; &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; return; &#125; continue; &#125; &#125; &#125;&#125; 而对于网络请求队列中的任务该如何执行，这里就要看NetworkDispatcher的具体实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * Provides a thread for performing network dispatch from a queue of requests. * * Requests added to the specified queue are processed from the network via a * specified &#123;@link Network&#125; interface. Responses are committed to cache, if * eligible, using a specified &#123;@link Cache&#125; interface. Valid responses and * errors are posted back to the caller via a &#123;@link ResponseDelivery&#125;. */public class NetworkDispatcher extends Thread &#123; /** The queue of requests to service. */ private final BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue; /** The network interface for processing requests. */ private final Network mNetwork; /** The cache to write to. */ private final Cache mCache; /** For posting responses and errors. */ private final ResponseDelivery mDelivery; /** Used for telling us to die. */ private volatile boolean mQuit = false; /** * Creates a new network dispatcher thread. You must call &#123;@link #start()&#125; * in order to begin processing. * * @param queue Queue of incoming requests for triage * @param network Network interface to use for performing requests * @param cache Cache interface to use for writing responses to cache * @param delivery Delivery interface to use for posting responses */ public NetworkDispatcher(BlockingQueue&lt;Request&lt;?&gt;&gt; queue, Network network, Cache cache, ResponseDelivery delivery) &#123; mQueue = queue; mNetwork = network; mCache = cache; mDelivery = delivery; &#125; /** * Forces this dispatcher to quit immediately. If any requests are still in * the queue, they are not guaranteed to be processed. */ public void quit() &#123; mQuit = true; interrupt(); &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) private void addTrafficStatsTag(Request&lt;?&gt; request) &#123; // Tag the request (if API &gt;= 14) if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; TrafficStats.setThreadStatsTag(request.getTrafficStatsTag()); &#125; &#125; @Override public void run() &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); while (true) &#123; long startTimeMs = SystemClock.elapsedRealtime(); Request&lt;?&gt; request; try &#123; // Take a request from the queue. request = mQueue.take(); &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; return; &#125; continue; &#125; try &#123; request.addMarker(\"network-queue-take\"); // If the request was cancelled already, do not perform the // network request. if (request.isCanceled()) &#123; request.finish(\"network-discard-cancelled\"); continue; &#125; addTrafficStatsTag(request); // mNetwork会去执行对应的request请求，后面再看里面的具体实现 // Perform the network request. NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker(\"network-http-complete\"); // If the server returned 304 AND we delivered a response already, // we're done -- don't deliver a second identical response. if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish(\"not-modified\"); continue; &#125; // 将网络请求返回的NetworkResponse交给request.parseNetworkResponse进行处理 // Parse the response here on the worker thread. Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker(\"network-parse-complete\"); // Write to cache if applicable. // TODO: Only update cache metadata instead of entire record for 304s. if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(\"network-cache-written\"); &#125; // Post the response back. request.markDelivered(); // mDelivery进行分发 mDelivery.postResponse(request, response); &#125; catch (VolleyError volleyError) &#123; volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); parseAndDeliverNetworkError(request, volleyError); &#125; catch (Exception e) &#123; VolleyLog.e(e, \"Unhandled exception %s\", e.toString()); VolleyError volleyError = new VolleyError(e); volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); mDelivery.postError(request, volleyError); &#125; &#125; &#125; private void parseAndDeliverNetworkError(Request&lt;?&gt; request, VolleyError error) &#123; error = request.parseNetworkError(error); mDelivery.postError(request, error); &#125;&#125; 上面会执行到mNetwork.performRequest方法，而Network是一个接口，具体的实现要看BaseNetwork中的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102@Overridepublic NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; Map&lt;String, String&gt; responseHeaders = Collections.emptyMap(); try &#123; // Gather headers. Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); addCacheHeaders(headers, request.getCacheEntry()); // 调用mHttpStack.performRequest方法，这里就是newRequestQueue中创建的部分，9及以上为HurlStack，9以下为HttpClientStach,具体就是真正执行网络请求的部分了。 httpResponse = mHttpStack.performRequest(request, headers); StatusLine statusLine = httpResponse.getStatusLine(); int statusCode = statusLine.getStatusCode(); responseHeaders = convertHeaders(httpResponse.getAllHeaders()); // Handle cache validation. if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123; Entry entry = request.getCacheEntry(); if (entry == null) &#123; return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null, responseHeaders, true, SystemClock.elapsedRealtime() - requestStart); &#125; // A HTTP 304 response does not have all header fields. We // have to use the header fields from the cache entry plus // the new ones from the response. // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5 entry.responseHeaders.putAll(responseHeaders); return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data, entry.responseHeaders, true, SystemClock.elapsedRealtime() - requestStart); &#125; // Handle moved resources if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123; String newUrl = responseHeaders.get(\"Location\"); request.setRedirectUrl(newUrl); &#125; // Some responses such as 204s do not have content. We must check. if (httpResponse.getEntity() != null) &#123; responseContents = entityToBytes(httpResponse.getEntity()); &#125; else &#123; // Add 0 byte response as a way of honestly representing a // no-content request. responseContents = new byte[0]; &#125; // if the request is slow, log it. long requestLifetime = SystemClock.elapsedRealtime() - requestStart; logSlowRequests(requestLifetime, request, responseContents, statusLine); if (statusCode &lt; 200 || statusCode &gt; 299) &#123; throw new IOException(); &#125; return new NetworkResponse(statusCode, responseContents, responseHeaders, false, SystemClock.elapsedRealtime() - requestStart); &#125; catch (SocketTimeoutException e) &#123; attemptRetryOnException(\"socket\", request, new TimeoutError()); &#125; catch (ConnectTimeoutException e) &#123; attemptRetryOnException(\"connection\", request, new TimeoutError()); &#125; catch (MalformedURLException e) &#123; throw new RuntimeException(\"Bad URL \" + request.getUrl(), e); &#125; catch (IOException e) &#123; int statusCode = 0; NetworkResponse networkResponse = null; if (httpResponse != null) &#123; statusCode = httpResponse.getStatusLine().getStatusCode(); &#125; else &#123; throw new NoConnectionError(e); &#125; if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123; VolleyLog.e(\"Request at %s has been redirected to %s\", request.getOriginUrl(), request.getUrl()); &#125; else &#123; VolleyLog.e(\"Unexpected response code %d for %s\", statusCode, request.getUrl()); &#125; if (responseContents != null) &#123; networkResponse = new NetworkResponse(statusCode, responseContents, responseHeaders, false, SystemClock.elapsedRealtime() - requestStart); if (statusCode == HttpStatus.SC_UNAUTHORIZED || statusCode == HttpStatus.SC_FORBIDDEN) &#123; attemptRetryOnException(\"auth\", request, new AuthFailureError(networkResponse)); &#125; else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123; attemptRetryOnException(\"redirect\", request, new AuthFailureError(networkResponse)); &#125; else &#123; // TODO: Only throw ServerError for 5xx status codes. throw new ServerError(networkResponse); &#125; &#125; else &#123; throw new NetworkError(networkResponse); &#125; &#125; &#125;&#125; 上面调用了mHttpStack.performRequest的方法，这里就以9及以上的HurlStack类来看下源码：12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError &#123; String url = request.getUrl(); HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.putAll(request.getHeaders()); map.putAll(additionalHeaders); if (mUrlRewriter != null) &#123; String rewritten = mUrlRewriter.rewriteUrl(url); if (rewritten == null) &#123; throw new IOException(\"URL blocked by rewriter: \" + url); &#125; url = rewritten; &#125; URL parsedUrl = new URL(url); HttpURLConnection connection = openConnection(parsedUrl, request); for (String headerName : map.keySet()) &#123; connection.addRequestProperty(headerName, map.get(headerName)); &#125; setConnectionParametersForRequest(connection, request); // Initialize HttpResponse with data from the HttpURLConnection. ProtocolVersion protocolVersion = new ProtocolVersion(\"HTTP\", 1, 1); int responseCode = connection.getResponseCode(); if (responseCode == -1) &#123; // -1 is returned by getResponseCode() if the response code could not be retrieved. // Signal to the caller that something was wrong with the connection. throw new IOException(\"Could not retrieve response code from HttpUrlConnection.\"); &#125; StatusLine responseStatus = new BasicStatusLine(protocolVersion, connection.getResponseCode(), connection.getResponseMessage()); BasicHttpResponse response = new BasicHttpResponse(responseStatus); response.setEntity(entityFromConnection(connection)); for (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123; if (header.getKey() != null) &#123; Header h = new BasicHeader(header.getKey(), header.getValue().get(0)); response.addHeader(h); &#125; &#125; return response;&#125; 接下来还要看一下mDelivery.postResponse(request, response);这里的,mDelivery就是new ExecutorDelivery(new Handler(Looper.getMainLooper()))123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Delivers responses and errors. */public class ExecutorDelivery implements ResponseDelivery &#123; /** Used for posting responses, typically to the main thread. */ private final Executor mResponsePoster; /** * Creates a new response delivery interface. * @param handler &#123;@link Handler&#125; to post responses on */ public ExecutorDelivery(final Handler handler) &#123; // Make an Executor that just wraps the handler. mResponsePoster = new Executor() &#123; @Override public void execute(Runnable command) &#123; handler.post(command); &#125; &#125;; &#125; /** * Creates a new response delivery interface, mockable version * for testing. * @param executor For running delivery tasks */ public ExecutorDelivery(Executor executor) &#123; mResponsePoster = executor; &#125; @Override public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123; postResponse(request, response, null); &#125; @Override public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker(\"post-response\"); // 内部会调用execute方法 mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable)); &#125; @Override public void postError(Request&lt;?&gt; request, VolleyError error) &#123; request.addMarker(\"post-error\"); Response&lt;?&gt; response = Response.error(error); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null)); &#125; /** * A Runnable used for delivering network responses to a listener on the * main thread. */ @SuppressWarnings(\"rawtypes\") private class ResponseDeliveryRunnable implements Runnable &#123; private final Request mRequest; private final Response mResponse; private final Runnable mRunnable; public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) &#123; mRequest = request; mResponse = response; mRunnable = runnable; &#125; @SuppressWarnings(\"unchecked\") @Override public void run() &#123; // 这里就是重点部分了 // If this request has canceled, finish it and don't deliver. if (mRequest.isCanceled()) &#123; mRequest.finish(\"canceled-at-delivery\"); return; &#125; // 调用mRequest的deliverResponse或者deliverError进行分发 // Deliver a normal response or error, depending. if (mResponse.isSuccess()) &#123; mRequest.deliverResponse(mResponse.result); &#125; else &#123; mRequest.deliverError(mResponse.error); &#125; // If this is an intermediate response, add a marker, otherwise we're done // and the request can be finished. if (mResponse.intermediate) &#123; mRequest.addMarker(\"intermediate-response\"); &#125; else &#123; // 执行finish方法 mRequest.finish(\"done\"); &#125; // If we have been provided a post-delivery runnable, run it. if (mRunnable != null) &#123; mRunnable.run(); &#125; &#125; &#125;&#125; 这里再看一下mRequest的deliverResponse方法。Request接口中没有实现该方法，具体我们以StringRequest为例看一下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * A canned request for retrieving the response body at a given URL as a String. */public class StringRequest extends Request&lt;String&gt; &#123; private final Listener&lt;String&gt; mListener; /** * Creates a new request with the given method. * * @param method the request &#123;@link Method&#125; to use * @param url URL to fetch the string at * @param listener Listener to receive the String response * @param errorListener Error listener, or null to ignore errors */ public StringRequest(int method, String url, Listener&lt;String&gt; listener, ErrorListener errorListener) &#123; super(method, url, errorListener); mListener = listener; &#125; /** * Creates a new GET request. * * @param url URL to fetch the string at * @param listener Listener to receive the String response * @param errorListener Error listener, or null to ignore errors */ public StringRequest(String url, Listener&lt;String&gt; listener, ErrorListener errorListener) &#123; this(Method.GET, url, listener, errorListener); &#125; @Override protected void deliverResponse(String response) &#123; // 回调 mListener.onResponse(response); &#125; @Override protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123; String parsed; try &#123; parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); &#125; catch (UnsupportedEncodingException e) &#123; parsed = new String(response.data); &#125; return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response)); &#125;&#125; 接着看一下mRequest.finish方法的实现:1234567891011121314151617181920212223242526272829303132333435/** * Notifies the request queue that this request has finished (successfully or with error). * * &lt;p&gt;Also dumps all events from this request's event log; for debugging.&lt;/p&gt; */void finish(final String tag) &#123; if (mRequestQueue != null) &#123; // 内部调用了mRequestQueue的finish方法，也就是把请求从请求队列中移除。 mRequestQueue.finish(this); &#125; if (MarkerLog.ENABLED) &#123; final long threadId = Thread.currentThread().getId(); if (Looper.myLooper() != Looper.getMainLooper()) &#123; // If we finish marking off of the main thread, we need to // actually do it on the main thread to ensure correct ordering. Handler mainThread = new Handler(Looper.getMainLooper()); mainThread.post(new Runnable() &#123; @Override public void run() &#123; mEventLog.add(tag, threadId); mEventLog.finish(this.toString()); &#125; &#125;); return; &#125; mEventLog.add(tag, threadId); mEventLog.finish(this.toString()); &#125; else &#123; long requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime; if (requestTime &gt;= SLOW_REQUEST_THRESHOLD_MS) &#123; VolleyLog.d(\"%d ms: %s\", requestTime, this.toString()); &#125; &#125;&#125; 到这里就全部分析完了。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"布局优化","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/布局优化/","text":"布局优化 去除不必要的嵌套和节点 这是最基本的一条，但也是最不好做到的一条，往往不注意的时候难免会一些嵌套等。 首次不需要的节点设置为GONE或使用ViewStud. 使用Relativelayout代替LinearLayout.平时写布局的时候要多注意，写完后可以通过Hierarchy Viewer或在手机上通过开发者选项中的显示布局边界来查看是否有不必要的嵌套。 使用include include可以用于将布局中一些公共的部分提取出来。在需要的时候使用即可，比喻一些页面统一的loading页。 include标签的layout属性指定所要包含的布局文件，我们也可以通过android:id或者一些其他的属性来覆盖被引入布局的根节点所对应的属性值。 123&lt;includelayout=\"@layout/loading\"android:id=\"@+id/loading_main\" /&gt; loading.xml内容为： 1234567891011121314151617181920&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ProgressBar android:id=\"@+id/pb_loadiing\" android:layout_width=\"28dip\" android:layout_height=\"28dip\" android:layout_centerInParent=\"true\" android:indeterminateDrawable=\"@drawable/progressbar_anim_drawable\" /&gt; &lt;TextView android:layout_below=\"@id/pb_loadiing\" android:layout_centerHorizontal=\"true\" android:layout_marginTop=\"10dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"loading...\" android:textSize=\"15sp\" /&gt;&lt;/RelativeLayout&gt; 使用&lt;merge&gt;标签 merge可以有效的解决布局的层级关系。我们通过一个例子来说明一下： 123456789101112131415161718192021&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\"&gt; &lt;ImageView android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:scaleType=\"center\" android:src=\"@drawable/ic_launcher\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"20dip\" android:textSize=\"22sp\" android:textColor=\"#990000\" android:layout_gravity=\"center_horizontal|bottom\" android:text=\"TEST\" /&gt;&lt;/FrameLayout&gt; 我们在一个页面中显示该部分内容，运行后观察Hierarchy Viewer。 我们会发现除了我们布局最外层还会有一层FrameLayout，这是因为Activity内容视图的parent view就是一个FrameLayout，所以对于我们来说无意中已经多了一层毫无意义的布局。 接下来merge的功能就能发挥了，修改代码如下。 123456789101112131415161718&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;ImageView android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:scaleType=\"center\" android:src=\"@drawable/ic_launcher\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"20dip\" android:textSize=\"22sp\" android:textColor=\"#990000\" android:layout_gravity=\"center_horizontal|bottom\" android:text=\"TEST\" /&gt;&lt;/merge&gt; 接下来我们在用Hierarchy Viewer观察就会发现完美的去掉了一层FrameLayout 当然上面我们使用merge是因为跟布局正好是FrameLayout并且没有backgroud和padding等这些属性。如果根本局是LinearLayout等，就没法直接使用merge了。 在include的时候很容易造成布局层级嵌套过多，结合merge使用能有效解决这个问题。 使用ViewStub ViewStub标签与include一样可以用来引入一个外部布局，但是Viewstub引入的布局默认不会解析与显示，宽高为0，View也为null,这样就会在解析layout时节省cpu和内存。简单的理解就是ViewStub是include加上GONE.ViewStub常用来引入那些默认不会显示，只在特殊情况下显示的布局，如进度布局、网络失败显示的刷新布局、信息出错出现的提示布局等. 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; …… &lt;ViewStub android:id=\"@+id/network_unreachble\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout=\"@layout/network_unreachble\" /&gt;&lt;/RelativeLayout&gt; 在代码中通过(ViewStub)findViewById(id)找到ViewStub，使用inflate()展开ViewStub,然后得到子View，如下： 12345678910111213141516171819private View mNetErrorView;private void showNetError() &#123; if (mNetErrorView != null) &#123; mNetErrorView.setVisibility(View.VISIBLE); return; &#125; ViewStub stub = (ViewStub)findViewById(R.id.network_unreachble); // 解析并且显示该部分，返回值就是解析后的该`View` mNetErrorView = stub.inflate(); Button networkSetting = (Button)mNetErrorView.findViewById(R.id.bt_network);&#125;private void showNormal() &#123; if (mNetErrorView != null) &#123; mNetErrorView.setVisibility(View.GONE); &#125;&#125; 或者也可以通过第二种方式: 12345View viewStub = findViewById(R.id.network_unreachble);// ViewStub被展开后的布局所替换viewStub.setVisibility(View.VISIBLE); // 获取展开后的布局mNetErrorView = findViewById(R.id.network_unreachble); 减少不必要的Inflate 如上一步中stub.infalte()后将该View进行记录或者是ListView中item inflate的时候。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"发布library到Maven仓库","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/发布library到Maven仓库/","text":"发布library到Maven仓库在Android Studio中想要使用一些第三方类库的时候非常方便，只需要在build.gradle中加入一行代码就可以了：123dependencies &#123; compile 'com.google.code.gson:gson:2.3.1'&#125; 刚从Eclipse转过来的时候感觉太方便了，也不用下jar包然后拷贝到libs目录了，重要的是以后升级起来灰常方便，改个数字就好了。那究竟它里面是怎么运转的呢？其实Android Studio是从Maven仓库中下载所配置的libraray。总的来说，Android只有两种存放library的服务器就是jCenter和Maven Central: jCenter jCenter是由bintray维护的Maven仓库。你可以在这里查看它所有的library。 想要在项目中使用jCenter必须要在项目的build.gradle中像如下这样进行声明： 12345 allprojects &#123; repositories &#123; jcenter() &#125;&#125; Maven Central Maven Central是由sonatype维护的Maven仓库。想要在项目中使用Maven Central需要在项目的build.gradle文件中像下面这样进行声明: 12345678910111213141516171819202122232425262728293031323334353637 allprojects &#123; repositories &#123; mavenCentral() &#125; &#125; ``` 虽然`jCenter`和`Maven Central`都是`Android`标准的`library maven`仓库，但是他俩是由不同提供者维护，并且存放到完全不同的服务器上，所以他俩之间毫无关系。 除了这两个标准的服务器外，如果我们使用的`library`作者把该`library`放到自己的服务器上，我们还可以自己定义特有的`Maven`仓库服务器。例如`Twitter`的`Fabric.io`就是这种情况，它们在[https://maven.fabric.io/public](https://maven.fabric.io/public)上维护了一个自己的`Maven`仓库，如果你想使用`Fabric.io`上的`library`你必须要自己定义仓库的`url`: ```java repositories &#123; maven &#123; url 'https://maven.fabric.io/public' &#125; &#125; 然后才能正常使用 dependencies &#123; compile 'com.crashlytics.sdk.android:crashlytics:2.2.4@aar' &#125; ``` 上传到自建服务器需要定义仓库的`url`，所以会比上传到标准的`maven`仓库使用起来要更麻烦。 至于上传到`jCenter`还是`Maven Central`上面就要看开发者个人的爱好了，当然在这两个上面都上传是最方便的。在`Android Studio`开始的几个版本中，它将`Maven central` 作为默认仓库。新建项目之后`build.gradle`中会自动生成`Maven central`仓库的配置。 但是`Maven Central`最大的问题就是上传`library`非常困难，同时还会由安全方面的原因，所以后来`Android Studio`将默认仓库替换成`jCenter`。所以最近的几个版本中创建项目之后,`build.gradle`中会默认定义`jCenter`而不是`Maven Central`。 `jCenter`相对`Maven Central`来说更好的几个主要原因: - `jCenter`通过`CDN`发送`library`，开发者会由更快的下载体验。- `jCenter`作为世界最大的`Java`仓库，所以它上面的`library`会更多。- `jCenter`上传`library`更简单，不需要像在`Maven Central`上那么复杂。- `jCenter`的用户界面更友好。- `jCenter`的`bintray`网站上可以通过一键实现将`library`上传到`Maven Central`上。所以我们后面要讲的就是如何上传`library`到`bintray`的`jCenter`中然后再一键上传到`Maven Central`上。 说之前先通过`picasso`为例认识一下几个主要的部分: 我们在使用`picasso`时，它会告诉我们按照如下使用： ```javacompile 'com.squareup.picasso:picasso:2.5.2' 或者12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.picasso&lt;/groupId&gt; &lt;artifactId&gt;picasso&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt;&lt;/dependency&gt; 这两种方法分别对应了jCenter和Maven Central中的使用方法.jCenter中com.squareup.picasso就是grounId，通常我们以开发者的报名后面紧跟library的名字来命名groupId, picasso是artifactId,artifactId也就是library真实的名称。,后面的2.5.2就是当前的version. 看到这里应该清楚其实就是Android Studio从Maven服务器上去下载我们所配置的library然后与我们项目一起进行编译。从Maven仓库上下载的是该library的jar或者aar文件。 仓库中存储的有两种文件类型的library：jar和aar。jar包大家都知道。那什么是aar呢？aar是在jar的基础上进行开发的，这是因为Androd Library需要植入一些特有的文件，例如资源文件、assets、jni、清单文件等。而这些都不是jar的标准，因为aar就是在jar包的基础上新增了对其他文件的封装。当然他和jar包一样，在本质上都是zip包，下面我们看一下aar的目录结构:123456789- /AndroidManifest.xml- /classes.jar- /res/- /R.txt- /assets/- /libs/*.jar- /jni/&lt;abi&gt;/*.so- /proguard.txt- /lint.jar 讲到这里已经清楚了groupId、artifactId以及aar了，那接下来我们就讲一下具体的发布流程了: 在Bintray上创建一个包 登陆bintray。 选择Maven后进入。 添加新包。 填写包信息 包名这里对于单词之间要用-分割。 然后会提示已经上传。到这里我们已经在bintray上创建了一个Maven仓库，接下来要做的就是上传library。 在Sonatype上传件一个Maven Central账户。 注册Sonatype账号 在Sonatype上注册账号。 注册完登陆后需要在JIRA中创建一个issue，这样他就会允许你上传匹配Maven Central提供的GROUP_ID的library。 Project: Community Support - Open Source Project Repository Hosting Issue Type: New Project Summary: 你的 library名称的概要，比如The Cheese Library。 Group Id: 输入根GROUP_ID，比如， com.charonchui。一旦批准之后，每个以com.charon开始的library都允许被上传到仓库，比如com.charonchui.xxx。 Project URL: 输入任意一个你想贡献的library的URL，比如， https://github.com/CharonChui/CyberLink4Android。 SCM URL: 版本控制的URL，比如 https://github.com/CharonChui/CyberLink4Android.git。 其他的都不用管，写完之后创建就可以了。 然后就是开始等，大约一周左右就会获准将自己的library分享到Maven Central。 下面就是Bintray中的账户选项中填写Sonatype用户名。 开启自动注册功能，为了能让我们通过jcenter上传的libraray自动发布到Maven Central中 使用下面的命令生成一个key。如果是windows用户需要使用cygwin。否则不能执行 gpg --gen-key 后面会一步步的进行提示，按照提示输入相应内容就好。 创建完成后可以使用gpg --list-keys命令来查看创建key的信息. 接下来需要将生成的key上传到keyserver上才能发挥作用。 如上图所示将key上传到keyserver让它发挥作用，运行如下命令，将下面的PUBLIC_KEY_ID替换成上面2048R/后面的数字，如我的是B861C367 gpg --keyserver hkp://pool.sks-keyservers.net --send-keys PUBLIC_KEY_ID 运行以下命令 12gpg -a --export yourmail@email.com &gt; public_key_sender.asc gpg -a --export-secret-key yourmail@email.com &gt; private_key_sender.asc 运行完上面的两个命令后，会在当前目录分别生成public_key_sender.asc以及private_key_sender.ask两个文件，下面我们就打开这两个文件的内容，填写到Bintray的Edit Profile页面中的GPG注册部分。 开启自动注册。 在Edit Your Profile页面找到Repositories后，选择maven后的edit。然后将GPG sign uploaded files using Bintray’s public/private key pair.打上勾就可以了。 接下来就是如何将Android Studio中的Library Module进行上传首先是修改项目的build.gradle文件。如下:123456789101112131415161718192021222324// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // 注意gradle版本要再1.1.2以上，之前的版本存在问题。如果在工程中/gradle/wrapper/gradle-wrapper.properties重看到当前的gradle版本为2.4，下面的配置版本就要改为1.3.0 classpath 'com.android.tools.build:gradle:1.2.3' // 下面的部分就为新添加的。 // 用于上传项目到bintray classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.2' // 用于生成javaDoc和jar，如果gradle版本为2.4及以上，下面的版本就要改为1.3，具体可参考https://github.com/dcendents/android-maven-gradle-plugin classpath 'com.github.dcendents:android-maven-plugin:1.2' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 修改local.properties文件，在里面配置apikey、用户名以及密码，以便bintray进行验证。之所以要把这些东西配置到该文件中是因为这些信息都比较敏感，不能分享到别处，包括版本控制里面。而在创建项目的时候local.properties已经被添加到.gitignore中了，所以这些数据不会被上传：需要添加如下三行代码:123bintray.user=YOUR_BINTRAY_USERNAME // 这里一定要用小写，不要用CharonChui不然会报错的，因为他会根据该用户名去找指定package，如果是大写他就找不到了。bintray.apikey=YOUR_BINTRAY_API_KEYbintray.gpg.password=YOUR_GPG_PASSWORD Api key可以在Binatry官网上面的Edit Profile页面下的API Key中获取。最后要做的就是修改library module中的build.gradle文件。下面这是最初的状态：1234567891011121314151617181920212223apply plugin: 'com.android.library'android &#123; compileSdkVersion 22 buildToolsVersion \"22.0.1\" defaultConfig &#123; minSdkVersion 8 targetSdkVersion 22 versionCode 1 versionName \"1.0\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar'])&#125; 下面就是修改之后的文件:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120apply plugin: 'com.android.library'apply plugin: 'com.github.dcendents.android-maven'apply plugin: \"com.jfrog.bintray\"// This is the library version used when deploying the artifactversion = \"1.0.0\"android &#123; compileSdkVersion 22 buildToolsVersion \"22.0.1\" defaultConfig &#123; minSdkVersion 8 targetSdkVersion 22 versionCode 1 versionName \"1.0\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar'])&#125;def siteUrl = 'https://github.com/CharonChui/CyberLink4Android' // Homepage URL of the librarydef gitUrl = 'https://github.com/CharonChui/CyberLink4Android.git' // Git repository URLgroup = \"com.charonchui.cyberlink\" // Maven Group ID for the artifactinstall &#123; repositories.mavenInstaller &#123; // This generates POM.xml with proper parameters pom &#123; project &#123; packaging 'aar' // Add your description here name 'cyberlink-android' description = 'CyberLink for Android is a development package for UPnP™ developers on Android development.' url siteUrl // Set your license licenses &#123; license &#123; name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' &#125; &#125; developers &#123; developer &#123; id 'CharonChui' name 'Charon Chui' email 'charon.chui@gmail.com' &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = 'sources'&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;Properties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())// https://github.com/bintray/gradle-bintray-pluginbintray &#123; user = properties.getProperty(\"bintray.user\") key = properties.getProperty(\"bintray.apikey\") configurations = ['archives'] pkg &#123; repo = \"maven\" // it is the name that appears in bintray when logged name = \"cyberlink-android\" websiteUrl = siteUrl vcsUrl = gitUrl licenses = [\"Apache-2.0\"] publish = true version &#123; gpg &#123; sign = true //Determines whether to GPG sign the files. The default is false passphrase = properties.getProperty(\"bintray.gpg.password\") //Optional. The passphrase for GPG signing' &#125;// mavenCentralSync &#123;// sync = true //Optional (true by default). Determines whether to sync the version to Maven Central.// user = properties.getProperty(\"bintray.oss.user\") //OSS user token// password = properties.getProperty(\"bintray.oss.password\") //OSS user password// close = '1' //Optional property. By default the staging repository is closed and artifacts are released to Maven Central. You can optionally turn this behaviour off (by puting 0 as value) and release the version manually.// &#125; &#125; &#125;&#125; 到这一步就可以开始上传到bintray了，接下来开启Android Studio的Terminal中。 检查代码的正确性，以及编译library文件(aar,pom等)。执行如下命令: ./gradlew install如果提示权限不足就用chmod 777 gradlew改下权限就好了，windows下直接运行gradlew install 正确的话会提示BUILD SUCCESSFUL 上传编译的文件到bintray，使用如下命令: ./gradlew bintrayUpload 成功的话会提示SUCCESSFUL接下来到bintray上检查一下你得package你会在版本区域发现新上传的版本。点击进去就能发现我们上传的library文件。 点击该版本进入后可以看到所有的文件目录。 到这里你的library就已经上传了，任何人都可以使用，但是别高兴的太早，因为现在只是上传到了你自己的私人Maven仓库，而不是jCenter上，如果别人使用你library，他必须要先定义仓库的url， 如下:12345678910repositories &#123; maven &#123; url 'https://dl.bintray.com/charonchui/maven/' &#125;&#125;... dependencies &#123; compile 'com.charonchui.cyberlink:cyberlink-android:1.0.0'&#125; 这样终究是不方便的，因为别人还要单独的去配置你仓库的url那么接下来就是怎么将bintray上我们的仓库上传到jCenter中呢？把library同步到jCenter上非常容易。只需要访问bintray，然后点击Add to jCeter然后在新出来的页面直接点击Send即可。现在我们就需要等待bintray团队审核我们的请求，一般会在两三个小时左右，如果审核通过，会收到一封邮件通知。通过这一步之后任何开发者都可以不用配置仓库url直接使用了。想检查一下自己的library是否在jCenter上存在，可以直接访问http://jcenter.bintray.com,然后根据你的groupId直接进入相应的目录查看即可。这里要说一下，这个链接到jCenter是一个只需要做一次的操作，如果以后对你的package做了修改，或者发布新版本等，这些改变会自动同步到jCenter上。同时，如果你要像删除某一个package，但是在jCenter仓库中的library不会被删除。它会一直存在，没法直接删除，因此如果你想要完全删除的时候，最好在移除package之前先在网页上把删除每个版本。如何通过后也可以在bintray上面看到，这里已经不显示Add to jCenter按钮了，他会直接显示出来jCenter. 到这里你就可以在项目中直接使用: 123dependencies &#123; compile 'com.charonchui.cyberlink:cyberlink-android:1.0.0'&#125; 但是，我悲剧了。提示失败了，为什么呢？ 原因就出来library这个module name这里，因为我这里的module那么是library所以它上传之后的路径就是library而不是cyberlink-android: 所以通过这里能看出来它是使用当前module的名字的。我们只能通过如下方式去使用:123dependencies &#123; compile 'com.charonchui.cyberlink:library:1.0.0'&#125; 这样就能正常使用了。 如果有些人感觉这样不好，就想要com.charonchui.cyberlink:cyberlink-android:1.0.0的方式，那就将Android Studio中library的名字修改为cyberlink-android后重新上传发布吧。 最后一步:上传library到Maven Central 并不是所有的开发者都使用jCenter。仍然会有一些人在使用Maven Central。因为此我们仍然需要将library上传到Maven Central上。要从jCenter中上传到Maven Central之前需要先完成以下两部分: Bintray上的pacage已经链接到jCenter. Maven Central上的仓库已经认证通过. 如果确认已经完成上面的授权后，上传library到Maven Central就非常简单了，只需要在package的详情页面点击Maven Central的链接。直接进入下一个页面:然后再出来的页面输入Maven Central对应的用户名和密码点击Sync就可以了。上传到Maven Central的library是非常严格的，比如+号是不能在library版本的依赖定义中使用的。完成之后，你可以在 Maven Central Repository中找到你的library。 总结下在使用过程中遇到的错误: Maven gradle插件与gradle版本要对应好，如下，不要不对应。 12345678910111213141516171819202122// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // 用于上传项目到bintray classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.2' // 用于生成javaDoc和jar classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; windows下执行gradlew install编译javadoc时会提示GBK编码错误，这时候需要修改编译时的编码，具体放狗搜下，当时我改在mac上用了，就没解决。 编译生成javadoc时提示很多找不到类，不能使用&lt;br/&gt;等错误，这里建议在写注释的时候一定要规范，不要使用汉字，而且不要使用&lt;br/&gt;，&lt;p&gt;等。","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android6.0权限系统","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Android6.0权限系统/","text":"Android6.0权限系统Android权限系统是一个非常重要的安全问题，因为它只有在安装时会询问一次。一旦软件本安装之后，应用程序可以在用户毫不知情的情况下使用这些权限来获取所有的内容。 很多坏蛋会通过这个安全缺陷来收集用户的个人信息并使用它们来做坏事的情况就不足为奇了。 Android团队也意识到了这个问题。在经过了7年后，权限系统终于被重新设置了。从Anroid 6.0(API Level 23)开始，应用程序在安装时不会被授予任何权限，取而代之的是在运行时应用回去请求用户授予对应的权限。这样可以让用户能更好的去控制应用功能。例如，一个用户可能会同一个拍照应用使用摄像头的权限，但是不同授权它获取设备位置的权限。用户可以在任何时候通过去应用的设置页面来撤销授权。 注意:上面请求权限的对话框不会自动弹出。开发者需要手动的调用。如果开发者调用了一些需要权限的功能，但是用户又拒绝授权的话，应用就会crash。 系统权限被分为两类，normal和dangerous: Normal Permissions不需要用户直接授权，如果你的应用在清单文件中声明了Normal Permissions`，系统会自动授权该权限。 Dangerous Permissions可以让应用获取用户的私人数据。如果你的应用在清单文件中申请了Dangerous Permissions，那就必须要用户来授权给应用。 Normal Permissions:Normal Permission是当用户安装或更新应用时，系统将授予应用所请求的权限，又称为PROTECTION_NORMAL（安装时授权的一类基本权限）。该类权限只需要在manifest文件中声明即可，安装时就授权，不需要每次使用时进行检查，而且用户不能取消以上授权。 ACCESS_LOCATION_EXTRA_COMMANDS ACCESS_NETWORK_STATE ACCESS_NOTIFICATION_POLICY ACCESS_WIFI_STATE BLUETOOTH BLUETOOTH_ADMIN BROADCAST_STICKY CHANGE_NETWORK_STATE CHANGE_WIFI_MULTICAST_STATE CHANGE_WIFI_STATE DISABLE_KEYGUARD EXPAND_STATUS_BAR GET_PACKAGE_SIZE INSTALL_SHORTCUT INTERNET KILL_BACKGROUND_PROCESSES MODIFY_AUDIO_SETTINGS NFC READ_SYNC_SETTINGS READ_SYNC_STATS RECEIVE_BOOT_COMPLETED REORDER_TASKS REQUEST_IGNORE_BATTERY_OPTIMIZATIONS REQUEST_INSTALL_PACKAGES SET_ALARM SET_TIME_ZONE SET_WALLPAPER SET_WALLPAPER_HINTS TRANSMIT_IR UNINSTALL_SHORTCUT USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_SYNC_SETTINGS 下图为Dangerous permissions and permission groups: 在所有的Android版本中，你的应用都需要在manifest文件中声明normal和dangerous权限。然而声明所影响的效果会因系统版本和你应用的target SDK lever有关: 如果设备运行的是Android 5.1或者之前的系统，或者应用的targetSdkVersion是22或者之前版本：如果你在manifest中声明了dangerous permission，用户需要在安装应用时授权这些权限。如果用户不授权这些权限，系统就不会安装该应用。(我试了下发现即使targetSdkVersion是22及以下，在6.0的手机上时，如果你安装时你不同意一些权限，也仍然可以安装的) 如果设备运行的是Android 6.0或者更高的系统，并且你应用的targetSdkVersion是23或者更高:应用必须在manifest文件中申请这些权限，而且必须要在运行时对所需要的dangerous permission申请授权。用户可以统一或者拒绝授权，并且及时用户拒绝了授权，应用在无法使用一些功能的情况下也要保证能继续运行。 也就是说新的运行时权限仅当我们设置targetSdkVersion是23及以上时才会起作用。如果你的targtSdkVersion低于23，那将被认为该应用没有经过android 6.0的测试，当该应用被安装到了6.0的手机上时，仍然会使用之前的旧权限规则，在安装时会提示所有需要的权限(这样做是有道理的，不然对于之前开发的应用，我们都要立马去修改让它适应6.0，来不及的话就导致6.0的手机都无法使用了，显然Android开发团队不会考虑不到这种情况)，当然用户可以在安装的界面不允许一些权限，那当程序使用到了这些权限时，会崩溃吗？答案是在Android 6.0及以上的手机会直接crash，但是在23之前的手机上不会crash。 所以如果你的应用没有支持运行时权限的功能，那千万不要讲targetSdkVersion设置为23，否则就麻烦了。 注意:从Android 6.0(API Level 23)开始，即使应用的targetSdkVersion是比较低的版本，但是用户仍然可以在任何时候撤销对应用的授权。所以不管应用的targetSdkVerison是什么版本，你都要测试你的应用在不能获取权限时能不能正常运行。 下面介绍下如何使用Android Support Library来检查和请求权限。Android框架在6.0开始也提供了相同的方法。然而使用support包会比较简单，因为这样你就不需要在请求方法时判断当前的系统版本。(后面说的这几个类都是android.support.v4中的) ###检查权限 如果应用需要使用dangerous permission，在任何时候执行需要该权限的操作时你都需要检查是否已经授权。用户可能会经常取消授权，所以即使昨天应用已经使用了摄像头，这也不能保证今天仍然有使用摄像头的权限。 为了检查是否可以使用该权限，调用ContextCompat.checkSelfPermission()。例如:123// Assume thisActivity is the current activityint permissionCheck = ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR); 如果应用有该权限，该方法将返回PackageManager.PERMISSION_GRANTED，应用可以进行相关的操作。如果应用不能使用该权限，该方法将返回PERMISSION_DENIED，这是应用将必须要向用户申请该权限。 ###申请使用权限 如果应用需要使用清单文件中申明的dangerous permission，它必须要向用户申请来授权。Android提供了几种申请授权的方法。使用这些方法时将会弹出一个标准的系统对话框，该对话框不能自定义。 #####说明为什么应用需要使用这些权限 在一些情况下，你可能需要帮助用力理解为什么需要该权限。例如，一个用户使用了一个照相的应用，用户不会奇怪为什么应用申请使用摄像头的权限，但是用户可能会不理解为什么应用需要获取位置或者联系人的权限。在请求一个权限之前，你需要该用户一个说明。一定要切记不要通过说明来压倒用户。如果你提供了太多的说明，用户可能会感觉沮丧并且会卸载它。 一个你需要提供说明的合适时机就是在用户之前已经不同意授权该权限的情况下。如果一个用户继续尝试使用需要权限的功能时，但是之前确禁止了该权限的请求，这就可能是因为用户不理解为什么该功能需要使用该权限。在这种情况下，提供一个说明是非常合适的。 为了能找到用户可能需要说明的情况，android提供了一个工具类方法ActivityCompat.shouldShowRequestPermissionRationale().。如果应用之前申请了该权限但是用户拒绝授权后该方法会返回true。(在Android 6.0之前调用的时候会直接返回false) 注意：如果用户之前拒绝了权限申请并且选择了请求权限对话框中的Don’t ask again选项，该方法就会返回false。如果设备策略禁止了该应用使用该权限，该方法也会返回false。(我测试的时候发现请求权限的对话框中并没有Don’t asdk again这一项) #####申请需要的权限 如果应用没有所需的权限时，应用必须调用ActivityCompat.requestPermissions (Activity activity, String[] permissions, int requestCode)方法来申请对用的权限。参数传递对应所需的权限以及一个整数型的request code来标记该权限申请。 该方法是异步的:该方法会立即返回，在用户响应了请求权限的对话框之后，系统会调用对用的回调方法来通知结果，并且会传递在reqeustPermissions()方法中的request code。(在Android 6.0之前调用的时候会直接去调用onRequestPermissionsResult()的回调方法)如图: 下面是检查是否读取联系人权限，并且在必要时申请权限的代码: 1234567891011121314151617181920212223242526// Here, thisActivity is the current activityif (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; // Show an expanation to the user *asynchronously* -- don't block // this thread waiting for the user's response! After the user // sees the explanation, try again to request the permission. &#125; else &#123; // No explanation needed, we can request the permission. ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. &#125;&#125; 注意：当调用requestPermissions()方法时，系统会显示一个标准的对话框。应用不能指定或者改变该对话框。如果你想提供一些信息或者说明给用户，你需要在调用requestPermissions()之前处理。 #####处理请求权限的的结果 如果应用申请权限，系统会显示一个对话框。当用户相应后，系统会调用应用中的onRequestPermissionsResult (int requestCode, String[] permissions, int[] grantResults)方法并传递用户的操作结果。在应用中必须要重写该方法来查找授权了什么权限。该回调方法会传递你在requestPermisssions()方法中传递的request code。直接在Activity或者Fragment中重写onRequestPermissionsResult()方法即可。例如，申请READ_CONTACTS的权限可能会有下面的回到方法: 123456789101112131415161718192021222324@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! Do the // contacts-related task you need to do. &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. &#125; return; &#125; // other 'case' lines to check for other // permissions this app might request &#125;&#125; 系统提示的对话框会描述应用所需的permission groud。它不会列出特定的权限。例如，如果你申请了READ_CONTACTS权限，系统的对话框只会说你的应用需要获取设备的联系人信息。用户只需要授权每个permission group一次。如果你应用需要申请其他任何一个在该permission group中的权限时，系统会自动授权。在申请这些授权时，系统会像用户明确通过系统对话框统一授权时一样去调用onRequestPermissionsResult()方法并且传递PERMISSION_GRANTED参数。 注意：虽然用户已经授权了同一permission group中其他的任何权限，但是应用仍然需要明确申请每个需要的权限。例外，permission group中的权限在以后可能会发生变化。 例如，假设在应用的manifest文件中同时声明了READ_CONTACTS和WRITE_CONTACTS权限。如果你申请READ_CONTACTS权限而且用户同意了该权限，如果你想继续申请WRITE_CONTACTS权限，系统不会与用户有任何交互就会直接进行授权。 如果用户拒绝了一个权限申请，你的应用进行合适的处理。例如，你的应用可能显示一个对话框来表明无法执行用户请求的需要该权限的操作。 如果系统向用户申请权限授权，用户选择了让系统以后不要再申请该权限。 在这种情况下，应用在任何时间调用reqeustPermissions()方法来再次申请权限时，系统都会直接拒绝该请求。系统会直接调用onRequestPermissionResult()回调方法并且传递PERMISSION_DENIED参数，和用户明确拒绝应用申请该权限时一样。 这就意味着在你调用requestPermissions()方法是，你无法确定是否会和用户有直接的交互操作。 示例代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final private int REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS = 124; private void insertDummyContactWrapper() &#123; List&lt;String&gt; permissionsNeeded = new ArrayList&lt;String&gt;(); final List&lt;String&gt; permissionsList = new ArrayList&lt;String&gt;(); if (!addPermission(permissionsList, Manifest.permission.ACCESS_FINE_LOCATION)) permissionsNeeded.add(\"GPS\"); if (!addPermission(permissionsList, Manifest.permission.READ_CONTACTS)) permissionsNeeded.add(\"Read Contacts\"); if (!addPermission(permissionsList, Manifest.permission.WRITE_CONTACTS)) permissionsNeeded.add(\"Write Contacts\"); if (permissionsList.size() &gt; 0) &#123; if (permissionsNeeded.size() &gt; 0) &#123; // Need Rationale String message = \"You need to grant access to \" + permissionsNeeded.get(0); for (int i = 1; i &lt; permissionsNeeded.size(); i++) message = message + \", \" + permissionsNeeded.get(i); showMessageOKCancel(message, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; requestPermissions(permissionsList.toArray(new String[permissionsList.size()]), REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS); &#125; &#125;); return; &#125; requestPermissions(permissionsList.toArray(new String[permissionsList.size()]), REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS); return; &#125; insertDummyContact();&#125; private boolean addPermission(List&lt;String&gt; permissionsList, String permission) &#123; if (checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) &#123; permissionsList.add(permission); // Check for Rationale Option if (!shouldShowRequestPermissionRationale(permission)) return false; &#125; return true;&#125; 上面讲到的都是Activity中的使用方法，那Fragment中怎么授权呢？如果在Fragment中使用，用v13包中的FragmentCompat.requestPermissions()和FragmentCompat.shouldShowRequestPermissionRationale()。 在Fragment中申请权限，不要使用ActivityCompat.requestPermissions, 直接使用Fragment.requestPermissions方法，否则会回调到Activity的onRequestPermissionsResult。但是虽然你使用Fragment.requestPermissions方法，也照样回调不到Fragment.onRequestPermissionsResult中。这是Android的Bug,详见，Google已经在23.3.0修复了该问题，所以要尽快升级。 所以升级到23.3.0及以上就没问题了。如果不升级该怎么处理呢？就是在Activity.onRequestPermissionsResult方法中去手动调用每个Fragment的方法(当然你要判断下权限个数，不然申请一个权限的情况下会重复调用).12345678910@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); List&lt;Fragment&gt; fragments = getSupportFragmentManager().getFragments(); if (fragments != null) &#123; for (Fragment fragment : fragments) &#123; fragment.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125; &#125;&#125; 我简单的写了一个工具类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204public class PermissionUtil &#123; /** * 在调用需要权限的功能时使用该方法进行检查。 * * @param activity * @param requestCode * @param iPermission * @param permissions */ public static void checkPermissions(Activity activity, int requestCode, IPermission iPermission, String... permissions) &#123; handleRequestPermissions(activity, requestCode, iPermission, permissions); &#125; public static void checkPermissions(Fragment fragment, int requestCode, IPermission iPermission, String... permissions) &#123; handleRequestPermissions(fragment, requestCode, iPermission, permissions); &#125; public static void checkPermissions(android.app.Fragment fragment, int requestCode, IPermission iPermission, String... permissions) &#123; handleRequestPermissions(fragment, requestCode, iPermission, permissions); &#125; /** * 在Actvitiy或者Fragment中重写onRequestPermissionsResult方法后调用该方法。 * * @param activity * @param requestCode * @param permissions * @param grantResults * @param iPermission */ public static void onRequestPermissionsResult(Activity activity, int requestCode, String[] permissions, int[] grantResults, IPermission iPermission) &#123; requestResult(activity, requestCode, permissions, grantResults, iPermission); &#125; public static void onRequestPermissionsResult(Fragment fragment, int requestCode, String[] permissions, int[] grantResults, IPermission iPermission) &#123; requestResult(fragment, requestCode, permissions, grantResults, iPermission); &#125; public static void onRequestPermissionsResult(android.app.Fragment fragment, int requestCode, String[] permissions, int[] grantResults, IPermission iPermission) &#123; requestResult(fragment, requestCode, permissions, grantResults, iPermission); &#125; public static &lt;T&gt; void requestPermission(T t, int requestCode, String... permission) &#123; List&lt;String&gt; permissions = new ArrayList&lt;&gt;(); for (String s : permission) &#123; permissions.add(s); &#125; requestPermissions(t, requestCode, permissions); &#125; /** * 在检查权限后自己处理权限说明的逻辑后调用该方法，直接申请权限。 * * @param t * @param requestCode * @param permissions * @param &lt;T&gt; */ public static &lt;T&gt; void requestPermission(T t, int requestCode, List&lt;String&gt; permissions) &#123; if (permissions == null || permissions.size() == 0) &#123; return; &#125; requestPermissions(t, requestCode, permissions); &#125; public static boolean checkSelfPermission(Context context, String permission) &#123; if (context == null || TextUtils.isEmpty(permission)) &#123; throw new IllegalArgumentException(\"invalidate params: the params is null !\"); &#125; context = context.getApplicationContext(); if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123; int result = ContextCompat.checkSelfPermission(context, permission); if (PackageManager.PERMISSION_DENIED == result) &#123; return false; &#125; &#125; return true; &#125; private static &lt;T&gt; void handleRequestPermissions(T t, int requestCode, IPermission iPermission, String... permissions) &#123; if (t == null || permissions == null || permissions.length == 0) &#123; throw new IllegalArgumentException(\"invalidate params\"); &#125; if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123; Activity activity = getActivity(t); List&lt;String&gt; deniedPermissions = getDeniedPermissions(activity, permissions); if (deniedPermissions != null &amp;&amp; deniedPermissions.size() &gt; 0) &#123; List&lt;String&gt; rationalPermissions = new ArrayList&lt;&gt;(); for (String deniedPermission : deniedPermissions) &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(activity, deniedPermission)) &#123; rationalPermissions.add(deniedPermission); &#125; &#125; boolean showRational = false; if (iPermission != null) &#123; showRational = iPermission.showRational(requestCode); &#125; if (rationalPermissions.size() &gt; 0 &amp;&amp; showRational) &#123; if (iPermission != null) &#123; iPermission.onRational(requestCode, deniedPermissions); &#125; &#125; else &#123; requestPermissions(t, requestCode, deniedPermissions); &#125; &#125; else &#123; if (iPermission != null) &#123; iPermission.onGranted(requestCode); &#125; &#125; &#125; else &#123; if (iPermission != null) &#123; iPermission.onGranted(requestCode); &#125; &#125; &#125; @Nullable private static &lt;T&gt; Activity getActivity(T t) &#123; Activity activity = null; if (t instanceof Activity) &#123; activity = (Activity) t; &#125; else if (t instanceof Fragment) &#123; activity = ((Fragment) t).getActivity(); &#125; else if (t instanceof android.app.Fragment) &#123; activity = ((android.app.Fragment) t).getActivity(); &#125; return activity; &#125; @TargetApi(Build.VERSION_CODES.M) private static &lt;T&gt; void requestPermissions(T t, int requestCode, List&lt;String&gt; deniedPermissions) &#123; if (deniedPermissions == null || deniedPermissions.size() == 0) &#123; return; &#125; // has denied permissions if (t instanceof Activity) &#123; ((Activity) t).requestPermissions(deniedPermissions.toArray(new String[deniedPermissions.size()]), requestCode); &#125; else if (t instanceof Fragment) &#123; ((Fragment) t).requestPermissions(deniedPermissions.toArray(new String[deniedPermissions.size()]), requestCode); &#125; else if (t instanceof android.app.Fragment) &#123; ((android.app.Fragment) t).requestPermissions(deniedPermissions.toArray(new String[deniedPermissions.size()]), requestCode); &#125; &#125; private static List&lt;String&gt; getDeniedPermissions(Context context, String... permissions) &#123; if (context == null || permissions == null || permissions.length == 0) &#123; return null; &#125; List&lt;String&gt; denyPermissions = new ArrayList&lt;&gt;(); for (String permission : permissions) &#123; if (!checkSelfPermission(context, permission)) &#123; denyPermissions.add(permission); &#125; &#125; return denyPermissions; &#125; private static &lt;T&gt; void requestResult(T t, int requestCode, String[] permissions, int[] grantResults, IPermission iPermission) &#123; List&lt;String&gt; deniedPermissions = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; grantResults.length; i++) &#123; if (grantResults[i] != PackageManager.PERMISSION_GRANTED) &#123; deniedPermissions.add(permissions[i]); &#125; &#125; if (deniedPermissions.size() &gt; 0) &#123; if (iPermission != null) &#123; iPermission.onDenied(requestCode); &#125; &#125; else &#123; if (iPermission != null) &#123; iPermission.onGranted(requestCode); &#125; &#125; &#125;&#125;interface IPermission &#123; void onGranted(int requestCode); void onDenied(int requestCode); void onRational(int requestCode, List&lt;String&gt; permissions); /** * 是否需要提示用户该权限的作用，提示后需要再调用requestPermission()方法来申请。 * * @return true 为提示，false为不提示 */ boolean showRational(int requestCode);&#125; 使用方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class MainFragment extends Fragment implements View.OnClickListener &#123; private Button mReqCameraBt; private Button mReqContactsBt; private Button mReqMoreBt; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_main, container, false); findView(view); initView(); return view; &#125; private void findView(View view) &#123; mReqCameraBt = (Button) view.findViewById(R.id.bt_requestCamera); mReqContactsBt = (Button) view.findViewById(R.id.bt_requestContacts); mReqMoreBt = (Button) view.findViewById(R.id.bt_requestMore); &#125; private void initView() &#123; mReqCameraBt.setOnClickListener(this); mReqContactsBt.setOnClickListener(this); mReqMoreBt.setOnClickListener(this); &#125; public static final int REQUEST_CODE_CAMERA = 0; public static final int REQUEST_CODE_CONTACTS = 1; public static final int REQUEST_CODE_MORE = 2; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); PermissionUtil.onRequestPermissionsResult(this, requestCode, permissions, grantResults, mPermission); &#125; public void requestCamera() &#123; PermissionUtil.checkPermissions(this, REQUEST_CODE_CAMERA, mPermission, Manifest.permission.CAMERA); &#125; public void requestReadContacts() &#123; PermissionUtil.checkPermissions(this, REQUEST_CODE_CONTACTS, mPermission, Manifest.permission.READ_CONTACTS); &#125; public void requestMore() &#123; PermissionUtil.checkPermissions(this, REQUEST_CODE_MORE, mPermission, Manifest.permission.READ_CONTACTS, Manifest.permission.READ_CALENDAR, Manifest.permission.CALL_PHONE); &#125; private void showPermissionTipDialog(final int requestCode, final List&lt;String&gt; permissions) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); builder.setMessage(\"I want you permissions\"); builder.setTitle(\"Hello Permission\"); builder.setPositiveButton(\"确认\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); PermissionUtil.requestPermission(MainFragment.this, requestCode, permissions); &#125; &#125;); builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); &#125; &#125;); builder.create().show(); &#125; public IPermission mPermission = new IPermission() &#123; @Override public void onGranted(int requestCode) &#123; Toast.makeText(getActivity(), \"onGranted :\" + requestCode, Toast.LENGTH_SHORT).show(); &#125; @Override public void onDenied(int requestCode) &#123; Toast.makeText(getActivity(), \"onDenied :\" + requestCode, Toast.LENGTH_SHORT).show(); &#125; @Override public void onRational(int requestCode, List&lt;String&gt; permission) &#123; showPermissionTipDialog(requestCode, permission); &#125; @Override public boolean showRational(int requestCode) &#123; switch (requestCode) &#123; case REQUEST_CODE_MORE: return true; default: break; &#125; return false; &#125; &#125;; @Override public void onClick(View v) &#123; int id = v.getId(); switch (id) &#123; case R.id.bt_requestCamera: requestCamera(); break; case R.id.bt_requestContacts: requestReadContacts(); break; case R.id.bt_requestMore: requestMore(); break; &#125; &#125;&#125; 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"性能优化","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/性能优化/","text":"性能优化代码优化原则: 时间换时间： 如禁用电脑的一些开机启动项，通过减少这些没必要的启动项的时间从而节省开机时间 如网站界面上数据的分批获取，AJAX技术 时间换空间： 如拷贝文件时new一个字节数组当缓冲器，即byte[] buffer = new byte[1024]。 为什么只new一个1024个字节的数组呢，new一个更大的字节数组不是一下就把文件拷贝完了么？这么做就是为了牺牲时间节省有限的内存空间 空间换时间： 如用Windows系统自带的搜索文件的功能搜索文件时会很慢，但是我们牺牲电脑硬盘空间安装一个everything软件来搜索文件就特别快 空间换空间： 如虚拟内存 Android开发中的体现 采用硬件加速，在清单文件中application节点添加android:hardwareAccelerated=”true”。不过这个需要在android 3.0才可以使用。android4.0这个选项是默认开启的。 View中设置缓存属性setDrawingCache为true. 优化你的布局. 动态加载View. 采用ViewStub避免一些不经常的视图长期握住引用. 将Acitivity中的Window的背景图设置为空。getWindow().setBackgroundDrawable(null);``android的默认背景是不是为空。 采用&lt;merge&gt;优化布局层数。 采用&lt;include&gt;来共享布局。 利用TraceView查看跟踪函数调用。有的放矢的优化。 cursor的使用。不过要注意管理好cursor,不要每次打开关闭cursor.因为打开关闭Cursor非常耗时。 Cursor.require用于刷cursor. 采用SurfaceView在子线程刷新UI, 避免手势的处理和绘制在同一UI线程（普通View都这样做）。 采用JNI，将耗时间的处理放到c/c++层来处理。 有些能用文件操作的，尽量采用文件操作，文件操作的速度比数据库的操作要快10倍左右。 避免创建不必要的对象 如果方法用不到成员变量，可以把方法申明为static，性能会提高到15%到20% 避免使用getter/setter存取field，可以把field申明为public，直接访问 static的变量如果不需要修改，应该使用static final修饰符定义为常量 使用增强for循环,比普通for循环效率高，但是也有缺点就是在遍历 集合过程中，不能对集合本身进行操作 合理利用浮点数，浮点数比整型慢两倍； 针对ListView的性能优化 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android卸载反馈","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/Android卸载反馈/","text":"Android卸载反馈最初记得是在360安全卫士中出现的，在手机上卸载他的应用之后浏览器就会弹出一个反馈页面，让用户进行反馈，感觉这种功能对于产品改进特别有帮助。但是仔细一想该怎么去实现却犯愁了，最开始想这也简单啊，不就是监听下自身被卸载就可以了，应该系统会有卸载的广播，可惜没有。甚至其他的一些方法也是不行的，因为你程序都被卸载了，你的代码怎么会执行呢？皮之不存，毛将焉附。那360是怎样实现的呢？说句真心话360做的产品还是非常有创新的，虽然有些时候他会损坏用户的利益，不过但从技术方面，着实让人信服。 既然Java实现不了，那就得考虑下其他的了，自然最先想到的就是JNI了，可惜C的部分不懂，上网搜了很多资料和介绍，找得到可以通过一下方式实现: 通过c中的fork方法来复制一个子进程。复制出来的子进程在父进程被销毁后，仍然可以存在。 pid_t fpid = fork()被调用前，就一个进程执行该段代码，这条语句执行之后，就会有两个进程执行该代码，两个进程执行没有固定先后顺序，只要看 系统调度策略，fork()函数的特别之处在于调用一次会返回两次结果： - 返回值大于0，当前是父进程。 - 返回0，当前是子进程。 - 返回小于0的负值。(出错了，可能是内存不足或者是进程数已经达到系统最大值) fork出子进程后让子进程一直去监听/data/data/packageName是否存在，如果不存在了，那就说明程序被卸载了，但是这样一直去轮训判断肯定会浪费 系统资源的，当然也会更加费电，对用户来讲肯定是有损害的。所以这种技术最好也不好用，不然大家的手机以后还能了得。万恶的产品。 得到程序被卸载之后弹出浏览器打开指定反馈页面。这就要用到am命令了，最早知道这个命令是在开发TV版的时候，遥控器找不到了，程序安装后无法 打开了，用该命令就不怕了，哈哈。但是在c中怎么执行am命令呢？这就要用到execlp()函数，该函数就是c中执行系统命令的函数。 好了，主要的内容上面都分析完了，下面上代码。 Java层定义natvie方法。 1234567891011121314151617public class MainActivity extends Activity &#123; private static final String TAG = \"@@@\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); String packageDir = \"/data/data/\" + getPackageName(); initUninstallFeedback(packageDir, Build.VERSION.SDK_INT); &#125; private native void initUninstallFeedback(String packagePath, int sdkVersion); static &#123; System.loadLibrary(\"uninstall_feedback\"); &#125;&#125; 创建jni目录，增加Android.mk以及uninstall_feedback.c文件。Android.mk的内容: 1234567891011LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := uninstall_feedbackLOCAL_SRC_FILES := uninstall_feedback.cLOCAL_C_INCLUDES := $(LOCAL_PATH)/includeLOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -lloginclude $(BUILD_SHARED_LIBRARY) uninstall_feedback.c的实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 将Java中的String转换成c中的char字符串 */char* Jstring2CStr(JNIEnv* env, jstring jstr) &#123; char* rtn = NULL; jclass clsstring = (*env)-&gt;FindClass(env, \"java/lang/String\"); //String jstring strencode = (*env)-&gt;NewStringUTF(env, \"GB2312\"); // 得到一个java字符串 \"GB2312\" jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, \"getBytes\", \"(Ljava/lang/String;)[B\"); //[ String.getBytes(\"gb2312\"); jbyteArray barr = (jbyteArray)(*env)-&gt;CallObjectMethod(env, jstr, mid, strencode); // String .getByte(\"GB2312\"); jsize alen = (*env)-&gt;GetArrayLength(env, barr); // byte数组的长度 jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE); if (alen &gt; 0) &#123; rtn = (char*) malloc(alen + 1); //\"\" memcpy(rtn, ba, alen); rtn[alen] = 0; &#125; (*env)-&gt;ReleaseByteArrayElements(env, barr, ba, 0); // return rtn;&#125;void Java_com_charon_uninstallfeedback_MainActivity_initUninstallFeedback( JNIEnv* env, jobject thiz, jstring packageDir, jint sdkVersion) &#123; char * pd = Jstring2CStr(env, packageDir); //fork子进程，以执行轮询任务 pid_t pid = fork(); if (pid &lt; 0) &#123; // fork失败了 &#125; else if (pid == 0) &#123; // 可以一直采用一直判断文件是否存在的方式去判断，但是这样效率稍低，下面使用监听的方式，死循环，每个一秒判断一次，这样太浪费资源了。 int check = 1; while (check) &#123; FILE* file = fopen(pd, \"rt\"); if (file == NULL) &#123; if (sdkVersion &gt;= 17) &#123; // Android4.2系统之后支持多用户操作，所以得指定用户 execlp(\"am\", \"am\", \"start\", \"--user\", \"0\", \"-a\", \"android.intent.action.VIEW\", \"-d\", \"http://shouji.360.cn/web/uninstall/uninstall.html\", (char*) NULL); &#125; else &#123; // Android4.2以前的版本无需指定用户 execlp(\"am\", \"am\", \"start\", \"-a\", \"android.intent.action.VIEW\", \"-d\", \"http://shouji.360.cn/web/uninstall/uninstall.html\", (char*) NULL); &#125; check = 0; &#125; else &#123; &#125; sleep(1); &#125; &#125; else &#123; &#125;&#125; 编译so文件。Windows下要用cygwin来操作。上面的介绍是在Eclipse中进行的，用ndk-build命令来编译so。具体请看之前写的JNI基础这篇文章。 有关如何在Android Stuido中进行ndk开发请看另一篇文章。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"屏幕适配之百分比方案详解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/屏幕适配之百分比方案详解/","text":"屏幕适配之百分比方案详解Android设备碎片化十分严重，在开发过程中的适配工作也非常很繁琐，有关屏幕适配的介绍请看之前的文章屏幕适配。 最近看到DrawerLayout，support v4中提供的类，想到对google提供的这些支持库，自己一点都不熟悉，想着看看Google提供的支持库都有什么内容。结果看着看着在最后忽然看到了Percent Support Library。寻思怎么还百分比呢？仔细一看介绍，我擦，真是太有用了。 ###Percent Support LibraryThe Percent package provides APIs to support adding and managing percentage based dimensions in your app. The Percent Support library adds support for the PercentLayoutHelper.PercentLayoutParams interface and various classes, such as PercentFrameLayout and PercentRelativeLayout. After you download the Android Support Libraries, this library is located in the /extras/android/support/percent directory. For more information on how to set up your project, follow the instructions in Adding libraries with resources. The Gradle build script dependency identifier for this library is as follows:com.android.support:percent:23.3.0 看到了吗？ 说提供了PercentFrameLayout和PercentRelativeLayout来支持百分比了。这样不就完美的解决了适配的问题嘛。啥也不说了，立马配置cradle来瞧瞧。 Subclass of FrameLayout that supports percentage based dimensions and margins. You can specify dimension or a margin of child by using attributes with “Percent” suffix. 上代码:123456789101112&lt;android.support.percent.PercentFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:src=\"@mipmap/ic_launcher\" app:layout_widthPercent=\"50%\" app:layout_heightPercent=\"50%\" app:layout_marginTopPercent=\"25%\" app:layout_marginLeftPercent=\"25%\"/&gt;&lt;/android.support.percent.PercentFrameLayout&gt; 效果如下:完美. 支持的属性: layout_widthPercent layout_heightPercent layout_marginPercent layout_marginLeftPercent layout_marginTopPercent layout_marginRightPercent layout_marginBottomPercent layout_marginStartPercent layout_marginEndPercent layout_aspectRatio It is not necessary to specify layout_width/height if you specify layout_widthPercent. However, if you want the view to be able to take up more space than what percentage value permits, you can add layout_width/height=”wrap_content”. In that case if the percentage size is too small for the View’s content, it will be resized using wrap_content rule. 如果指定了layout_widthPercent就不用指定layout_width/height属性了。(Studio可能会提示错误，设置忽略就好)。然而，如果你想要该View能够占用比设置的百分比值更大的空间时，你可以指定layout_widht/height=“wrap_content”。在这种情况下，如果设置的百分比值在显示内容时太小时，将会使用wrap_content的值重新计算。 就是这个意思:如果指定的百分比太小怕显示不开的话，也可以给它指定wrap_content属性，这样当显示不开的时候就会使用wrap_content的值。如下:1234567891011121314151617&lt;android.support.percent.PercentFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\" android:text=\"顶顶顶顶顶大大大\" android:textSize=\"30dp\" android:singleLine=\"true\" app:layout_widthPercent=\"30%\" app:layout_heightPercent=\"5%\" app:layout_marginTopPercent=\"25%\" app:layout_marginLeftPercent=\"25%\"/&gt;&lt;/android.support.percent.PercentFrameLayout&gt; 效果: 加入wrap_content后一点效果也没有啊，还是显示不全啊，和没加wrap_content一样，- -! 你也可以通过只设置width或者height和layout_aspectRatio这种比例值的方式来让第另一个值自动计算。例如，如果你想要使用16:9的比例，你可以使用:12android:layout_width=\"300dp\"app:layout_aspectRatio=\"178%\" 这样将会在宽固定为300dp的基础上以16:9(1.78:1)来计算高度。 PercentRelativeLayout的使用都是一样的，这里就不贴了。 那它是怎么实现的呢？其实就是内部给通过属性换算，把本布局的宽高和百分比去计算每个view的大小和位置。但是还有为什么上面设置的wrap_content无效呢？是我理解错了吗？ 带着这两个疑问我们来看下源码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class PercentFrameLayout extends FrameLayout &#123; private final PercentLayoutHelper mHelper = new PercentLayoutHelper(this); public PercentFrameLayout(Context context) &#123; super(context); &#125; public PercentFrameLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public PercentFrameLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected LayoutParams generateDefaultLayoutParams() &#123; return new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new LayoutParams(getContext(), attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; mHelper.adjustChildren(widthMeasureSpec, heightMeasureSpec); super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 从名字上就能看出来下面就是处理如果指定百分比过小不足显示内容时，就去使用`wrap_content`的逻辑 if (mHelper.handleMeasuredStateTooSmall()) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); mHelper.restoreOriginalParams(); &#125; public static class LayoutParams extends FrameLayout.LayoutParams implements PercentLayoutHelper.PercentLayoutParams &#123; private PercentLayoutHelper.PercentLayoutInfo mPercentLayoutInfo; public LayoutParams(Context c, AttributeSet attrs) &#123; super(c, attrs); // PercentLayoutInfo中去解析自定义属性的值 mPercentLayoutInfo = PercentLayoutHelper.getPercentLayoutInfo(c, attrs); &#125; public LayoutParams(int width, int height) &#123; super(width, height); &#125; public LayoutParams(int width, int height, int gravity) &#123; super(width, height, gravity); &#125; public LayoutParams(ViewGroup.LayoutParams source) &#123; super(source); &#125; public LayoutParams(MarginLayoutParams source) &#123; super(source); &#125; public LayoutParams(FrameLayout.LayoutParams source) &#123; super((MarginLayoutParams) source); gravity = source.gravity; &#125; public LayoutParams(LayoutParams source) &#123; this((FrameLayout.LayoutParams) source); mPercentLayoutInfo = source.mPercentLayoutInfo; &#125; @Override public PercentLayoutHelper.PercentLayoutInfo getPercentLayoutInfo() &#123; if (mPercentLayoutInfo == null) &#123; mPercentLayoutInfo = new PercentLayoutHelper.PercentLayoutInfo(); &#125; return mPercentLayoutInfo; &#125; @Override protected void setBaseAttributes(TypedArray a, int widthAttr, int heightAttr) &#123; PercentLayoutHelper.fetchWidthAndHeight(this, a, widthAttr, heightAttr); &#125; &#125;&#125; 源码不长，主要是三个部分: 重写onMeasure，根据百分比转换成对应的尺寸 重写onLayout 自定义LayoutParams，在FrameLayout.LayoutParams的基础上多实现了一个接口。包含了PercentLayoutHelper.PercentLayoutInfo属性，而文档中对PercentLayoutInfo的介绍是Container for information about percentage dimensions and margins. It acts as an extension for LayoutParams. 我们也先一步步的来分析，首先看下mHelper.adjustChildren(widthMeasureSpec, heightMeasureSpec);:1234567891011121314151617181920212223242526272829303132333435363738394041/** * Iterates over children and changes their width and height to one calculated from percentage * values. * @param widthMeasureSpec Width MeasureSpec of the parent ViewGroup. * @param heightMeasureSpec Height MeasureSpec of the parent ViewGroup. */public void adjustChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"adjustChildren: \" + mHost + \" widthMeasureSpec: \" + View.MeasureSpec.toString(widthMeasureSpec) + \" heightMeasureSpec: \" + View.MeasureSpec.toString(heightMeasureSpec)); &#125; int widthHint = View.MeasureSpec.getSize(widthMeasureSpec); int heightHint = View.MeasureSpec.getSize(heightMeasureSpec); // mHost是由构造函数传递过来的，就是PercentFrameLayout自身。 for (int i = 0, N = mHost.getChildCount(); i &lt; N; i++) &#123; View view = mHost.getChildAt(i); ViewGroup.LayoutParams params = view.getLayoutParams(); if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"should adjust \" + view + \" \" + params); &#125; if (params instanceof PercentLayoutParams) &#123; // 通过PercentLayoutParams. getPercentLayoutInfo()方法得到PercentLayoutInfo，至于PercentLayoutInfo类在上面也说过了。 PercentLayoutInfo info = ((PercentLayoutParams) params).getPercentLayoutInfo(); if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"using \" + info); &#125; if (info != null) &#123; if (params instanceof ViewGroup.MarginLayoutParams) &#123; // PercentFrameLayout.LayoutParams继承自FrameLayout.LayoutParams，而FrameLayout.LayoutParams又继承自ViewGroup.MarginLayoutParams info.fillMarginLayoutParams(view, (ViewGroup.MarginLayoutParams) params, widthHint, heightHint); &#125; else &#123; info.fillLayoutParams(params, widthHint, heightHint); &#125; &#125; &#125; &#125;&#125; 所以上面代码的意思就是通过对每个子View调用getLayoutParams方法，然后从该LayoutParams中获取到它的PercentLayoutInfo属性，然后再调用PercentLayoutInfo.fillMarginLayoutParams()方法。 那我们继续看一下PercentLayoutInfo.fillMarginLayoutParams()方法的实现，该方法是根据百分比去设置尺寸和margin:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Fills &#123;@code ViewGroup.MarginLayoutParams&#125; dimensions and margins based on percentage * values. */public void fillMarginLayoutParams(View view, ViewGroup.MarginLayoutParams params, int widthHint, int heightHint) &#123; // 根据百分比值设置View的尺寸 fillLayoutParams(params, widthHint, heightHint); // 从注释中就能知道，fillLayoutParams是计算尺寸，那下面这部分就是处理margin了 // mPreservedParams来记录原始的margin值 // Preserve the original margins, so we can restore them after the measure step. mPreservedParams.leftMargin = params.leftMargin; mPreservedParams.topMargin = params.topMargin; mPreservedParams.rightMargin = params.rightMargin; mPreservedParams.bottomMargin = params.bottomMargin; MarginLayoutParamsCompat.setMarginStart(mPreservedParams, MarginLayoutParamsCompat.getMarginStart(params)); MarginLayoutParamsCompat.setMarginEnd(mPreservedParams, MarginLayoutParamsCompat.getMarginEnd(params)); if (leftMarginPercent &gt;= 0) &#123; params.leftMargin = (int) (widthHint * leftMarginPercent); &#125; if (topMarginPercent &gt;= 0) &#123; params.topMargin = (int) (heightHint * topMarginPercent); &#125; if (rightMarginPercent &gt;= 0) &#123; params.rightMargin = (int) (widthHint * rightMarginPercent); &#125; if (bottomMarginPercent &gt;= 0) &#123; params.bottomMargin = (int) (heightHint * bottomMarginPercent); &#125; boolean shouldResolveLayoutDirection = false; if (startMarginPercent &gt;= 0) &#123; MarginLayoutParamsCompat.setMarginStart(params, (int) (widthHint * startMarginPercent)); shouldResolveLayoutDirection = true; &#125; if (endMarginPercent &gt;= 0) &#123; MarginLayoutParamsCompat.setMarginEnd(params, (int) (widthHint * endMarginPercent)); shouldResolveLayoutDirection = true; &#125; if (shouldResolveLayoutDirection &amp;&amp; (view != null)) &#123; // Force the resolve pass so that start / end margins are propagated to the // matching left / right fields MarginLayoutParamsCompat.resolveLayoutDirection(params, ViewCompat.getLayoutDirection(view)); &#125; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"after fillMarginLayoutParams: (\" + params.width + \", \" + params.height + \")\"); &#125;&#125; 再看一下PercentLayoutInfo.fillLayoutParams()的实现，该方法是通过百分比设置View的尺寸: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Fills &#123;@code ViewGroup.LayoutParams&#125; dimensions based on percentage values. */public void fillLayoutParams(ViewGroup.LayoutParams params, int widthHint, int heightHint) &#123; // mPreservedParams来记录原始的宽高值 // Preserve the original layout params, so we can restore them after the measure step. mPreservedParams.width = params.width; mPreservedParams.height = params.height; // We assume that width/height set to 0 means that value was unset. This might not // necessarily be true, as the user might explicitly set it to 0. However, we use this // information only for the aspect ratio. If the user set the aspect ratio attribute, // it means they accept or soon discover that it will be disregarded. final boolean widthNotSet = (mPreservedParams.mIsWidthComputedFromAspectRatio || mPreservedParams.width == 0) &amp;&amp; (widthPercent &lt; 0); final boolean heightNotSet = (mPreservedParams.mIsHeightComputedFromAspectRatio || mPreservedParams.height == 0) &amp;&amp; (heightPercent &lt; 0); // 如果指定了百分比属性，就用宽高值和百分比去算出具体的宽高 if (widthPercent &gt;= 0) &#123; // 看到了吗？是根据父`View `的宽高来乘以百分比，不是根据整个屏幕的宽高，这样可能会有问题，要是ListView这种的高度没法算了 params.width = (int) (widthHint * widthPercent); &#125; if (heightPercent &gt;= 0) &#123; params.height = (int) (heightHint * heightPercent); &#125; // 如果指定了宽高的比例值，就用比例值去算出宽高，从这里能看出`aspectRatio`的优先级比百分比要高。他可以覆盖百分比之前设置的值。 if (aspectRatio &gt;= 0) &#123; if (widthNotSet) &#123; params.width = (int) (params.height * aspectRatio); // Keep track that we've filled the width based on the height and aspect ratio. mPreservedParams.mIsWidthComputedFromAspectRatio = true; &#125; if (heightNotSet) &#123; params.height = (int) (params.width / aspectRatio); // Keep track that we've filled the height based on the width and aspect ratio. mPreservedParams.mIsHeightComputedFromAspectRatio = true; &#125; &#125; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"after fillLayoutParams: (\" + params.width + \", \" + params.height + \")\"); &#125;&#125;``` 到这里`onMeasure`中通过百分比值设置宽高以及`margin`的部分就看完了，那我们接着看一下关于百分比值过小时对`wrap_content`的处理: ```javaif (mHelper.handleMeasuredStateTooSmall()) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125; 看一下PercentLayoutHelper.handleMeasuredStateTooSmall()方法的实现:12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Iterates over children and checks if any of them would like to get more space than it * received through the percentage dimension. * * If you are building a layout that supports percentage dimensions you are encouraged to take * advantage of this method. The developer should be able to specify that a child should be * remeasured by adding normal dimension attribute with &#123;@code wrap_content&#125; value. For example * he might specify child's attributes as &#123;@code app:layout_widthPercent=\"60%p\"&#125; and * &#123;@code android:layout_width=\"wrap_content\"&#125;. In this case if the child receives too little * space, it will be remeasured with width set to &#123;@code WRAP_CONTENT&#125;. * * @return True if the measure phase needs to be rerun because one of the children would like * to receive more space. */public boolean handleMeasuredStateTooSmall() &#123; boolean needsSecondMeasure = false; for (int i = 0, N = mHost.getChildCount(); i &lt; N; i++) &#123; View view = mHost.getChildAt(i); ViewGroup.LayoutParams params = view.getLayoutParams(); if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"should handle measured state too small \" + view + \" \" + params); &#125; if (params instanceof PercentLayoutParams) &#123; PercentLayoutInfo info = ((PercentLayoutParams) params).getPercentLayoutInfo(); if (info != null) &#123; // shouldHandleMeasuredWidthTooSmall方法来进行判断 if (shouldHandleMeasuredWidthTooSmall(view, info)) &#123; needsSecondMeasure = true; params.width = ViewGroup.LayoutParams.WRAP_CONTENT; &#125; if (shouldHandleMeasuredHeightTooSmall(view, info)) &#123; needsSecondMeasure = true; params.height = ViewGroup.LayoutParams.WRAP_CONTENT; &#125; &#125; &#125; &#125; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"should trigger second measure pass: \" + needsSecondMeasure); &#125; return needsSecondMeasure;&#125; 那继续看一下shouldHandleMeasuredWidthTooSmall()方法:12345private static boolean shouldHandleMeasuredWidthTooSmall(View view, PercentLayoutInfo info) &#123; int state = ViewCompat.getMeasuredWidthAndState(view) &amp; ViewCompat.MEASURED_STATE_MASK; return state == ViewCompat.MEASURED_STATE_TOO_SMALL &amp;&amp; info.widthPercent &gt;= 0 &amp;&amp; info.mPreservedParams.width == ViewGroup.LayoutParams.WRAP_CONTENT;&#125; 继续看ViewCompat.getMeasuredWidthAndState()的源码:123public static int getMeasuredWidthAndState(View view) &#123; return IMPL.getMeasuredWidthAndState(view);&#125; 继续往下看，这个IMPL是什么呢？123456789101112131415161718192021222324252627static final ViewCompatImpl IMPL;static &#123; final int version = android.os.Build.VERSION.SDK_INT; if (version &gt;= 23) &#123; IMPL = new MarshmallowViewCompatImpl(); &#125; else if (version &gt;= 21) &#123; IMPL = new LollipopViewCompatImpl(); &#125; else if (version &gt;= 19) &#123; IMPL = new KitKatViewCompatImpl(); &#125; else if (version &gt;= 17) &#123; IMPL = new JbMr1ViewCompatImpl(); &#125; else if (version &gt;= 16) &#123; IMPL = new JBViewCompatImpl(); &#125; else if (version &gt;= 15) &#123; IMPL = new ICSMr1ViewCompatImpl(); &#125; else if (version &gt;= 14) &#123; IMPL = new ICSViewCompatImpl(); &#125; else if (version &gt;= 11) &#123; IMPL = new HCViewCompatImpl(); &#125; else if (version &gt;= 9) &#123; IMPL = new GBViewCompatImpl(); &#125; else if (version &gt;= 7) &#123; IMPL = new EclairMr1ViewCompatImpl(); &#125; else &#123; IMPL = new BaseViewCompatImpl(); &#125;&#125; 继续看，IMPL.getMeasuredWidthAndState()，方法其实最终就是使用的BaseViewCompatImpl.getMeasuredWidthAndState()方法，接着看它的的源码:1234@Override public int getMeasuredWidthAndState(View view) &#123; return view.getMeasuredWidth(); &#125; 最后就是调用了getMeasuredWidth()方法。 没毛病- -! onMeasure的到这里就分析完了。那接着来看一下onLayout方法,onLayout方法直接调用了PercentLayoutHelper.restoreOriginalParams，:12345678910111213141516171819202122232425262728/** * Iterates over children and restores their original dimensions that were changed for * percentage values. Calling this method only makes sense if you previously called * &#123;@link PercentLayoutHelper#adjustChildren(int, int)&#125;. */public void restoreOriginalParams() &#123; for (int i = 0, N = mHost.getChildCount(); i &lt; N; i++) &#123; View view = mHost.getChildAt(i); ViewGroup.LayoutParams params = view.getLayoutParams(); if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"should restore \" + view + \" \" + params); &#125; if (params instanceof PercentLayoutParams) &#123; PercentLayoutInfo info = ((PercentLayoutParams) params).getPercentLayoutInfo(); if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"using \" + info); &#125; if (info != null) &#123; if (params instanceof ViewGroup.MarginLayoutParams) &#123; info.restoreMarginLayoutParams((ViewGroup.MarginLayoutParams) params); &#125; else &#123; info.restoreLayoutParams(params); &#125; &#125; &#125; &#125;&#125; 调用了PercentLayoutInfo.restoreMarginLayoutParams()方法，我们看下它的源码:1234567891011121314151617/** * Restores original dimensions and margins after they were changed for percentage based * values. Calling this method only makes sense if you previously called * &#123;@link PercentLayoutHelper.PercentLayoutInfo#fillMarginLayoutParams&#125;. */public void restoreMarginLayoutParams(ViewGroup.MarginLayoutParams params) &#123; restoreLayoutParams(params); // mPreservedParams的值在之前ad params.leftMargin = mPreservedParams.leftMargin; params.topMargin = mPreservedParams.topMargin; params.rightMargin = mPreservedParams.rightMargin; params.bottomMargin = mPreservedParams.bottomMargin; MarginLayoutParamsCompat.setMarginStart(params, MarginLayoutParamsCompat.getMarginStart(mPreservedParams)); MarginLayoutParamsCompat.setMarginEnd(params, MarginLayoutParamsCompat.getMarginEnd(mPreservedParams));&#125; 意思是说，再他们被以百分比为基础的数据更改之后恢复成原始的尺寸和margin。然后继续看一下restoreLayoutParams():123456789101112131415161718192021/*** Restores original dimensions after they were changed for percentage based values. Calling* this method only makes sense if you previously called* &#123;@link PercentLayoutHelper.PercentLayoutInfo#fillLayoutParams&#125;.*/public void restoreLayoutParams(ViewGroup.LayoutParams params) &#123; if (!mPreservedParams.mIsWidthComputedFromAspectRatio) &#123; // Only restore the width if we didn't compute it based on the height and // aspect ratio in the fill pass. params.width = mPreservedParams.width; &#125; if (!mPreservedParams.mIsHeightComputedFromAspectRatio) &#123; // Only restore the height if we didn't compute it based on the width and // aspect ratio in the fill pass. params.height = mPreservedParams.height; &#125; // Reset the tracking flags. mPreservedParams.mIsWidthComputedFromAspectRatio = false; mPreservedParams.mIsHeightComputedFromAspectRatio = false;&#125; 好了到这里也分析完了onLayout的方法，大意就是在onMeasure之前先将原始的宽高和margin都备份一下，然后在onMeasure中根据百分比去设置对应的宽高和margin，等到设置完之后在onLayout方法中再去将这些值恢复到之前备份的起始数据。说实话我没看明白为什么要这样做？ 通过上面的代码分析我们知道对布局影响力的优先顺序: app:layout_aspectRatio &gt; app:layout_heightPercent &gt; android:layout_height如果我们同时都设置这三个参数值的话，最终会用app:layout_aspectRatio的值。 遗留问题: 为什么在onLayout方法中去恢复数据，这有什么作用？ 看代码在处理如果指定的百分比过小但又指定wrap_content时，会重新根据wrap_content去重新计算的逻辑没有错，但是为什么我在上面测试的时候确没效果？ 在上面分析代码时看到fillLayoutParams中是根据父View的宽高来乘以百分比，不是根据整个屏幕的宽高，这样可能会有问题，要是ListView这种的高度没法算了。 邮箱 ：charon.chui@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"性能优化相关工具","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/性能优化相关工具/","text":"性能优化相关工具有关性能优化的文章请参考性能优化和布局优化 ###DDMS(百宝箱) #####查看进程的内存使用 DDMS可以让你查看到一个进程使用的堆内存。 在Device了表选择你想查看的进程。 点击Update Heap按钮来开启查看进程堆内存信息。 在Heap页面，点击Cause GC来执行垃圾回收。 在列表中点击一个对象类型来查看它所分配的内存大小。 #####追踪对象的内存分配情况 在Device了表选择你想查看的进程。 在Allocation Tracker页面，点击Start Tracking按钮来开始追踪。 点击Get Allocations来查看从你点击Start Tracking之后分配内存的对象列表。 你可以再次点击Get Allocations来添加新分配内存的对象列表。 停止追踪或者清除数据可以点击Stop Tracking按钮。 在列表中单独点击一行来查看详细的信息。 #####使用文件系统 DDMS提供了一个文件浏览器来供你查看、拷贝、删除文件。 在Device页面，选中你想要查看的设备。 从设备中拷贝文件，用文件浏览器选择文件后点击Pull file按钮。 拷贝文件到设备中，点击Push file按钮。 #####检查线程信息 Thread页面可以显示指定进程中当前正在运行的线程。 在Device页面，选择想要查看的进程。 点击Update Threads按钮。 在Thread页面，你可以查看对应的线程信息。 #####启动方法分析 方法分析可以追踪一个方法的特定信息，例如调用数量，执行时间、耗时等。如果想要更精确的控制想要收集的数据，可以使用startMethodTracing()和stopMethodTracing()方法。 在你开始使用方法分析之前请知晓如下限制: 在Android 2.1及以前的设备必须有SD卡，并且你的应用必须有写入SD卡的权限。 在Android 2.2及以后的设备中不需要SD卡，trace log文件会直接被导入到开发机上。 开启方法分析: 在Device页面，选择想要开启方法分析的进程。 点击Start Method Profiling按钮。 在Android 4.4及以后，可以选择trace_based profiling或者基本的sample-based profiling选项。在之前的版本智能使用trace-based profiling。 在应用中操作界面来执行你想要分析的方法。 点击Stop Method Profiling按钮。DDMS会停止分析并且将在Start Method Profiling和Stop Method Profiling中间手机的方法分析数据使用Traceview打开。 使用网络流量工具从Android 4.0开始,DDMS包含了一个网络使用情况的页面来支持跟踪应用的网络请求。 如图: 。 通过检测数据交互的频繁性以及在每次连接中数据的传递量，你可以知道应用中具体可以做的更好更高效的地方。想要更好的查看引起数据交互的地方，可以使用TrafficsStats这个API，它也可以使用setThreadStatsTag()方法来设置数据使用情况的tag， 首先要讲到的是Systrace，之前在淘宝面试的时候被问到，如有查找UI绘制卡顿的问题，我没答上来。早点知道Systrace就好了(当然只知道工具是不够的，也要懂得里面的原理)。 SystraceSystrace有什么用呢？官方文档中有一片文章的标题是：使用Systrace进行UI性能分析。 在应用程序开发的过程中，你需要检查用户交互是否平滑流畅，运行在稳定的60fps。如果中间出了些问题，导致某一帧延迟，我们想要解决该问题的第一步就是理解系统如何操作的。 Systrace工具可以让你来手机和观察整个android设备的时间信息，也称为trace。它会显示每个时间点上的CPU消耗图，显示每个线程在显示的内容以及每个进程当时在做的操作。 在使用Systracv来分析应用之前，你需要手机应用的trace log信息。生成的trace能够让你清晰的观察系统在该时间内所做的任何事情。 生成Trace为了能创建一个trace，你必须要执行如下几个操作。 首先，你要有一个Android 4.1及以上的设备。将该设备设置为debugging，连接你的设备并且安装应用。有些类型的信息，特别是一些硬盘的活动和内核工作队列，需要设备获取root权限才可以。 然而，大多数的Systrace log的数据只需要设备开启开发者debugging就可以了。 Systrace可以通过命令行或者图形化界面的方式来运行，在Studio中打开Android Device Monitor然后选择Systracv图标。 下面以命令行的方式为例，这里只讲解一下Android 4.3及以上的使用方式: 确保设备已经通过USB连接并且开启了debugging模式。 设置一些参数并执行trace命令，例如: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 $ cd android-sdk/platform-tools/systrace $ python systrace.py --time=10 -o mynewtrace.html sched gfx view wm ``` 执行完上面的命令后就会在`sdk/platform-tools/systrace/mynewtrace.html`生成对应的`html`文件。 - 在设备上执行一些你想要`trace`的过程。 悲剧了，生成了对应的`html`文件，但是我死活打不开。打开是白屏，折腾了我半天，最后终于找到了解决方法: &gt; Firstly, if anyone is using Chrome v50.0+ on OS X, just try this please.&gt; open chrome browser and go to &quot;chrome://tracing&quot;&gt; in the tracing page, click load and select the systrace generated html file.&gt; Secondly, I think it&apos;s a bug which is confirmed by Google.`OK`了。 ![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/systrace_file.png?raw=true =)。 看不懂！！！#####分析Trace用浏览器打开上面生成的`mynewtrace.html`。 下面为了能明显的说明，我就用官网提供的例子来说明了。 ######查看Frames从打开的文件中我们能看到每个应用都有一行`frame`的圆圈来标示渲染的帧，通常都是绿色的。黄色或者红的圆圈标示超过了我们对保障60fps所需的16毫秒绘制时间。。 可以在文件上面按`w`键来放大文件以便能更好的观看查找。 &gt; ***提示:***在文件上面按`?`键可以查看对应的快捷键。 ![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/frame-unselected.png?raw=true)。 在`Android 5.0`以上的设备上，显示工作呗分为`UI Thread`和`Render Thread`。在之前的版本，所有工作都是在`UI Thread`进行的。 点击某个单独的`frame`图标来查看它们所需的时间。######观看Alerts `Systracv`会自动分析`trace`过程的时间，并且通过`alerts`提示该展现问题，以及建议如何处理。 ![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/frame-selected.png?raw=true) 如上图所示，在你点击一个比较慢的`frame`时，下面就会显示一个`alert`。在这种情况下，它直说可能是`ListView`服用以及重复渲染的问题。 如果你发现`UI Thread`做了太多的工作，你可以使用`TraceView`进行代码分析，来找到具体哪些操作导致了消耗时间。如下，你也可以通过点击窗口右边的`Alerts`来查看当前所有的`alert`。这样会直接展开`Alert`窗口。 ![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/frame-selected-alert-tab.png?raw=true)下面我们以另外一个例子来分析一下它的`Frame`： 我们点击某一红色`frame`来查看这一阵的一些相关警告: ![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/systrace-frame-zoomin.png?raw=true)可以看到这里说耗时32毫秒，这已经远远超过了16毫秒的绘制时间。 我们可以通过`Description`来查看描述内容。 下面是另外一个渲染过慢的例子: ![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/systrace-2-frame.png?raw=true)从上图，我们发现了`Scheduling delay`的警告，加起来能看到总的绘制时间大约是19毫秒。 `Scheduling delay`的意思是调度延迟，也就是说一个县城在处理这部分操作时，在很长时间内没有被分配到`CPU`上面进行运算，这样就导致了很长时间内没有完成操作。 我们选择这一帧中最长的一块，来观察下: ![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/systrace-2-slice.png?raw=true)我们在上图看到了`Wall duration`，他代表着这一块开始到结束的总耗时。而在`CPU Duration`这里显示了`CPU`在处理该部分消耗的时间。 很明显，真个区域用了18毫秒，但是`CPU`实际处理只用了4毫秒，也就是说剩下的14毫秒就可能有问题了。 ![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/systrace-2-cpu.png?raw=true)可以看到，4个线程都比较忙。 选择其中一个线程来查看是哪个应用在使用它，这里看到了一个包名为`com.udinic.keepbusyapp`的应用。也就是说由于另外一个应用占用了`CPU`,，导致了我们的应用未能获取到足够的`CPU`资源。 #####追踪代码在`Android 4.3`以上你可以使用`Trace`类来在代码中添加(很熟悉有木有，在看源码的时候经常看到)。这样能查看到此时你的应用线程都做了哪些操作。 下面的代码展示了如何使用`Trace`类来追踪两个代码块部分: ```javapublic void ProcessPeople() &#123; Trace.beginSection(&quot;ProcessPeople&quot;); try &#123; Trace.beginSection(&quot;Processing Jane&quot;); try &#123; // code for Jane task... &#125; finally &#123; Trace.endSection(); // ends &quot;Processing Jane&quot; &#125; Trace.beginSection(&quot;Processing John&quot;); try &#123; // code for John task... &#125; finally &#123; Trace.endSection(); // ends &quot;Processing John&quot; &#125; &#125; finally &#123; Trace.endSection(); // ends &quot;ProcessPeople&quot; &#125;&#125; ###Traceview Traceview是一个性能测试工具，展示了所有方法的运行时间。 Traceview is a graphical viewer for execution logs that you create by using the Debug class to log tracing information in your code. Traceview can help you debug your application and profile its performance. #####创建Trace文件 想要使用Traceview你需要创建一个包含你想分析部分的trace信息的log文件。有两种方式来生成trace logs： 在你测试的类中添加startMethodTracing()和stopMethodTracing()的代码，来指定开始和结束获取trace信息。这种方式是非常精确的，因为你可以在代码中指定开始和结束的位置。 使用DDMS中的方法来生成。这种方式就不太精确。虽然这种方式不能精确的指定起始和结束位置，但是如果在你无法修改源代码或者不需要精确时间的时候是非常有用的。 在开始生成trace log信息时，你需要知道如下的限制条件: 如果你在测试代码中使用，你的应用必须要用WRITE_EXTERNAL_STORAGE的权限。 如果你使用DDMS生成: Android 2.1之前必须有SD卡，并且你的应用也要有写入SD卡的权限。 Android 2.2之后不需要SD卡，trace log文件会直接生成到你的开发机上。 在测试代码中调用startMethodTracing()方法的时候，你可以指定系统生成trace文件的名字。结束的时候调用stopMethodTracing()方法。这些方法开始和结束时贯穿整个虚拟中的。例如你可以在你activity的onCreate()方法中调用startMethodTracing()方法，然后在activity的onDestroy()方法中调用stopMethodTracing()方法。12345// start tracing to \"/sdcard/calc.trace\"Debug.startMethodTracing(\"calc\");// ...// stop tracingDebug.stopMethodTracing(); 在调用startMethodTracing()方法的时候，系统创建一个名为&lt;trace-base-name&gt;.trace的文件。它包含方法的二进制trace数据和一个线程与方法名的对应集合。然后系统就开始生成trace数据，直到调用stopMethodTracing()方法。如果在你调用stopMethodTracing()方法之前系统已经达到了最大的缓冲大小，系统就会停止trace并且在控制台发出一个通知。 #####拷贝Trace文件到电脑上 在模拟器或者机器上生成&lt;trace-base-name&gt;.trace文件后，你需要拷贝他们到你的电脑上，你可以使用adb pull命令来拷贝：adb pull /sdcard/calc.trace /tmp #####在Traceview中查看trace文件 运行Traceview并且查看trace文件: 打开Android Device Monitor。 在Android Device Monitor的状态栏中点击DDMS并且选择一个进程。 点击Start Method Profiling图标开始查看。 在查看完后点击Stop Method Profiling图标来显示traceview。 大体的样子如下: #####Traceview Layout 如果你有一个trace log文件(通过添加tracing代码或者用DDMS生成)，你可以把该文件加载到Traceview中，这将会把log数据显示为两部分: timeline panel-展示了每个线程和方法的起始和结束 profile panel-提供了一个方法中的执行内容的简述 #####Timeline Panel 每个线程都会以时间从左往右递增的方式在单独的一行中显示它的执行情况， #####Profile Panel 显示了一个方法所消耗的时间的概要情况。在表格中会同时显示inclusive和exclusive的时间。Exclusive的时间是该方法所消耗的时间。InClusive的时间是该方法消耗的时间加上任何调的方法所消耗的时间。我们简单的将调用的方法叫做parents，被调用的方法叫做children。如果一个方法被调用，它会显示对应的parents和children。parents会显示一个紫色的背景，children会显示一个黄色的背景。最后一列显示了该方法所调用的总数的调用数。在下面的图中我们能看到一共有14个地方调用了LoadListener.nativeFinished() . Name 方法名 Inclusive CPU Time， CPU在处理该方法以及所有子方法(被它调用的所有方法)所消耗的时间。 Exlusive CPU Time, CPU在处理该方法的耗时。 Inclusive/Exclusive Real Time， 从方法开始执行到执行结束的耗时。 Cal+Rec, 这个方法被调用的次数，以及递归被调用的次数。 CPU/Real time per Call, 在处理这个方法时的CPU耗时的平均值。 上图中getView方法被调用了12次，每次CPU消耗2.8秒，但是每次调用的总耗时是162秒，这里肯定有问题。而看看这个方法的children，我们可以看到这其中的每个方法在耗时方面是如何分布的。Thread.join()方法战局了98%的inclusive real time。这个方法在等待另一个线程结束的时候被调用。在Children中另外一个方法就是Tread.start()方法，而之所以整个方法耗时很长，我猜测是因为在getView()方法中启动了线程并且在等待它的结束。 但是这个线程在哪儿？ 我们在getView()方法中并不能看到这个线程做了什么，因为这段逻辑不在getView()方法之中。于是我找到了Thread.run()方法，就是在线程被创建出来时候所运行的方法。而跟随这个方法一路向下，我找到了问题的元凶。 我发现了BgService.doWork()方法的每次调用花费了将近14毫秒，并且有四十个这东西！而且getView()中还有可能调用多次这个方法，这就解释了为什么getView()方法执行时间如此之长。这个方法让CPU长时间的保持在了繁忙状态。而看看Exclusive CPU time，我们可以看到他占据了80%的CPU时间！此外，根据Exclusive CPU time排序，可以帮我们更好的定位那些耗时很长的方法，而他们很有可能就是造成性能问题的罪魁祸首。 关注这些耗时方法，例如getView()，View#onDraw()等方法，可以很好的帮助我们寻找为什么应用运行缓慢的原因。但有些时候，还会有一些其他的东西来占用宝贵的CPU资源，而这些资源如果被运用在UI的绘制上，也许我们的应用会更加流畅。Garbage Collector垃圾回收机制会不时的运行，回收那些没用的对象，通常来讲这不会影响我们在前台运行的程序。但如果GC被运行的过于频繁，他同样可以影响我们应用的执行效率。而我们该如何知道回收的是否过于频繁了呢… ###Monitors 在Android Studio中下方的Android Monitor中可以看到Monitors工具栏，它能不断的去检测内存、网络、CPU的消耗情况。 我们可以直接点击Dump Java Heap或者Call GC等按钮，以便更好的去观察内存的使用情况。点击后会生成一个.hprof的文件。生成后直接使用Studio打开.hprof文件即可。 说到这里插一嘴,有关Java垃圾回收机制请参考 在左边能看到所有堆内存中的实例。后面会显示他所占用的内存大小。 对于内存泄漏的分析可以使用MAT或者LeakCanary来进行。这里就不仔细说了。 #####不同虚拟机的内存管理 Android Monitor使用的Virtual Machine(VM): Android 4.3(API Level 18)及以前的版本使用Dalvik VM . Android 4.4(API Level 19)默认使用Dalvik VM，Android RunTime(ART)是可选的。 Android 4.3(API Level 18)及更高的版本使用ART VM. 虚拟之执行垃圾回收。Dalvik虚拟机使用一个标记和清除垃圾收集方案。ART虚拟机使用分代收集算法与标记和清楚手机算法相结合的方式。 Logcat会显示一些垃圾回收相关的信息。 #####GPU使用情况 上面也显示了GPU的使用情况，这里要说一句，如果想要显示它，必须要在手机的开发者中心中开启GPU显示配置文件选项，将其设置为显示与adb shell dumpsys gfxinfo。然后再点击Studio中的按钮重新开始就可以看到了。 每一条线意味着一帧被绘制出来了。而线的颜色又代表不同的阶段： Draw(蓝色)代表着View.onDraw()方法。如果这个值很高就说明可能是该View比较复杂。 在这个环节会创建/刷新DisplayList中的对象，这些对象在后面会被转换成GPU可以明白的OpenGL命令。而这个值比较高可能是因为view比较复杂，需要更多的时间去创建他们的display list，或者是因为有太多的view在很短的时间内被创建。 Prepare(紫色)，从Android 6.0开始，一个新的线程被引进来帮助UI线程进行绘制。 这个线程叫做Render Thread。它负责转换它负责转换display list到OpenGL命令并且送至GPU。在这过程中，UI线程可以继续开始处理后面的帧。而在UI线程将所有资源传递给RenderThread过程中所消耗的时间，就是紫色阶段所消耗的时间。如果在这过程中有很多的资源都要进行传递，display list会变得过多过于沉重，从而导致在这一阶段过长的耗时。 Process(红色) 执行Display list中的内容并创建OpenGL命令。如果有过多或者过于复杂的display list需要执行的话，那么这阶段会消耗较长的时间，因为这样的话会有很多的view被重绘。而重绘往往发生在界面的刷新或是被移动出了被覆盖的区域。 Execute (黄色) – 发送OpenGL命令到GPU。这个阶段是一个阻塞调用，因为CPU在这里只会发送一个含有一些OpenGL命令的缓冲区给GPU，并且等待GPU返回空的缓冲区以便再次传递下一帧的OpenGL命令。而这些缓冲区的总量是一定的，如果GPU太过于繁忙，那么CPU则会去等待下一个空缓冲区。所以，如果我们看到这一阶段耗时比较长，那可能是因为GPU过于繁忙的绘制UI，而造成这个的原因则可能是在短时间内绘制了过于复杂的view。 Measure/Layout(绿色) 代表Measure和Layout的时间。 ###Hierarchy Viewer 布局分析工具，非常常用。 在Android Device Monitor中打开Hierarchy Viewer即可。 连接你的手机或者模拟器。 出于安全性考虑，Hierarchy Viewer只能连接开发者版的系统的手机。 运行程序，并且让界面显示出来。 启动hierarchy view工具，接着就能看到左边栏显示出了对应的设备，展开后可以看到一些组件的名称。这个页面包含了应用的界面以及系统的界面。选择你的应用中想要查看的界面直接双击就可以了。 如果你的界面显示的不是这个样子，少一些东西的话，你可以使用Window&gt;Reset Perspective来重置样式。 但是我并打不开。如果你的手机是Android 4.1及以上版本你必须要在你的电脑上设置一个ANDROID_HVPROTODE 环境变量才可以。 Windows 增加一个名为ANDROID_HVPROTO值为ddm的环境变量就可以了。 Mac 打开.bash_profile touch .bash_profile创建 open -e .bash_profile打开 添加 12#Hierarchy Viewer Variable export ANDROID_HVPROTO=ddm source .bash_profile 如果配置完成后仍然不能用的话，你可以: 关闭Android Studio. 执行add kill-server，然后adb start-server. 通过命令行开始hierarchyviewer. 好了，我们直接打开自己的页面进行查看布局吧(有点慢)。它是介个样子滴 ： 我们可以看到所有结构，点击对一个的节点，能直接看到该界面的UI效果，并展示该布局包含多少个View，以及该布局measure,draw,layout所消耗的时间。选中Show Extras选项可以看到在右下角看到界面效果。 选中要查看的节点后点击Profile Node选项，可以看到如下界面: 可以看到每个布局都出现了三个点。有不同的颜色,从左到右这三个点分别表示: 左边的点代表Draw阶段。 中间的点代表了Layout阶段。 右边的点代表了Execute阶段。 这三个点有分别对应了pipeline中的不同阶段，如下图: 不同的颜色代表不同的性能: 绿色代表渲染的非常快，至少是其他View的一半。 黄色代表View渲染比最后那一半的View快。 红色代表View渲染是几乎是在最慢的那部分中间。 Hierarchy Viewer测量的是相对的表现能力，所以总会有一个红色的节点，它并不意味者该View一定是绘制的太慢。 ###过度绘制 在开发者选项中将调试GPU过度绘制设置为显示过度绘制区域，就能看到程序的绘制情况。过度绘制往往发生在我们需要在一个东西上面绘制另外一个东西，例如在一个红色的背景上画一个黄色的按钮。那么GPU就需要先画出红色背景，再在他上面绘制黄色按钮，此时过度绘制就是不可避免的了。如果我们有太多层需要绘制，那么则会过度的占用GPU导致我们每帧消耗的时间超过16毫秒。这些过度绘制可能发生在我们给Activity或Fragment设置了全屏的背景，同时又给ListView以及ListView的条目设置了背景色。而通过只设置一次背景色即可解决这样的问题。 注意：默认的主题会为你指定一个默认的全屏背景色，如果你的activity又一个不透平的背景盖住了默认的背景色，那么你可以移除主题默认的背景色，这样也会移除一层的过度绘制。这可以通过配置主题配置或是通过代码的方法，在onCreate()方法中调用getWindow().setBackgroundDrawable(null)方法来实现。 ###Hardware Acceleration 在Honeycomb版本中引入了硬件加速（Hardware Accleration）后，我们的应用在绘制的时候就有了全新的绘制模型。它引入了DisplayList结构，用来记录View的绘制命令，以便更快的进行渲染。但还有一些很好的功能开发者们往往会忽略或者使用不当——View layers。 使用View layers（硬件层），我们可以将view渲染入一个非屏幕区域缓冲区（off-screen buffer，前面透明度部分提到过），并且根据我们的需求来操控它。这个功能主要是针对动画，因为它能让复杂的动画效果更加的流畅。而不使用硬件层的话，View会在动画属性（例如coordinate, scale, alpha值等）改变之后进行一次刷新。而对于相对复杂的view，这一次刷新又会连带它所有的子view进行刷新，并各自重新绘制，相当的耗费性能。使用View layers，通过调用硬件层，GPU直接为我们的view创建一个结构，并且不会造成view的刷新。而我们可以在避免刷新的情况下对这个结构进行进行很多种的操作，例如x/y位置变换，旋转，透明度等等。总之，这意味着我们可以对一个让一个复杂view执行动画的同时，又不会刷新！这会让动画看起来更加的流畅。在阅读了ViewPager的源码后，我发现了在滑动的时候会自动为左右两页启动一个硬件层，并且在滑动结束后移除掉。 在两页间滑动的时候创建硬件层也是可以理解的，但对我来说小有不幸。通常来讲加入硬件层是为了让ViewPager的滑动更加流畅，毕竟它们相对复杂。 是的，但是再使用硬件layers的时候还是有几点要牢记在心： 回收 – 硬件层会占用GPU中的一块内存。只在必要的时候使用他们，比如动画，并且事后注意回收。例如在上面ObjectAnimator的例子中，我们增加了一个动画结束监听以便在动画结束后可以移除硬件层。而在Property animator的例子中，我们使用了withLayers()，这会在动画开始时候自动创建硬件层并且在结束的时候自动移除。 如果你在调用了硬件View layers后改变了View，那么会造成硬件硬件层的刷新并且再次重头渲染一遍view到非屏幕区域缓存中。这种情况通常发生在我们使用了硬件层暂时还不支持的属性（目前为止，硬件层只针对以下几种属性做了优化：otation、scale、x/y、translation、pivot和alpha）。例如，如果你另一个view执行动画，并且使用硬件层，在屏幕滑动他们的同时改变他的背景颜色，这就会造成硬件层的持续刷新。而以硬件层的持续刷新所造成的性能消耗来说，可能让它在这里的使用变得并不那么值。 有关如何使用Hardware Layer请参考之前写的文章:通过Hardware Layer提高动画性能 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"视频播放相关内容总结","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/视频播放相关内容总结/","text":"视频播放相关内容总结多媒体常识： 什么是多媒体 多媒体是计算机和视频技术的结合，实际上它是两个媒体；声音和图像，或者用现在的术语：音响和电视 常用的视频格式 Android系统默认：mp4、3gp 常用格式：ts、3gpp、3g2、3gpp2、avi、mkv、flv、divx、f4v、rm、rmvb、rv、wmv、asf、mov、mpg、v8、ram、mpeg、 swf、m2v、asx、ra、ram、ndivx、xvid等 常用音频格式： Android系统：mp3、ogg； 常用格式：wma、mid、m4a、xmf、aac、mpa、midi、ar等 常用图片格式：PNG、GIF、BMP、jpg 国内各个视频网站采用的解码框架： 优酷、搜狐、奇艺、pps、暴风影音土豆、56网都是用的ffmpeg. pptv已经使用p2p技术 点对点技术（peer-to-peer， 简称P2P）又称对等互联网络技术，是一种网络新技术，依赖网络中参与者的计算能力和带宽， 而不是把依赖都聚集在较少的几台服务器上。P2P网络通常用于通过Ad Hoc连接来连接节点。这类网络可以用于多种用途， 各种档案分享软件已经得到了广泛的使用。P2P技术也被使用在类似VoIP等实时媒体业务的数据通信中。 目前常用的开发框架： VLC框架： VLC是一个开源项目，基于ffmpeg框架的自定义播放器。其中LibVLC是VLC的核心部分，就相当于MediaPlayer类 VLC一个最主要的部分，它可以播放各种类型的媒体文件和流媒体文件，并且可以创造媒体流并保存成各种格式的媒体文件 VLC是一种跨平台的媒体播放器和流媒体服务器，最初为videolan的客户端，它是一种非常简便的多媒体播放器， 它可以用来播放各种各样的音视频的格式文件(MPEG-1、MPEG-2、MPEG- 4、DivX、WMV、mp3、OGG、Vorbis、AC3、AAC等等)流媒体协议 最具特色的功能是可以边下载边观看Divx媒体文件，并可以播放不完全的AVI文件。并且支持界面的更改。 缺点：有C/C++代码，还有Java代码，代码太庞大 ffmpeg框架： 优点：轻量级框架，易于维护 FFmpeg是一个集录制、转换、音/视频编码解码功能为一体的完整的开源解决方案 FFMPEG几乎为你把所有的繁重工作都做了，比如解码、编码、复用和解复用。 这使得多媒体应用程序变得容易编写。它是一个简单的，用C编写的，快速的并且能够解码几乎所有你能用到的格式，当然也包括编码多种格式。 FFmpeg支持MPEG、DivX、MPEG4、AC3、DV、FLV等40多种编码，支持AVI、MPEG、OGG、Matroska、ASF等90多种解码 FFmpeg主目录下主要有libavcodec、libavformat和libavutil等子目录。其中libavcodec用于存放各个encode/decode模块 libavformat用于存放muxer/demuxer模块，libavutil用于存放内存操作等辅助性模块 vitamio框架： vitamio也是基于ffmpeg开源框架 VPlayer是vitamio的一个产品，vitamio和VPlayer是同一个团队开发的，VPlayer能播放的vitamio也能播放 ##Surface简介 Surface就是“表面”的意思。在SDK的文档中，对Surface的描述是这样的：“Handle onto a raw buffer that is being managed by the screen compositor”， 翻译成中文就是“由屏幕显示内容合成器(screen compositor)所管理的原生缓冲器的句柄”， 这句话包括下面两个意思： 通过Surface（因为Surface是句柄）就可以获得原生缓冲器以及其中的内容。就像在C语言中，可以通过一个文件的句柄，就可以获得文件的内容一样； 原生缓冲器（rawbuffer）是用于保存当前窗口的像素数据的。 简单的说Surface对应了一块屏幕缓冲区，每个Window对应一个Surface，任何View都是画在Surface上的，传统的view共享一块屏幕缓冲区，所有的绘制必须在UI线程中进行 我们不能直接操作Surface实例，要通过SurfaceHolder，在SurfaceView中可以通过getHolder()方法获取到SurfaceHolder实例。 Surface是一个用来画图形的地方，但是我们知道画图都是在一个Canvas对象上面进行的，Surface中的Canvas成员，是专门用于提供画图的地方，就像黑板一样，其中的原始缓冲区是用来保存数据的地方， Surface本身的作用类似一个句柄，得到了这个句柄就可以得到其中的Canvas、原始缓冲区以及其他方面的内容，所以简单的说Surface是用来管理数据的(句柄)。 ##SurfaceView简介 简单的说SurfaceView就是一个有Surface的View里面内嵌了一个专门用于绘制的Surface,SurfaceView控制这个Surface的格式和尺寸以及绘制位置.SurfaceView是一个View也许不够严谨， 然而从定义中 public class SurfaceView extends View显示SurfaceView确实是派生自View，但是SurfaceView却有着自己的Surface，源码： 1234567 if (mWindow == null) &#123; mWindow = new MyWindow(this); mLayout.type = mWindowType; mLayout.gravity = Gravity.LEFT|Gravity.TOP; mSession.addWithoutInputChannel(mWindow, mWindow.mSeq, mLayout, mVisible ? VISIBLE : GONE, mContentInsets); &#125; 很明显，每个SurfaceView创建的时候都会创建一个MyWindow，new MyWindow(this)中的this正是SurfaceView自身，因此将SurfaceView和window绑定在一起，而前面提到过每个window对应一个Surface， 所以SurfaceView也就内嵌了一个自己的Surface，可以认为SurfaceView是来控制Surface的位置和尺寸。传统View及其派生类的更新只能在UI线程，然而UI线程还同时处理其他交互逻辑， 这就无法保证view更新的速度和帧率了，而SurfaceView可以用独立的线程来进行绘制，因此可以提供更高的帧率，例如游戏，摄像头取景等场景就比较适合用SurfaceView来实现。 Surface是纵深排序(Z-ordered)的，这表明它总在自己所在窗口的后面。 Surfaceview提供了一个可见区域，只有在这个可见区域内的Surface部分内容才可见，可见区域外的部分不可见，所以可以认为SurfaceView就是展示Surface中数据的地方,Surface就是管理数据的地方， SurfaceView就是展示数据的地方，只有通过SurfaceView才能展现Surface中的数据。 Surface的排版显示受到视图层级关系的影响，它的兄弟视图结点会在顶端显示。这意味者Surface的内容会被它的兄弟视图遮挡，这一特性可以用来放置遮盖物(overlays)(例如，文本和按钮等控件)。 注意，如果Surface上面有透明控件，那么它的每次变化都会引起框架重新计算它和顶层控件的透明效果，这会影响性能。surfaceview变得可见时，surface被创建；surfaceview隐藏前，surface被销毁。 这样能节省资源。如果你要查看 surface被创建和销毁的时机，可以重载surfaceCreated(SurfaceHolder)和 surfaceDestroyed(SurfaceHolder)。 SurfaceView的核心在于提供了两个线程：UI线程和渲染线程,两个线程通过“双缓冲”机制来达到高效的界面适时更新。 ##SurfaceHolder简介 显示一个Surface的抽象接口，使你可以控制Surface的大小和格式以及在Surface上编辑像素，和监视Surace的改变。这个接口通常通过SurfaceView类实现。简单的说就是我们无法直接操作Surface只能通过SurfaceHolder这个接口来获取和操作Surface。SurfaceHolder中提供了一些lockCanvas()`：获取一个Canvas对象，并锁定之。所得到的Canvas对象，其实就是Surface中一个成员。加锁的目的其实就是为了在绘制的过程中，Surface中的数据不会被改变。lockCanvas是为了防止同一时刻多个线程对同一canvas写入。 从设计模式的角度来看,Surface、SurfaceView、SurfaceHolder实质上就是MVC(Model-View-Controller)，Model就是模型或者说是数据模型，更简单的可以理解成数据，在这里也就是Surface，View就是视图，代表用户交互界面，这里就是SurfaceView,SurfaceHolder就是Controller. ##MediaController MediaController继承FrameLayout，通过MediaPlayerControl接口与VideoView进行结合控制，内部是通过PopupWindow将整个控制栏界面显示到界面上， 而该PopupWindow所显示在的位置就是通过setAnchorView()设置进来的Anchor一般可以使当前的VideoView或者是整个Activity的根布局。这里要分为小屏和全屏两种情况来进行设置。 如果当前的MediaController只是播放前下面的控制栏部分(进度条、快进、快退、暂停等)这样我们可以通过对VideoView设置点击事件，控制它的显示和隐藏。 如果MediaController为整个屏幕包括了控制栏部分、上端的信息显示部分、以及左右栏的功能部分、这时候就可以通过对MediaController本身设置点击事件来控制显示和隐藏。 Controller可以用PopupWindow来实现,具体有两种方式： - 整个控制栏(上面的信息部分、下面的控制部分以及左右边)都在`Controller`中，`setAnchorView()`的时候就会让`Controller`中的`PopupWindow`显示出来(一直显示，但是这个`PopupWindow`是透明的)， 真正的显示与隐藏是控制在`PopupWindow`中的`View`部分的显示与隐藏来实现。开始的时候我是想用这种方式，当时我想的是播放就播放、控制就控制，分离开来多好，但是没想到， 一旦有`PopupWindow`显示出来后，Activity是接收不到任何`Touch`事件的，所有的重试界面等都要放到`Controller`中实现(手势处理等)。但是也有好处，就是不管显示还是隐藏都可以去处理手势. - `PopupWindow`不是全屏的，只包含下面真正的控制部分(快进、快退、暂停等,不包含上面的信息部分和左右边),而且也不是开始就显示，显示隐藏是通过控制`PopupWindow`的显示与隐藏来进行的。 而对于信息部分、以及左右边都是在`Activity`的布局当中，我们通过接口回调得到`PopupWindow`的显示与隐藏来控制这些布局的显示与隐藏即可。 这样的话我们就需要将手势等全部放到`Activity`中去处理，但是也有一个问题，就是如果`Controller`正在显示的话`Activity`是接收不到`Touch`事件的，就无法处理手势，只能是让`Controller`消失后才能处理手势。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"热修复实现","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/热修复实现/","text":"热修复实现现在的热修复方案已经有很多了，例如alibaba的dexposed、AndFix以及jasonross的Nuwa等等。原来没有仔细去分析过也没想写这篇文章，但是之前InstantRun详解这篇文章中介绍了Android Studio Instant Run的实现原理，这不就是活生生的一个热修复吗？ 随心情久久不能平复，我们何不用这种方式来实现。 方案有很多种，我就只说明下我想到的方式，也就是Instant Run的方式:分拆到不同的dex中，然后通过classloader来进行加载。但是在之前InstantRun详解中只说到会通过内部的server去判断该类是否有更新，如果有的话就去从新的dex中加载该类，否则就从旧的dex中加载，但这是如何实现的呢？ 怎么去从不同的dex中选择最新的那个来进行加载。 讲到这里需要先介绍一下ClassLoader： &lt; A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &quot;class file&quot; of that name from a file system. 在一般情况下，应用程序不需要创建一个全新的ClassLoader对象，而是使用当前环境已经存在的ClassLoader。因为Javad的Runtime环境在初始化时，其内部会创建一个ClassLoader对象用于加载Runtime所需的各种Java类。每个ClassLoader必须有一个父ClassLoader，在装载Class文件时，子ClassLoader会先请求父ClassLoader加载该Class文件，只有当其父ClassLoader找不到该Class文件时，子ClassLoader才会继续装载该类，这是一种安全机制。 对于Android的应用程序，本质上虽然也是用Java开发，并且使用标准的Java编译器编译出Class文件，但最终的APK文件中包含的却是dex类型的文件。dex文件是将所需的所有Class文件重新打包，打包的规则不是简单的压缩，而是完全对Class文件内部的各种函数表、变量表等进行优化，并产生一个新的文件，这就是dex文件。由于dex文件是一种经过优化的Class文件，因此要加载这样特殊的Class文件就需要特殊的类装载器，这就是DexClassLoader，Android SDK中提供的DexClassLoader类就是出于这个目的。 总体来说，Android 默认主要有三个ClassLoader: BootClassLoader: 系统启动时创建， &lt; `Provides an explicit representation of the boot class loader. It sits at the head of the class loader chain and delegates requests to the VM’s internal class loading mechanism.` PathClassLoader: 可以加载/data/app目录下的apk，这也意味着，它只能加载已经安装的apk； DexClassLoader: 可以加载文件系统上的jar、dex、apk；可以从SD卡中加载未安装的apk 通过上面的分析知道，如果用多个dex的话肯定会用到DexClassLoader类，我们首先来看一下它的源码(这里插一嘴，源码可以去googlesource中找):123456789101112131415161718192021222324252627282930313233343536373839/** * A class loader that loads classes from &#123;@code .jar&#125; and &#123;@code .apk&#125; files * containing a &#123;@code classes.dex&#125; entry. This can be used to execute code not * installed as part of an application. * * &lt;p&gt;This class loader requires an application-private, writable directory to * cache optimized classes. Use &#123;@code Context.getDir(String, int)&#125; to create * such a directory: &lt;pre&gt; &#123;@code * File dexOutputDir = context.getDir(\"dex\", 0); * &#125;&lt;/pre&gt; * * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt; * External storage does not provide access controls necessary to protect your * application from code injection attacks. */public class DexClassLoader extends BaseDexClassLoader &#123; /** * Creates a &#123;@code DexClassLoader&#125; that finds interpreted and native * code. Interpreted classes are found in a set of DEX files contained * in Jar or APK files. * * &lt;p&gt;The path lists are separated using the character specified by the * &#123;@code path.separator&#125; system property, which defaults to &#123;@code :&#125;. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by &#123;@code File.pathSeparator&#125;, which * defaults to &#123;@code \":\"&#125; on Android * @param optimizedDirectory directory where optimized dex files * should be written; must not be &#123;@code null&#125; * @param libraryPath the list of directories containing native * libraries, delimited by &#123;@code File.pathSeparator&#125;; may be * &#123;@code null&#125; * @param parent the parent class loader */ public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent); &#125;&#125; 注释说的太明白了，这里就不翻译了，但是我们并没有找到加载的代码，去它的父类中查找，因为家在都是从loadClass()方法中，所以我们去ClassLoader类中看一下loadClass()方法:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Loads the class with the specified name. Invoking this method is * equivalent to calling &#123;@code loadClass(className, false)&#125;. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; In the Android reference implementation, the * second parameter of &#123;@link #loadClass(String, boolean)&#125; is ignored * anyway. * &lt;/p&gt; * * @return the &#123;@code Class&#125; object. * @param className * the name of the class to look for. * @throws ClassNotFoundException * if the class can not be found. */ public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123; return loadClass(className, false); &#125; /** * Loads the class with the specified name, optionally linking it after * loading. The following steps are performed: * &lt;ol&gt; * &lt;li&gt; Call &#123;@link #findLoadedClass(String)&#125; to determine if the requested * class has already been loaded.&lt;/li&gt; * &lt;li&gt;If the class has not yet been loaded: Invoke this method on the * parent class loader.&lt;/li&gt; * &lt;li&gt;If the class has still not been loaded: Call * &#123;@link #findClass(String)&#125; to find the class.&lt;/li&gt; * &lt;/ol&gt; * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; In the Android reference implementation, the * &#123;@code resolve&#125; parameter is ignored; classes are never linked. * &lt;/p&gt; * * @return the &#123;@code Class&#125; object. * @param className * the name of the class to look for. * @param resolve * Indicates if the class should be resolved after loading. This * parameter is ignored on the Android reference implementation; * classes are not resolved. * @throws ClassNotFoundException * if the class can not be found. */ protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = findLoadedClass(className); if (clazz == null) &#123; ClassNotFoundException suppressed = null; try &#123; // 先检查父ClassLoader是否已经家在过该类 clazz = parent.loadClass(className, false); &#125; catch (ClassNotFoundException e) &#123; suppressed = e; &#125; if (clazz == null) &#123; try &#123; // 调用DexClassLoader.findClass()方法。 clazz = findClass(className); &#125; catch (ClassNotFoundException e) &#123; e.addSuppressed(suppressed); throw e; &#125; &#125; &#125; return clazz; &#125; 上面会调用DexClassLoader.findClass()方法，但是DexClassLoader没有实现该方法，所以去它的父类BaseDexClassLoader中看，接着看一下BaseDexClassLoader的源码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Base class for common functionality between various dex-based * &#123;@link ClassLoader&#125; implementations. */public class BaseDexClassLoader extends ClassLoader &#123; /** originally specified path (just used for &#123;@code toString()&#125;) */ private final String originalPath; /** structured lists of path elements */ private final DexPathList pathList; /** * Constructs an instance. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by &#123;@code File.pathSeparator&#125;, which * defaults to &#123;@code \":\"&#125; on Android * @param optimizedDirectory directory where optimized dex files * should be written; may be &#123;@code null&#125; * @param libraryPath the list of directories containing native * libraries, delimited by &#123;@code File.pathSeparator&#125;; may be * &#123;@code null&#125; * @param parent the parent class loader */ public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.originalPath = dexPath; this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; // 从DexPathList中找 Class clazz = pathList.findClass(name); if (clazz == null) &#123; throw new ClassNotFoundException(name); &#125; return clazz; &#125; @Override protected URL findResource(String name) &#123; return pathList.findResource(name); &#125; @Override protected Enumeration&lt;URL&gt; findResources(String name) &#123; return pathList.findResources(name); &#125; @Override public String findLibrary(String name) &#123; return pathList.findLibrary(name); &#125; 在findClass()方法中我们看到调用了DexPathList.findClass()方法:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * A pair of lists of entries, associated with a &#123;@code ClassLoader&#125;. * One of the lists is a dex/resource path &amp;mdash; typically referred * to as a \"class path\" &amp;mdash; list, and the other names directories * containing native code libraries. Class path entries may be any of: * a &#123;@code .jar&#125; or &#123;@code .zip&#125; file containing an optional * top-level &#123;@code classes.dex&#125; file as well as arbitrary resources, * or a plain &#123;@code .dex&#125; file (with no possibility of associated * resources). * * &lt;p&gt;This class also contains methods to use these lists to look up * classes and resources.&lt;/p&gt; *//*package*/ final class DexPathList &#123; private static final String DEX_SUFFIX = \".dex\"; private static final String JAR_SUFFIX = \".jar\"; private static final String ZIP_SUFFIX = \".zip\"; private static final String APK_SUFFIX = \".apk\"; /** class definition context */ private final ClassLoader definingContext; /** list of dex/resource (class path) elements */ // 把dex封装成一个数组，每个Element代表一个dex private final Element[] dexElements; /** list of native library directory elements */ private final File[] nativeLibraryDirectories; // ..... /** * Finds the named class in one of the dex files pointed at by * this instance. This will find the one in the earliest listed * path element. If the class is found but has not yet been * defined, then this method will define it in the defining * context that this instance was constructed with. * * @return the named class or &#123;@code null&#125; if the class is not * found in any of the dex files */ public Class findClass(String name) &#123; for (Element element : dexElements) &#123; DexFile dex = element.dexFile; // 遍历数组，拿到第一个就返回 if (dex != null) &#123; Class clazz = dex.loadClassBinaryName(name, definingContext); if (clazz != null) &#123; return clazz; &#125; &#125; &#125; return null; &#125;&#125; 从上面的源码中分析，我知道系统会把所有相关的dex维护到一个数组中，然后在加载类的时候会从该数组中的第一个元素中取，然后返回。那我们只要保证将我们热修复后的dex对应的Element放到该数组的第一个位置就可以了，这样系统就会加载我们热修复的dex中的类。所以方案出来了，只要把有问题的类修复后，放到一个单独的dex，然后把该Dex转换成对应的Element后再将该Element插入到dexElements数组的第一个位置就可以了。那该如何去将其插入到dexElements数组的第一个位置呢？– 暴力反射。 到这里我感觉初步的思路已经有了: 将补丁作为dex发布。 通过反射修改该dex所对应的Element在数组中的位置。 但是我也想到肯定还会有类似下面的问题: 资源文件的处理 四大组件的处理 清单文件的处理 虽然我知道没有这么简单，但是我还是决定抱着不作不死的宗旨继续前行。 好了，demo走起来。 怎么生成dex文件呢？这要讲过两部分: .class-&gt; .jar : jar -cvf test.jar com/charon/instantfix_sample/MainActivity.class .jar-&gt; .dex: dx --dex --output=target.jar test.jar target.jar就是包含.dex的jar包 生成好dex后我们为了模拟先将其放到asset目录下(实际开发中肯定要从接口中去下载，当然还会有一些版本号的判断等)，然后就是将该dex转换成 我的方案中采用的是MultiDex，对其进行一部分改造，具体代码：1、添加dex文件，并执行install/** 添加apk包外的dex文件 自动执行install @param dexFile*/public static void addDexFileAutoInstall(Context context, List dexFile,File optimizedDirectory) { if (dexFile != null &amp;&amp; !dexFile.isEmpty() &amp;&amp;!dexFiles.contains(dexFile)) {dexFiles.addAll(dexFile); LogUtil.d(TAG, &quot;add other dexfile&quot;); installDexFile(context,optimizedDirectory); }}2、installDexFile直接调用MultiDex 的installSecondaryDexes方法。/** 添加apk包外的dex文件， @param context*/publicstatic void installDexFile(Context context, File optimizedDirectory){if (checkValidZipFiles(dexFiles)) {try { installSecondaryDexes(context.getClassLoader(), optimizedDirectory, dexFiles); } catch (IllegalAccessExceptione){ e.printStackTrace(); } catch (NoSuchFieldExceptione) { e.printStackTrace(); } catch (InvocationTargetExceptione){ e.printStackTrace(); } catch (NoSuchMethodExceptione) { e.printStackTrace(); } catch (IOExceptione) { e.printStackTrace(); } }}3、将patch.dex放在所有dex最前面。private static voidexpandFieldArray(Object instance, String fieldName, Object[]extraElements) throws NoSuchFieldException, IllegalArgumentException,IllegalAccessException { Field jlrField = findField(instance, fieldName); Object[]original = (Object[]) jlrField.get(instance); Object[]combined = (Object[]) Array.newInstance(original.getClass().getComponentType(),original.length + extraElements.length); // 将后来的dex放在前面，主dex放在最后。 System.arraycopy(extraElements, 0, combined, 0, extraElements.length); System.arraycopy(original, 0, combined, extraElements.length,original.length); // 原始的dex合并，是将主dex放在前面，其他的dex依次放在后面。 //System.arraycopy(original, 0, combined, 0, original.length); //System.arraycopy(extraElements, 0, combined, original.length,extraElements.length); jlrField.set(instance, combined); }到此将patch.dex放进了Element，接下来的问题就是加载Class，当加载patch.dex中类的时候，会遇到一个问题，这个问题就是QQ空间团队遇到,Classd的CLASS_ISPREVERIFIED。具体原因是dvmResolveClass这个方法对Class进行了校验。判断这个要Resolve的class是否和其引用来自一个dex。如果不是，就会遇到问题。 当引用这和被引用者不在同一个dex中就会抛出异常，导致Resolve失败。QQ空间团队的方案是阻止所有的Class类打上CLASS_ISPREVERIFIED来逃过校验，这种方式其实是影响性能。我们的方案是和QQ团队的类似，但是和QQ空间不同的是，我们将fromUnverifiedConstant设置为true，来逃过校验，达到补丁的路径。具体怎么实现呢？要引用Cydia Hook技术来hook Native dalvik中dvmResolveClass这个方法。有关Cydia Hook技术请参考：官网地址：http://www.cydiasubstrate.com/官方教程：http://www.cydiasubstrate.com/id/38be592b-bda7-4dd2-b049-cec44ef7a73bSDK下载地址：http://asdk.cydiasubstrate.com/zips/cydia_substrate-r2.zip具体代码如下。//指明要hook的lib ：MSConfig(MSFilterLibrary,”/system/lib/libdvm.so”) // 在初始化的时候进行hookMSInitialize { LOGD(“Cydia Init”); MSImageRef image; //载入lib image = MSGetImageByName(“/system/lib/libdvm.so”); if (image != NULL) { LOGD(“image is not null”); void dexload=MSFindSymbol(image,”dvmResolveClass”); if(dexload != NULL) { LOGD(“dexloadis not null”); MSHookFunction(dexload, (void)proxyDvmResolveClass, (void*)&amp;dvmResolveClass_Proxy); } else{ LOGD(“errorfind dvmResolveClass”); } }}// 在初始化的时候进行hook//保留原来的地址ClassObject (dvmResolveClass_Proxy)(ClassObject referrer, u4 classIdx, boolfromUnverifiedConstant);// 新方法地址static ClassObject proxyDvmResolveClass(ClassObject referrer, u4 classIdx,bool fromUnverifiedConstant) { return dvmResolveClass_Proxy(referrer, classIdx,true);}有人可能会担心cydia Hook性能，稳定性问题，但是据我所知，目前有些公司已经用它来实现apk加壳和脱壳防止反编译技术方案。具体可以参考http://www.gitzx.com/android-cydiasubstrate/ 说到此处，似乎已经是一个完整的方案了，但在实践中，会发现运行加载类的时候报preverified错误，原来在DexPrepare.cpp，将dex转化成odex的过程中，会在DexVerify.cpp进行校验，验证如果直接引用到的类和clazz是否在同一个dex，如果是，则会打上CLASS_ISPREVERIFIED标志。通过在所有类（Application除外，当时还没加载自定义类的代码）的构造函数插入一个对在单独的dex的类的引用，就可以解决这个问题。空间使用了javaassist进行编译时字节码插入。 所以为了实现补丁方案，所以必须从这些方法中入手，防止类被打上CLASS_ISPREVERIFIED标志。 最终空间的方案是往所有类的构造函数里面插入了一段代码，代码如下： 123if (ClassVerifier.PREVENT_VERIFY) &#123; System.out.println(AntilazyLoad.class);&#125; 其中AntilazyLoad类会被打包成单独的antilazy.dex，这样当安装apk的时候，classes.dex内的类都会引用一个在不相同dex中的AntilazyLoad类，这样就防止了类被打上CLASS_ISPREVERIFIED的标志了，只要没被打上这个标志的类都可以进行打补丁操作。 然后在应用启动的时候加载进来.AntilazyLoad类所在的dex包必须被先加载进来,不然AntilazyLoad类会被标记为不存在，即使后续加载了hack.dex包，那么他也是不存在的，这样屏幕就会出现茫茫多的类AntilazyLoad找不到的log。 所以Application作为应用的入口不能插入这段代码。（因为载入hack.dex的代码是在Application中onCreate中执行的，如果在Application的构造函数里面插入了这段代码，那么就是在hack.dex加载之前就使用该类，该类一次找不到，会被永远的打上找不到的标志) 如何打包补丁包：１. 空间在正式版本发布的时候，会生成一份缓存文件，里面记录了所有class文件的md5，还有一份mapping混淆文件。２. 在后续的版本中使用-applymapping选项，应用正式版本的mapping文件，然后计算编译完成后的class文件的md5和正式版本进行比较，把不相同的class文件打包成补丁包。备注:该方案现在也应用到我们的编译过程当中,编译不需要重新打包dex,只需要把修改过的类的class文件打包成patch dex,然后放到sdcard下,那么就会让改变的代码生效。 在 Java 中，只有当两个实例的类名、包名以及加载其的 ClassLoader 都相同，才会被认为是同一种类型。上面分别加载的新类和旧类，虽然包名和类名都完全一样，但是由于加载的 ClassLoader 不同，所以并不是同一种类型，在实际使用中可能会出现类型不符异常。同一个 Class = 相同的 ClassName + PackageName + ClassLoader以上问题在采用动态加载功能的开发中容易出现，请注意。 通过上面的分析，我们知道使用ClassLoader动态加载一个外部的类是非常容易的事情，所以很容易就能实现动态加载新的可执行代码的功能，但是比起一般的Java程序，在Android程序中使用动态加载主要有两个麻烦的问题： Android中许多组件类（如Activity、Service等）是需要在Manifest文件里面注册后才能工作的（系统会检查该组件有没有注册），所以即使动态加载了一个新的组件类进来，没有注册的话还是无法工作；Res资源是Android开发中经常用到的，而Android是把这些资源用对应的R.id注册好，运行时通过这些ID从Resource实例中获取对应的资源。如果是运行时动态加载进来的新类，那类里面用到R.id的地方将会抛出找不到资源或者用错资源的异常，因为新类的资源ID根本和现有的Resource实例中保存的资源ID对不上；说到底，抛开虚拟机的差别不说，一个Android程序和标准的Java程序最大的区别就在于他们的上下文环境（Context）不同。Android中，这个环境可以给程序提供组件需要用到的功能，也可以提供一些主题、Res等资源，其实上面说到的两个问题都可以统一说是这个环境的问题，而现在的各种Android动态加载框架中，核心要解决的东西也正是“如何给外部的新类提供上下文环境”的问题。 DexClassLoader的使用方法一般有两种：从已安装的apk中读取dex从apk文件中读取dex假如有两个APK，一个是宿主APK，叫作HOST，一个是插件APK，叫作Plugin。Plugin中有一个类叫PluginClass，代码如下：123456789public class PluginClass &#123; public PluginClass() &#123; Log.d(\"JG\",\"初始化PluginClass\"); &#125; public int function(int a, int b)&#123; return a+b; &#125; &#125; 现在如果想调用插件APK中PluginClass内的方法，应该怎么办？ ####从已安装的apk中读取dex 先来看第一种方法，这种方法必须建一个Activity，在清单文件中配置Action.12345&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.maplejaw.plugin\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 然后在宿主APK中如下使用:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 这种方式用于从已安装的apk中读取，必须要有一个activity，且需要配置ACTION */private void useDexClassLoader()&#123; //创建一个意图，用来找到指定的apk Intent intent = new Intent(\"com.maplejaw.plugin\"); //获得包管理器 PackageManager pm = getPackageManager(); List&lt;ResolveInfo&gt; resolveinfoes = pm.queryIntentActivities(intent, 0); if(resolveinfoes.size()==0)&#123; return; &#125; //获得指定的activity的信息 ActivityInfo actInfo = resolveinfoes.get(0).activityInfo; //获得包名 String packageName = actInfo.packageName; //获得apk的目录或者jar的目录 String apkPath = actInfo.applicationInfo.sourceDir; //dex解压后的目录,注意，这个用宿主程序的目录，android中只允许程序读取写自己 //目录下的文件 String dexOutputDir = getApplicationInfo().dataDir; //native代码的目录 String libPath = actInfo.applicationInfo.nativeLibraryDir; //创建类加载器，把dex加载到虚拟机中 DexClassLoader calssLoader = new DexClassLoader(apkPath, dexOutputDir, libPath, this.getClass().getClassLoader()); //利用反射调用插件包内的类的方法 try &#123; Class&lt;?&gt; clazz = calssLoader.loadClass(packageName+\".PluginClass\"); Object obj = clazz.newInstance(); Class[] param = new Class[2]; param[0] = Integer.TYPE; param[1] = Integer.TYPE; Method method = clazz.getMethod(\"function\", param); Integer ret = (Integer)method.invoke(obj, 12,34); Log.d(\"JG\", \"返回的调用结果为:\" + ret); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 我们安装完两个APK后，在宿主中就可以直接调用，调用示例如下。 123public void btnClick(View view)&#123; useDexClassLoader();&#125; ####从apk文件中读取dex 这种方法由于并不需要安装，所以不需要通过Intent从activity中解析信息。换言之，这种方法不需要创建Activity。无需配置清单文件。我们只需要打包一个apk，然后放到SD卡中即可。核心代码如下： 123456789101112131415161718192021222324252627282930//apk路径String path=Environment.getExternalStorageDirectory().getAbsolutePath()+\"/1.apk\";private void useDexClassLoader(String path)&#123; File codeDir=getDir(\"dex\", Context.MODE_PRIVATE); //创建类加载器，把dex加载到虚拟机中 DexClassLoader calssLoader = new DexClassLoader(path, codeDir.getAbsolutePath(), null, this.getClass().getClassLoader()); //利用反射调用插件包内的类的方法 try &#123; Class&lt;?&gt; clazz = calssLoader.loadClass(\"com.maplejaw.plugin.PluginClass\"); Object obj = clazz.newInstance(); Class[] param = new Class[2]; param[0] = Integer.TYPE; param[1] = Integer.TYPE; Method method = clazz.getMethod(\"function\", param); Integer ret = (Integer)method.invoke(obj, 12,21); Log.d(\"JG\", \"返回的调用结果为: \" + ret); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 动态加载的几个关键问题资源访问：无法找到某某id所对应的资源因为将apk加载到宿主程序中去执行，就无法通过宿主程序的Context去取到apk中的资源,比如图片、文本等，这是很好理解的，因为apk已经不存在上下文了，它执行时所采用的上下文是宿主程序的上下文，用别人的Context是无法得到自己的资源的；解决方案一：插件中的资源在宿主程序中也预置一份；缺点：增加了宿主apk的大小；在这种模式下，每次发布一个插件都需要将资源复制到宿主程序中，这意味着每发布一个插件都要更新一下宿主程序；解决方案二：将插件中的资源解压出来，然后通过文件流去读取资源；缺点：实际操作起来还是有很大难度的。首先不同资源有不同的文件流格式，比如图片、XML等，其次针对不同设备加载的资源可能是不一样的，如何选择合适的资源也是一个需要解决的问题；实际解决方案：Activity中有一个叫mBase的成员变量，它的类型就是ContextImpl。注意到Context中有如下两个抽象方法，看起来是和资源有关的，实际上Context就是通过它们来获取资源的。这两个抽象方法的真正实现在ContextImpl中； 12345/** Return an AssetManager instance for your application's package. */ public abstract AssetManager getAssets(); /** Return a Resources instance for your application's package. */ public abstract Resources getResources(); 具体实现:123456789101112131415protected void loadResources() &#123; try &#123; AssetManager assetManager = AssetManager.class.newInstance(); Method addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class); addAssetPath.invoke(assetManager, mDexPath); mAssetManager = assetManager; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Resources superRes = super.getResources(); mResources = new Resources(mAssetManager, superRes.getDisplayMetrics(), superRes.getConfiguration()); mTheme = mResources.newTheme(); mTheme.setTo(super.getTheme());&#125; 加载资源的方法是通过反射，通过调用AssetManager中的addAssetPath方法，我们可以将一个apk中的资源加载到Resources对象中，由于addAssetPath是隐藏API我们无法直接调用，所以只能通过反射。addAssetPath(); 1234567891011121314@hide public final int addAssetPath(String path) &#123; synchronized (this) &#123; int res = addAssetPathNative(path); makeStringBlocks(mStringBlocks); return res; &#125;&#125; Activity生命周期的管理：反射方式和接口方式。反射的方式很好理解，首先通过Java的反射去获取Activity的各种生命周期方法，比如onCreate、onStart、onResume等，然后在代理Activity中去调用插件Activity对应的生命周期方法即可；缺点：一方面是反射代码写起来比较复杂，另一方面是过多使用反射会有一定的性能开销。 反射方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overrideprotected void onResume() &#123; super.onResume(); Method onResume = mActivityLifecircleMethods.get(\"onResume\"); if (onResume != null) &#123; try &#123; onResume.invoke(mRemoteActivity, new Object[] &#123; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;@Overrideprotected void onPause() &#123; Method onPause = mActivityLifecircleMethods.get(\"onPause\"); if (onPause != null) &#123; try &#123; onPause.invoke(mRemoteActivity, new Object[] &#123; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; super.onPause();&#125; 接口方式 1234567891011121314151617181920212223242526272829303132333435363738394041public interface DLPlugin &#123; public void onStart(); public void onRestart(); public void onActivityResult(int requestCode, int resultCode, Intent data); public void onResume(); public void onPause(); public void onStop(); public void onDestroy(); public void onCreate(Bundle savedInstanceState); public void setProxy(Activity proxyActivity, String dexPath); public void onSaveInstanceState(Bundle outState); public void onNewIntent(Intent intent); public void onRestoreInstanceState(Bundle savedInstanceState); public boolean onTouchEvent(MotionEvent event); public boolean onKeyUp(int keyCode, KeyEvent event); public void onWindowAttributesChanged(LayoutParams params); public void onWindowFocusChanged(boolean hasFocus); public void onBackPressed();…&#125; 代理Activity中只需要按如下方式即可调用插件Activity的生命周期方法，这就完成了插件Activity的生命周期的管理;插件Activity需要实现DLPlugin接口；12345678910111213141516171819202122232425262728293031@Overrideprotected void onStart() &#123; mRemoteActivity.onStart(); super.onStart();&#125;@Overrideprotected void onRestart() &#123; mRemoteActivity.onRestart(); super.onRestart();&#125;@Overrideprotected void onResume() &#123; mRemoteActivity.onResume(); super.onResume();&#125; Google Instant app 微信热补丁实现 多dex分拆 QQ空间热修复方案 Android dex分包方案 类加载器DexClassLoader 基于cydia Hook在线热修复补丁方案 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"视频解码之软解与硬解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/视频解码之软解与硬解/","text":"视频解码之软解与硬解硬解：从字面意思上理解就是用硬件来进行解码，通过显卡的视频加速功能对高清视频进行解码，很明显就是一个专门的电路板(这样好理解…)来进行视频的解码，是依靠显卡GPU的。 软解：字面上理解就是用软件进行解码，这样理解也对，但是实际最总还是要硬件来支持的，这个硬件就是CPU。 既然有这两种不同的解码方式，我们在开发中该如何进行选择？哪个更好？ 硬解优缺点： 显卡核心GPU拥有独特的计算方法，解码效率非常高，而且充当解码核心的模块成本并不高。这样不但能够减轻CPU的负担，还有着低功耗、发热少等特点。但是由于硬解码起步比较晚， 软件和驱动对其的支持度低。硬解码内置有什么样的模块就能够解码什么样的视频，面对网络上杂乱无章的视频编码格式，不可能做到完全兼容同。此外，硬解码的滤镜、字母、画质增强方面都做的十分不足。 优点：低功耗、发热少、效率高。 缺点：视频兼容性差、支持度低。 软解优缺点： 软解码技术的解码过程中，需要对大量的视频信息进行运算，对CPU性能的要求非常高。尤其是对高清晰度大码率的视频来说，巨大的运算量就会造成转换效率低、发热量大等问题。 但是由于软解码的过程中不需要复杂的硬件支持，兼容性非常高。即使是新出的视频编码格式，只要安装好相应的解码器文件，就能顺利播放。而且软解码拥有丰富的滤镜、字幕、画面处理优化等效果， 如果CPU足够强悍的话，能够实现更加出色的画面效果。 优点： 兼容强、全解码、效果好 缺点： 对CPU要求高、效率低、发热大 关于软解与硬解究竟哪个更好的问题一直是争论的热点，其实我倒是感觉没有好坏之分，各自有各自的优缺点和使用条件，根据需要去选择才是最合适的。播放码率比较大的视频，硬解可能流畅的播放，但是软解可能会出现演示、画面和声音卡顿不同步的问题。但是硬解播放出的视频大多都不允许在解码之后进行软件后处理，比如进行一些降噪锐化之类的后期滤镜，这样可能会让人感觉画质不太好的。当然上面的这种情况也是和CPU及GPU能力的不同而不同的。 总的来说，还是各有春秋，适合你的才是最好的。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"自定义View详解","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/自定义View详解/","text":"自定义View详解虽然之前也分析过View回执过程，但是如果让我自己集成ViewGroup然后自己重新onMeasure,onLayout,onDraw方法自定义View我还是会头疼。今天索性来系统的学习下。 ###onMeasure 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * &lt;p&gt; * Measure the view and its content to determine the measured width and the * measured height. This method is invoked by &#123;@link #measure(int, int)&#125; and * should be overridden by subclasses to provide accurate and efficient * measurement of their contents. * &lt;/p&gt; * * &lt;p&gt; * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you * &lt;em&gt;must&lt;/em&gt; call &#123;@link #setMeasuredDimension(int, int)&#125; to store the * measured width and height of this view. Failure to do so will trigger an * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by * &#123;@link #measure(int, int)&#125;. Calling the superclass' * &#123;@link #onMeasure(int, int)&#125; is a valid use. * &lt;/p&gt; * * &lt;p&gt; * The base class implementation of measure defaults to the background size, * unless a larger size is allowed by the MeasureSpec. Subclasses should * override &#123;@link #onMeasure(int, int)&#125; to provide better measurements of * their content. * &lt;/p&gt; * * &lt;p&gt; * If this method is overridden, it is the subclass's responsibility to make * sure the measured height and width are at least the view's minimum height * and width (&#123;@link #getSuggestedMinimumHeight()&#125; and * &#123;@link #getSuggestedMinimumWidth()&#125;). * &lt;/p&gt; * * @param widthMeasureSpec horizontal space requirements as imposed by the parent. * The requirements are encoded with * &#123;@link android.view.View.MeasureSpec&#125;. * @param heightMeasureSpec vertical space requirements as imposed by the parent. * The requirements are encoded with * &#123;@link android.view.View.MeasureSpec&#125;. * * @see #getMeasuredWidth() * @see #getMeasuredHeight() * @see #setMeasuredDimension(int, int) * @see #getSuggestedMinimumHeight() * @see #getSuggestedMinimumWidth() * @see android.view.View.MeasureSpec#getMode(int) * @see android.view.View.MeasureSpec#getSize(int) */protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 注释说的非常清楚。但是我还是要强调一下这两个参数:widthMeasureSpec和heightMeasureSpec这两个int类型的参数，看名字应该知道是跟宽和高有关系，但它们其实不是宽和高，而是由宽、高和各自方向上对应的模式来合成的一个值：其中，在int类型的32位二进制位中，31-30这两位表示模式，0~29这三十位表示宽和高的实际值.其中模式一共有三种，被定义在Android中的View类的一个内部类中：View.MeasureSpec： 1234567891011android.viewpublic static class View.MeasureSpecextends ObjectA MeasureSpec encapsulates the layout requirements passed from parent to child. Each MeasureSpec represents a requirement for either the width or the height. A MeasureSpec is comprised of a size and a mode. There are three possible modes:UNSPECIFIEDThe parent has not imposed any constraint on the child. It can be whatever size it wants.EXACTLYThe parent has determined an exact size for the child. The child is going to be given those bounds regardless of how big it wants to be.AT_MOSTThe child can be as large as it wants up to the specified size.MeasureSpecs are implemented as ints to reduce object allocation. This class is provided to pack and unpack the &lt;size, mode&gt; tuple into the int. MeasureSpec.UNSPECIFIED The parent has not imposed any constraint on the child. It can be whatever size it wants. 这种情况比较少，一般用不到。标示父控件没有给子View任何显示- - - -对应的二进制表示: 00 MeasureSpec.EXACTLY The parent has determined an exact size for the child. The child is going to be given those bounds regardless of how big it wants to be.理解成MATCH_PARENT或者在布局中指定了宽高值，如layout:width=’50dp’. - - - - 对应的二进制表示:01 MeasureSpec.AT_MOST The child can be as large as it wants up to the specified size.理解成WRAP_CONTENT,这是的值是父View可以允许的最大的值，只要不超过这个值都可以。- - - - 对应的二进制表示:10 那具体MeasureSpec是怎么把宽和高的实际值以及模式组合起来变成一个int类型的值呢？ 这部分是在MeasureSpce.makeMeasureSpec()方法中处理的:1234567public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; 那我们如何从MeasureSpec值中提取模式和大小呢？该方法内部是采用位移计算.123456789101112131415161718192021/** * Extracts the mode from the supplied measure specification. * * @param measureSpec the measure specification to extract the mode from * @return &#123;@link android.view.View.MeasureSpec#UNSPECIFIED&#125;, * &#123;@link android.view.View.MeasureSpec#AT_MOST&#125; or * &#123;@link android.view.View.MeasureSpec#EXACTLY&#125; */public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK);&#125;/** * Extracts the size from the supplied measure specification. * * @param measureSpec the measure specification to extract the size from * @return the size in pixels defined in the supplied measure specification */public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK);&#125; ###onLayout 为了能合理的去绘制定义View,你需要制定它的大小。复杂的自定义View通常需要根据屏幕的样式和大小来进行复杂的布局计算。你不应该假设你的屏幕上的View的大小。即使只有一个应用使用你的自定义View，也需要处理不同的屏幕尺寸、屏幕密度和横屏以及竖屏下的多种比率等。 虽然View有很多处理测量的方法，但他们中的大部分都不需要被重写。如果你的View不需要特别的控制它的大小，你只需要重写一个方法:onSizeChanged()。 onSizeChanged()方法会在你的View第一次指定大小后调用，在因某些原因改变大小后会再次调用。在上面PieChart的例子中，onSizeChanged()方法就是它需要重新计算表格样式和大小以及其他元素的地方。下面就是PieChart.onSizeChanged()方法的内容: 123456789101112// Account for paddingfloat xpad = (float)(getPaddingLeft() + getPaddingRight());float ypad = (float)(getPaddingTop() + getPaddingBottom());// Account for the labelif (mShowText) xpad += mTextWidth;float ww = (float)w - xpad;float hh = (float)h - ypad;// Figure out how big we can make the pie.float diameter = Math.min(ww, hh); ###onDraw 自定义View最重要的就是展现样式。 #####重写onDraw()方法 绘制自定义View最重要的步骤就是重写onDraw()方法。onDraw()方法的参数是Canvas对象。可以用它来绘制自身。Canvas类定义了绘制文字、线、位图和很多其他图形的方法。你可以在onDraw()方法中使用这些方法来指定UI. 在使用任何绘制方法之前，你都必须要创建一个Paint对象。 #####创建绘制的对象 android.graphics框架将绘制分为两步: 绘制什么，由Canvas处理。 怎么去绘制，由Paint处理。 #####Canvas The Canvas class holds the “draw” calls. To draw something, you need 4 basic components: A Bitmap to hold the pixels, a Canvas to host the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect, Path, text, Bitmap),and a paint (to describe the colors and styles for the drawing). Canvas():创建一个空的画布，可以使用setBitmap()方法来设置绘制的具体画布； Canvas(Bitmap bitmap):以bitmap对象创建一个画布，则将内容都绘制在bitmap上，bitmap不得为null; canvas.drawRect(RectF,Paint)方法用于画矩形，第一个参数为图形显示区域，第二个参数为画笔，设置好图形显示区域Rect和画笔Paint后，即可画图； canvas.drawRoundRect(RectF, float, float, Paint)方法用于画圆角矩形，第一个参数为图形显示区域，第二个参数和第三个参数分别是水平圆角半径和垂直圆角半径。 canvas.drawLine(startX, startY, stopX, stopY, paint)：前四个参数的类型均为float，最后一个参数类型为Paint。表示用画笔paint从点（startX,startY）到点（stopX,stopY）画一条直线； canvas.drawLines (float[] pts, Paint paint)``pts:是点的集合，大家下面可以看到，这里不是形成连接线，而是每两个点形成一条直线，pts的组织方式为｛x1,y1,x2,y2,x3,y3,……｝，例如float []pts={10,10,100,100,200,200,400,400};就是有四个点：（10，10）、（100，100），（200，200），（400，400）），两两连成一条直线； canvas.drawArc(oval, startAngle, sweepAngle, useCenter, paint)：第一个参数oval为RectF类型，即圆弧显示区域，startAngle和sweepAngle均为float类型，分别表示圆弧起始角度和圆弧度数,3点钟方向为0度，useCenter设置是否显示圆心，boolean类型，paint为画笔； canvas.drawCircle(float,float, float, Paint)方法用于画圆，前两个参数代表圆心坐标，第三个参数为圆半径，第四个参数是画笔； canvas.drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) 位图，参数一就是我们常规的Bitmap对象，参数二是源区域(这里是bitmap)，参数三是目标区域(应该在canvas的位置和大小)，参数四是Paint画刷对象，因为用到了缩放和拉伸的可能，当原始Rect不等于目标Rect时性能将会有大幅损失。 canvas.drawText(String text, float x, floaty, Paint paint)渲染文本，Canvas类除了上面的还可以描绘文字，参数一是String类型的文本，参数二x轴，参数三y轴，参数四是Paint对象。 canvas.drawPath (Path path, Paint paint)，根据Path去画. 1234567Path path = new Path(); path.moveTo(10, 10); //设定起始点 path.lineTo(10, 100);//第一条直线的终点，也是第二条直线的起点 path.lineTo(300, 100);//画第二条直线 path.lineTo(500, 100);//第三条直线 path.close();//闭环 canvas.drawPath(path, paint); #####Paint setARGB(int a, int r, int g, int b) 设置Paint对象颜色，参数一为alpha透明值 setAlpha(int a) 设置alpha不透明度，范围为0~255 setAntiAlias(boolean aa)是否抗锯齿 setColor(int color)设置颜色 setTextScaleX(float scaleX)设置文本缩放倍数，1.0f为原始 setTextSize(float textSize)设置字体大小 setUnderlineText(String underlineText)设置下划线 例如，Canvas提供了一个画一条线的方法，而Paint提供了指定这条线的颜色的方法。Canvas提供了绘制长方形的方法，而Paint提供了是用颜色填充整个长方形还是空着的方法。简单的说，Canvas指定了你想在屏幕上绘制的形状，而Paint指定了你要绘制的形状的颜色、样式、字体和样式等等。 所以，在你draw任何东西之前，你都需要创建一个或者多个Paint对象。下面的PieChart例子就是在构造函数中调用的init方法: 123456789101112131415161718private void init() &#123; mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mTextPaint.setColor(mTextColor); if (mTextHeight == 0) &#123; mTextHeight = mTextPaint.getTextSize(); &#125; else &#123; mTextPaint.setTextSize(mTextHeight); &#125; mPiePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPiePaint.setStyle(Paint.Style.FILL); mPiePaint.setTextSize(mTextHeight); mShadowPaint = new Paint(0); mShadowPaint.setColor(0xff101010); mShadowPaint.setMaskFilter(new BlurMaskFilter(8, BlurMaskFilter.Blur.NORMAL)); ... 下面是PieChart完整的onDraw()方法:1234567891011121314151617181920212223242526protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // Draw the shadow canvas.drawOval( mShadowBounds, mShadowPaint ); // Draw the label text canvas.drawText(mData.get(mCurrentItem).mLabel, mTextX, mTextY, mTextPaint); // Draw the pie slices for (int i = 0; i &lt; mData.size(); ++i) &#123; Item it = mData.get(i); mPiePaint.setShader(it.mShader); canvas.drawArc(mBounds, 360 - it.mEndAngle, it.mEndAngle - it.mStartAngle, true, mPiePaint); &#125; // Draw the pointer canvas.drawLine(mTextX, mPointerY, mPointerX, mPointerY, mTextPaint); canvas.drawCircle(mPointerX, mPointerY, mPointerSize, mTextPaint);&#125; 下面是一张View绘制过程中框架调用的一些标准方法概要图: 下面来几个例子: 自定义开关: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ToogleView extends View &#123; private int mSlideMarginLeft = 0; private Bitmap backgroundBitmap; private Bitmap slideButton; public ToogleView(Context context) &#123; super(context); init(context); &#125; public ToogleView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public ToogleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; backgroundBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.toogle_bg); slideButton = BitmapFactory.decodeResource(getResources(), R.drawable.toogle_slide); this.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mSlideMarginLeft == 0) &#123; mSlideMarginLeft = backgroundBitmap.getWidth() - slideButton.getWidth(); &#125; else &#123; mSlideMarginLeft = 0; &#125; invalidate(); &#125; &#125;); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Paint paint = new Paint(); paint.setAntiAlias(true); // 先画背景图 canvas.drawBitmap(backgroundBitmap, 0, 0, paint); // 再画滑块，用mSlideMarginLeft来控制滑块距离左边的距离。 canvas.drawBitmap(slideButton, mSlideMarginLeft, 0, paint); &#125; 1234567891011&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt;&lt;com.charon.recyclerviewdemo.ToogleView android:paddingLeft=\"50dp\" android:background=\"@android:color/holo_green_light\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;/LinearLayout&gt; 很明显显示的不对，因为高设置为warp_content了，但是界面显示的确实整个屏幕，而且paddingLeft也没生效，那该怎么做呢？ 当然是重写onMeasure() 方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class ToogleView extends View &#123; private int mSlideMarginLeft = 0; private Bitmap backgroundBitmap; private Bitmap slideButton; public ToogleView(Context context) &#123; super(context); init(context); &#125; public ToogleView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public ToogleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; backgroundBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.toogle_bg); slideButton = BitmapFactory.decodeResource(getResources(), R.drawable.toogle_slide); this.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mSlideMarginLeft == 0) &#123; mSlideMarginLeft = backgroundBitmap.getWidth() - slideButton.getWidth(); &#125; else &#123; mSlideMarginLeft = 0; &#125; invalidate(); &#125; &#125;); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width; int height; if (MeasureSpec.EXACTLY == measureWidthMode) &#123; width = measureWidth; &#125; else &#123; width = backgroundBitmap.getWidth(); &#125; if (MeasureSpec.EXACTLY == measureHeightMode) &#123; height = measureHeight; &#125; else &#123; height = backgroundBitmap.getHeight(); &#125; setMeasuredDimension(width, height); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Paint paint = new Paint(); paint.setAntiAlias(true); canvas.drawBitmap(backgroundBitmap, getPaddingLeft(), 0, paint); canvas.drawBitmap(slideButton, mSlideMarginLeft + getPaddingLeft(), 0, paint); &#125;&#125; 这样就可以了。简单的说明一下，就是如果当前的模式是EXACTLY那就把父View传递进来的宽高设置进来，如果是AT_MOST或者UNSPECIFIED的话就使用背景图片的宽高。 最后再来一个自定义ViewGroup的例子: 之前的引导页面都是通过类似ViewPager这种方法左右滑动，现在想让他上下滑动，该怎么弄呢？1234567891011121314151617public class VerticalLayout extends ViewGroup &#123; public VerticalLayout(Context context) &#123; super(context); &#125; public VerticalLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public VerticalLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; &#125;&#125; 继承ViewGroup必须要重写onLayout方法。其实这也很好理解，因为每个ViewGroup的排列方式不一样，所以让子类来自己实现是最好的。当然畜类重写onLayout之外，也要重写onMeasure。代码如下，滑动手势处理的部分就不贴了。12345678910111213141516171819202122@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int measureSpec = MeasureSpec.makeMeasureSpec(mScreenHeight * getChildCount(), MeasureSpec.getMode(heightMeasureSpec)); super.onMeasure(widthMeasureSpec, measureSpec); measureChildren(widthMeasureSpec, heightMeasureSpec);&#125;@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; // 就像猴子捞月一样，让他们一个个的从上往下排就好了 if (changed) &#123; int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); if (child.getVisibility() != View.GONE) &#123; child.layout(l, i * mScreenHeight, r, (i + 1) * mScreenHeight); &#125; &#125; &#125;&#125; 上面介绍了通过继承View以及ViewGroup的方式来自定义View，平时开发过程中有时不需要继承他俩，我们直接继承功能接近的类进行扩展就好，例如:我想自定义一个Meterial Design样式的EditText。那我们该怎么实现呢？ 当然是继承EditText了，它比EditText多了一条底下的线，那我们给它draw上就可以了。 12345678910111213141516171819202122232425public class MetrailEditText extends EditText &#123; private NinePatchDrawable mDrawable; public MetrailEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public MetrailEditText(Context context) &#123; super(context); init(); &#125; private void init() &#123; setBackgroundResource(0); mDrawable = (NinePatchDrawable) getResources().getDrawable(R.drawable.edittext_meterial_bg_activated); &#125; @Override protected void onDraw(final Canvas canvas) &#123; super.onDraw(canvas); mDrawable.setBounds(-getCompoundPaddingLeft(), 0, getWidth() + getCompoundPaddingRight(), getHeight()); mDrawable.draw(canvas); &#125;&#125; 看到这里你可能会糊涂，这哪行啊？ 我们的edittext_meterial_bg_activated可不是普通的图，当然是9 patch图了。 当然你可以在onDraw()的时候加一个自定义线的颜色mDrawable.setColorFilter(mLineColor, PorterDuff.Mode.SRC_ATOP);等。 参考部分: http://blog.csdn.net/cyp331203/article/details/40736027 邮箱 ：itgoyo@gmail.com Good Luck! I","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"通过Hardware Layer提高动画性能","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/通过Hardware Layer提高动画性能/","text":"通过Hardware Layer提高动画性能项目中越来越多的动画，越来越多的效果导致了应用性能越来越低。该如何提升。 ###简介 在View播放动画的过程中每一帧都需要被重绘。如果使用view layers，就不用每帧都去重绘，因为View渲染一旦离开屏幕缓冲区就可以被重用。 而且，hardware layers会在GPU上缓存，这样就会让一些动画过程中的操作变得更快。通过hardware layers可以快速的渲染一些简单的转变(位移、选中、缩放、颜色渐变)。由于很多动画都是这些动作的结合，所以hardware layers可以显著的提高动画性能。 在View当中提供了三种类型的Layer type: LAYER_TYPE_HARDWARE Indicates that the view has a hardware layer. A hardware layer is backed by a hardware specific texture (generally Frame Buffer Objects or FBO on OpenGL hardware) and causes the view to be rendered using Android’s hardware rendering pipeline, but only if hardware acceleration is turned on for the view hierarchy. When hardware acceleration is turned off, hardware layers behave exactly as software layers. A hardware layer is useful to apply a specific color filter and/or blending mode and/or translucency to a view and all its children. A hardware layer can be used to cache a complex view tree into a texture and reduce the complexity of drawing operations. For instance, when animating a complex view tree with a translation, a hardware layer can be used to render the view tree only once. A hardware layer can also be used to increase the rendering quality when rotation transformations are applied on a view. It can also be used to prevent potential clipping issues when applying 3D transforms on a view. LAYER_TYPE_SOFTWARE Indicates that the view has a software layer. A software layer is backed by a bitmap and causes the view to be rendered using Android’s software rendering pipeline, even if hardware acceleration is enabled. Software layers have various usages: When the application is not using hardware acceleration, a software layer is useful to apply a specific color filter and/or blending mode and/or translucency to a view and all its children. When the application is using hardware acceleration, a software layer is useful to render drawing primitives not supported by the hardware accelerated pipeline. It can also be used to cache a complex view tree into a texture and reduce the complexity of drawing operations. For instance, when animating a complex view tree with a translation, a software layer can be used to render the view tree only once. Software layers should be avoided when the affected view tree updates often. Every update will require to re-render the software layer, which can potentially be slow (particularly when hardware acceleration is turned on since the layer will have to be uploaded into a hardware texture after every update.) LAYER_TYPE_NONE Indicates that the view does not have a layer. 默认值。 使用首先使用的前提是在清单文件中开启了硬件加速。否则将无法使用hardware layer。这一点在上面的文档中也有说明。 API也是非常简单的，直接使用View.setLayerType()就好。使用时应该只是暂时的设置Hardware Layer，因为它们无法自动释放。基本的使用步骤： 对每个想要在动画过程中进行缓存的view调用View.setLayerType(View.LAYER_TYPE_HARDWARE, null)方法。 执行动画。 在动画执行结束后调用View.setLayerType(View.LAYER_TYPE_NONE, null)方法来进行清除。 示例:12345678910mView.setLayerType(View.LAYER_TYPE_HARDWARE, null);animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; mView.setLayerType(View.LAYER_TYPE_NONE, null); &#125;&#125;);animator.start(); 但是如果在4.0.x的版本中使用上面的代码会本亏，必须要把setLayerType放到Runnable中。如下:12345678910111213141516mView.setLayerType(View.LAYER_TYPE_HARDWARE, null);animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; //This will work successfully post(new Runnable() &#123; @Override public void run () &#123; setLayerType(LAYER_TYPE_NONE, null); &#125; &#125; &#125;&#125;);animator.start(); 如果你基于minSdkVersion 16以上并且使用ViewPropertyAnimator时，你可以使用withLayer()方法替代如上的操作: 1mView.animate().translationX(150).withLayer().start(); 或者在api 14以上时使用ViewCompat.animate().withLayer()这样做，你的动画就会变得更流畅！ ###注意事项 你应该知道，事情没那么简单。Hardware layers有着惊人的提升动画性能的能力。然而，如果滥用，它的危害更大。不要盲目的使用layers 首先，在有些情况下，hardware layers除了view渲染外还会执行更多的工作。缓存layer将会需要时间，因为首选第一步就需要两个过程: 先将这些view渲染到GPU的一个layer中然后GPU再渲染该layer到Window上。如果要渲染的View非常简单(例如一个纯色值),那么这样在初始化的时候就会增加Hardware Layer不必要的开销。 其次，对所有的缓存来讲，都有一个缓存失效的可能性。任何时候如果在动画过程中调用view.invalidate()，那么layer就必须要重新渲染。经常的废弃hardware layers会比没有layers的情况下更糟糕，因为如同上面讲到的hardware layers在设置缓存时会有额外的开销。如果你需要经常的重新缓存layer，那就会有极大的损害。 这个问题也是非常容易出现的，因为动画经常有多个移动的部分。假如现在有一个三个部分移动的动画: 1234Parent ViewGroup—-&gt; Child View1 (往左移动)—-&gt; Child View2 (往右移动)—-&gt; Child View3 (往上移动) 如果你只在父布局`ViewGroup`上设置一个`layer`，那就将经常的缓存失效，因为`ViewGroup`会随着子`View`不断地改变。然而对每个单独的子`Views`而言，他们只是在位移。这种情况下，最好是对每个子`View上`设置`Hardware Layer`（而不是在父布局上）。 ***再次重申，通常是对多个子`View上`适当的设置`Hardware Layer`，这样他们就不会在动画运行时失效。*** 在手机开发者选项中的*显示硬件层更新（Show hardware layers updates）*功能是追踪这个问题的开发利器。当`View`渲染`Hardware Layer`的时候闪烁绿色，它应该在动画开始的时候闪烁一次（也就是`Layer`渲染初始化的时候），然而，如果你的`View`在整个动画期间都是绿色，那就是遇到失效的问题了。 最后，hardware layers使用GPU内存，你当然不想出现内存泄漏的问题。所以你应该在必要的时候再去使用hardware layers，就想播放动画时。 这里也没有硬性规则。Android渲染系统是非常复杂的。就像所有性能问题一样，测试才是关键。通过使用“显示硬件层更新”开发者选项来确定layers是在帮你还是害你。 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"注解使用","date":"2014-12-31T17:11:00.000Z","path":"2015/01/01/注解使用/","text":"注解使用###简介 Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate. 更通俗的意思是为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。 Annotation其实是一种接口。通过反射来访问annotation信息。相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。Annotation是不会影响程序代码的执行，无论annotation怎么变化，代码都始终如一地执行。Java语言解释器在工作时会忽略这些annotation，因此在JVM中这些annotation是“不起作用”的，只能通过配套的工具才能对这些annontaion类型的信息进行访问和处理。 ###说明 Annotation的声明是通过关键字@interface。这个关键字会去继承Annotation接口。 Annotation的方法定义是独特的、受限制的。 Annotation类型的方法必须声明为无参数、无异常的。这些方法定义了Annotation的成员: 方法名代表成员变量名，而方法返回值代表了成员变量的类型。而且方法的返回值类型必须是基本数据类型、Class类型、String类型、枚举类型、Annotation类型或者由前面类型之一作为元素的一维数组。方法的后面可以使用default和一个默认的数值来声明成员变量的默认值，null不能作为成员变量的默认值，这与我们平时的使用有很大的区别。 注解如果只有一个默认属性，可直接用value()函数。一个属性也没有则表示该Annotation为Mark Annotation。 例如: 1234567891011121314public @interface UnitTest &#123; String value();&#125;``` 在使用时可以直接使用`@UnitTest(\"GCD\")`，`@UnitTest(\"GCD\"`实际上就是是 `@UnitTest(value=\"GCD)`的简单写法。 例如: ```java@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UseCase &#123; public int id(); public String description() default \"no description\";&#125; ###作用 Annotation一般作为一种辅助途径，应用在软件框架或者工具中。让这些工具类可以根据不同的Annotation注解信息来采取不同的处理过程或者改变相应程的行为。具有“让编译器进行编译检查的作用”。 具体可分为如下三类: 标记，用于告诉编译器一些信息 编译时动态处理，如动态生成代码 运行时动态处理，如得到注解信息 ###Annotation分类 #####标准的Annotaion 从jdk 1.5开始，自带了三种标准的annotation类型： Override 它是一种marker类型的Annotation，用来标注方法，说明被它标注的方法是重载了父类中的方法。如果我们使用了该注解到一个没有覆盖父类方法的方法时，编译器就会提示一个编译错误的警告。 Deprecated 它也是一种marker类型的Annotation。当方法或者变量使用该注解时，编译器就会提示该方法已经废弃。 SuppressWarnings 它不是marker类型的Annotation。用户告诉编译器不要再对该类、方法或者成员变量进行警告提示。 #####元Annotation 元Annotation是指用来定义Annotation的Annotation。 @Retention 保留时间，可为RetentionPolicy.SOURCE(源码时)、RetentionPolicy.CLASS(编译时)、RetentionPolicy.RUNTIME(运行时)，默认为CLASS。如果值为RetentionPolicy.SOURCE那大多都是Mark Annotation，例如:Override、Deprecated、Suppress Warnings。SOURCE表示仅存在于源码中，在class文件中不会包含。CLASS表示会在class文件中存在，但是运行时无法获取。RUNTIME表示会在class文件中存在，并且在运行时可以通过反射获取。 @Target 用来标记可进行修饰哪些元素，例如ElementType.TYPE、ElementType.METHOD、ElementType.CONSTRUCTOR、ElementType.FIELD、ElementType.PARAMETER等，如果未指定则默认为可修饰所有。 @Inherited 子类是否可以继承父类中的该注解。它所标注的Annotation将具有继承性。 例如: 123456java.lang.annotation.Inherited@Inheritedpublic @interface MyAnnotation &#123;&#125; 12@MyAnnotationpublic class MySuperClass &#123; ... &#125; 1public class MySubClass extends MySuperClass &#123; ... &#125; 在这个例子中`MySubClass`类继承了`@MyAnnotation`注解，因为`MySubClass`继承了`MySuperClass`类，而`MySuperClass`类使用了`@MyAnnotation`注解。 @Documented 是否会保存到javadoc文档中。 ###自定义Annotation 假设现在有个开发团队在每个类的开始都要提供一些信息，例如: 123456789101112public class Generation3List extends Generation2List &#123; // Author: John Doe // Date: 3/17/2002 // Current revision: 6 // Last modified: 4/12/2004 // By: Jane Doe // Reviewers: Alice, Bill, Cindy // class code goes here&#125; 我们可以声明一个注解来保存这些相同的元数据。如下: 123456789@interface ClassPreamble &#123; String author(); String date(); int currentRevision() default 1; String lastModified() default \"N/A\"; String lastModifiedBy() default \"N/A\"; // Note use of array String[] reviewers();&#125; 声明完注解之后我们就可以填写一些参数来使用它，如下: 1234567891011121314@ClassPreamble ( author = \"John Doe\", date = \"3/17/2002\", currentRevision = 6, lastModified = \"4/12/2004\", lastModifiedBy = \"Jane Doe\", // Note array notation reviewers = &#123;\"Alice\", \"Bob\", \"Cindy\"&#125;)public class Generation3List extends Generation2List &#123;// class code goes here&#125; ###Annotation解析 当Java源代码被编译时，编译器的一个插件annotation处理器则会处理这些annotation。处理器可以产生报告信息，或者创建附加的Java源文件或资源。如果annotation本身被加上了RententionPolicy的运行时类，则Java编译器则会将annotation的元数据存储到class文件中。然后Java虚拟机或其他的程序可以查找这些元数据并做相应的处理。 当然除了annotation处理器可以处理annotation外，我们也可以使用反射自己来处理annotation。Java SE 5有一个名为AnnotatedElement的接口，Java的反射对象类Class,Constructor,Field,Method以及Package都实现了这个接口。这个接口用来表示当前运行在Java虚拟机中的被加上了annotation的程序元素。通过这个接口可以使用反射读取annotation。AnnotatedElement接口可以访问被加上RUNTIME标记的annotation，相应的方法有getAnnotation,getAnnotations,isAnnotationPresent。由于Annotation类型被编译和存储在二进制文件中就像class一样，所以可以像查询普通的Java对象一样查询这些方法返回的Annotation。 #####运行时Annotation解析 该类是指@Retention为RUNTIME的Annotation。该类型的解析其实本质的使用反射。反射执行的效率是很低的如果不是必要，应当尽量减少反射的使用，因为它会大大拖累你应用的执行效率。 类注解 可以通过Class、Method、Field类来在运行时获取注解。下面是通过Class类获取注解的示例: 12345678910Class aClass = TheClass.class;Annotation[] annotations = aClass.getAnnotations();for(Annotation annotation : annotations)&#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"name: \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value()); &#125;&#125; 也可以获取一个指定的注解类型: 12345678Class aClass = TheClass.class;Annotation annotation = aClass.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"name: \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value());&#125; JDK提供的主要方法有: 1234567891011public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType) &#123; ...&#125;public Annotation[] getAnnotations() &#123; ...&#125;public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationType) &#123; ...&#125; 方法注解 下面是一个方法使用注解的例子: 1234public class TheClass &#123; @MyAnnotation(name=\"someName\", value = \"Hello World\") public void doSomething()&#123;&#125;&#125; 你可以通过如下方式获取方法注解: 12345678910Method method = ... //obtain method objectAnnotation[] annotations = method.getDeclaredAnnotations();for(Annotation annotation : annotations)&#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"name: \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value()); &#125;&#125; 也可以获取一个指定的方法注解，如下: 12345678Method method = ... // obtain method objectAnnotation annotation = method.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"name: \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value());&#125; 参数注解 在方法的参数中声明注解，如下: 12345public class TheClass &#123; public static void doSomethingElse( @MyAnnotation(name=\"aName\", value=\"aValue\") String parameter)&#123; &#125;&#125; 可以通过`Method`对象获取到参数的注解，如下: 1234567891011121314151617Method method = ... //obtain method objectAnnotation[][] parameterAnnotations = method.getParameterAnnotations();Class[] parameterTypes = method.getParameterTypes();int i=0;for(Annotation[] annotations : parameterAnnotations)&#123; Class parameterType = parameterTypes[i++]; for(Annotation annotation : annotations)&#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"param: \" + parameterType.getName()); System.out.println(\"name : \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value()); &#125; &#125;&#125; 注意，`Method.getParameterAnnotations()`方法会返回一个二维的`Annotation`数组，包含每个方法参数的一个注解数组。 变量注解 下面是一个变量使用注解的例子: 12345678910111213141516171819public class TheClass &#123; @MyAnnotation(name=\"someName\", value = \"Hello World\") public String myField = null;&#125;``` 你可以像下面这样获取变量的注解: ```javaField field = ... //obtain field objectAnnotation[] annotations = field.getDeclaredAnnotations();for(Annotation annotation : annotations)&#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"name: \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value()); &#125;&#125; 当然也可以获取一个指定的变量注解，如下: 12345678Field field = ... // obtain method objectAnnotation annotation = field.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"name: \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value());&#125; 记下来我们来举个栗子,运行时注解示例: 相信很多人都知道Butter Knife。它里面就是使用了注解:12345678@BindView(R.id.user) EditText username;@BindView(R.id.pass) EditText password;@BindString(R.string.login_error) String loginErrorMessage;@OnClick(R.id.submit) void submit() &#123; // TODO call server...&#125; 那我们就以onClick事件为例模仿着他去写一下。 12345678910111213141516171819202122232425262728public class InjectorProcessor &#123; public void process(final Object object) &#123; Class class_=object.getClass(); Method[] methods=class_.getDeclaredMethods(); for (final Method method : methods) &#123; onClick clickMethod=method.getAnnotation(onClick.class); if (clickMethod!=null) &#123; if (object instanceof Activity) &#123; for (int id : clickMethod.value()) &#123; View view=((Activity) object).findViewById(id); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; method.invoke(object); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; &#125; &#125; &#125;&#125; 使用: 1234567891011121314public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); InjectorProcessor processor=new InjectorProcessor(); processor.process(MainActivity.this); &#125; @onClick(&#123;R.id.textview&#125;) public void click() &#123; Toast.makeText(this, \"HHH\", Toast.LENGTH_SHORT).show(); &#125;&#125; 很显然大神JakeWharton不会这样做的，毕竟反射会影响性能。我们来看一下ButterKnife的源码:123456789101112131415@Target(METHOD)@Retention(CLASS)@ListenerClass( targetType = \"android.view.View\", setter = \"setOnClickListener\", type = \"butterknife.internal.DebouncingOnClickListener\", method = @ListenerMethod( name = \"doClick\", parameters = \"android.view.View\" ))public @interface OnClick &#123; /** View IDs to which the method will be bound. */ @IdRes int[] value() default &#123; View.NO_ID &#125;;&#125; 看到了吗？是编译型的注解。这样不会影响性能。 一张图总结一下: #####编译时Annotation解析 在刚才介绍的运行时注解中，很多人肯定会说使用反射会影响性能，那有没有不影响性能的方式呢？当然有了，那就是编译时注解。在编译时会通过注解标示来动态生成一些类或者xml，而在运行时，这里注解是没有的，它会依靠动态生成的类来进行操作。所以它就和直接调用方法一样，当然不会有效率影响了。 该类型注解值是@Retention为CLASS的Annotation，由APT(Annotaion Processing Tool)自动进行解析。是在编译时注入，所以不会像反射一样影响效率问题。 根据sun官方的解释，APT（annotation processing tool）是一个命令行工具，它对源代码文件进行检测找出其中的annotation后，使用annotation processors来处理annotation。而annotation processors使用了一套反射API并具备对JSR175规范的支持。 annotation processors处理annotation的基本过程如下： APT运行annotation processors根据提供的源文件中的annotation生成源代码文件和其它的文件（文件具体内容由annotation processors的编写者决定） 接着APT将生成的源代码文件和提供的源文件进行编译生成类文件。 APT在编译时自动查找所有继承自AbstractProcessor的类，然后调用他们的process方法去处理，这样就拥有了在编译过程中执行代码的能力 所以我们需要做的是: 自定义类继承AbstractProcessor 重写process方法 那我们就开始写: 12public class Processor extends AbstractProcessor&#123;&#125; 但是在Android Studio死活提示找不到AbstractProcessor类，这是因为注解是javase中javax包里面的，android.jar默认是不包含的，所以会编译报错.解决方法就是新建一个Module，在选择类型时将该Module的类型选为Java Library。然后在该Module中创建就好了Processor就好了，完美解决。 好，那我们就开始写个编译时处理的demo : Android Studio中创建一个Android工程。 新建一个Module，然后选择Java Library类型(我的名字为annotations)，并且让app依赖该module。 在annotations的module中创建注解类: 123456789101112package com.charon;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.CLASS)public @interface AnnotationTest &#123; String value() default \"\";&#125; 然后在annotations的module自定义Processor类 12345678910111213141516171819202122232425262728package com.charon;import java.util.Set;import javax.annotation.processing.AbstractProcessor;import javax.annotation.processing.RoundEnvironment;import javax.annotation.processing.SupportedAnnotationTypes;import javax.annotation.processing.SupportedSourceVersion;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.TypeElement;@SupportedAnnotationTypes(\"com.charon.AnnotationTest\")@SupportedSourceVersion(SourceVersion.RELEASE_7)public class TestProcessor extends AbstractProcessor &#123; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; System.out.println(\"process\"); for (TypeElement te : annotations) &#123; for (Element element : roundEnv.getElementsAnnotatedWith(te)) &#123; AnnotationTest annotation = element.getAnnotation(AnnotationTest.class); String value = annotation.value(); System.out.println(\"type : \" + value); &#125; &#125; return true; &#125;&#125; 注意:@SupportedAnnotationTypes(&quot;com.charon.AnnotationTest&quot;)来指定要处理的注解类。 @SupportedSourceVersion(SourceVersion.RELEASE_7)指定编译的版本。这种通过注解指定编译版本和类型的方式是从Java 1.7才有的。 对于之前的版本都是通过重写AbstractProcessor中的方法来指定的。 注册处理器 我们自定义了Processor那如何才能让其生效呢?就是在annotations的java同级目录新建resources/META-INF/services/javax.annotation.processing.Processor文件 1234- java- META-INF - services - javax.annotation.processing.Processor 然后在javax.annotation.processing.Processor文件中指定自定义的处理器，如: 1com.charon.TestProcessor 如果多个话就分行写。 然后我们Build一下(命令行执行./gradlew build)，就能看到控制台打印出来如下的信息: 12345:app:compileReleaseJavaWithJavac:app:compileReleaseJavaWithJavac - is not incremental (e.g. outputs have changed, no previous execution, etc.).processvalue : hahaprocess 注意:千万不要去logcat中找信息，这是编译时注解。 注意:一定要使用jdk1.7，1.8对注解的支持有bug。 上面只是一个简单的例子，如果你想用编译时注解去做一些更高级的事情，例如自动生成一些代码，那你可能就会用到如下几个类库: android-apt Google Auto Square javapoet 这三个库分别的作用为: android-apt Android Studio原本是不支持注解处理器的, 但是用android-apt这个插件后, 我们就可以使用注解处理器了, 这个插件可以自动的帮你为生成的代码创建目录, 让生成的代码编译到APK里面去, 而且它还可以让最终编译出来的APK里面不包含注解处理器本身的代码, 因为这部分代码只是编译的时候需要用来生成代码, 最终运行的时候是不需要的。 也就是说它主要有两个目的: 允许配置只在编译时作为注解处理器的依赖，而不添加到最后的APK或library 设置源路径，使注解处理器生成的代码能被Android Studio正确的引用 那在什么情况下我们会需要使用它呢？当你需要引入Processor生成的源代码到你的代码中时。例如当你使用Dagger 2或AndroidAnnotaition.该插件使得Android Studio可以配置生成资源的build path,避免IDE报错。当使用apt添加添加依赖，它将不会被包含到最终的APK里。 Auto Google Auto的主要作用是注解Processor类，并对其生成META-INF的配置信息， 可以让你不用去写META-INF这些配置文件，只要在自定义的Processor上面加上@AutoService(Processor.class) javapoet javapoet:A Java API for generating .java source files.可以更方便的生成代码，它可以帮助我们通过类调用的形式来生成代码。 ###自定义编译时注解 在自定义注解时，一般来说可能会建三个modules: app module:写一些使用注解的android应用逻辑。 api module:定义一些可以在app中使用的注解。它会被app以及compiler使用。 compiler module:定义Processor该module不会被包含到应用中，它只会在构建过程中被使用。在编译的过程中它会生成一些java文件，而这些java文件会被打包进apk中。 我们可以在该module中使用auto以及javapoet。 下面开始配置android-apt： 配置到app module下的build.gradle中 123456789101112131415161718192021222324252627282930313233343536373839404142434445apply plugin: 'com.android.application'// aptapply plugin: 'com.neenbedankt.android-apt'android &#123; compileSdkVersion 23 buildToolsVersion \"23.0.3\" defaultConfig &#123; applicationId \"com.charon.annotationdemo\" minSdkVersion 14 targetSdkVersion 23 versionCode 1 versionName \"1.0\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7 &#125;&#125;buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // 配置apt classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.4.0' compile project(':api') apt project(':compiler')&#125; 接下来在compiler module中配置auto以及javapoet 12345678apply plugin: 'java'sourceCompatibility = JavaVersion.VERSION_1_7targetCompatibility = JavaVersion.VERSION_1_7dependencies &#123; compile project (':api') compile 'com.google.auto.service:auto-service:1.0-rc2' compile 'com.squareup:javapoet:1.7.0'&#125; 在api module中也加上如下的配置: 123apply plugin: 'java'sourceCompatibility = JavaVersion.VERSION_1_7targetCompatibility = JavaVersion.VERSION_1_7 接下来在api module中定义一个注解 123456789101112package com.charon;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.CLASS)public @interface AnnotationTest &#123; String value();&#125; 然后在compiler module中自定义一个Processor 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.charon;import com.google.auto.service.AutoService;import java.util.Set;import javax.annotation.processing.AbstractProcessor;import javax.annotation.processing.ProcessingEnvironment;import javax.annotation.processing.Processor;import javax.annotation.processing.RoundEnvironment;import javax.lang.model.SourceVersion;import javax.lang.model.element.TypeElement;@AutoService(Processor.class)public class MyProcessor extends AbstractProcessor &#123; /** * Initializes the processor with the processing environment by * setting the &#123;@code processingEnv&#125; field to the value of the * &#123;@code processingEnv&#125; argument. An &#123;@code * IllegalStateException&#125; will be thrown if this method is called * more than once on the same object. * * @param processingEnv environment to access facilities the tool framework * provides to the processor * @throws IllegalStateException if this method is called more than once. */ @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); &#125; /** * Processes a set of annotation types on type elements originating from the prior round * and returns whether or not these annotations are claimed by this processor. * If true is returned, the annotations are claimed and subsequent processors will * not be asked to process them; * if false is returned, the annotations are unclaimed and subsequent processors may be * asked to process them. A processor may always return the same boolean value * or may vary the result based on chosen criteria. * The input set will be empty if the processor supports \"*\" and the root elements * have no annotations. A Processor must gracefully handle an empty set of annotations. * @param annotations * @param roundEnv * @return */ @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; System.out.println(\"hello processor\"); return false; &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; return super.getSupportedAnnotationTypes(); &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125;&#125; 这里简单的说一下这几个主要的方法: - `init()`:初始化操作的方法，`RoundEnvironment`会提供很多有用的工具类`Elements`、`Types`和`Filer`等。 - `process()`:这相当于每个处理器的主函数`main()`。在该方法中去扫描、评估、处理以及生成`Java`文件。 - `getSupportedAnnotationTypes()`:这里你必须指定，该注解器是注册给哪个注解的。 - `getSupportedSourceVersion()`:用来指定你使用的`java`版本。通常这里会直接放回`SourceVersion.latestSupported()`即可。 从`idk 1.7`开始，可以使用如下注解来代替`getSupporedAnnotationTypes()`和`getSupportedSourceVersion()`方法: 1234@SupportedSourceVersion(SourceVersion.latestSupported())@SupportedAnnotationTypes(&#123; // 合法注解全名的集合 &#125;) 注解相关API: Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a) 返回使用给定注释类型注释的元素。该注释可能直接出现或者被继承。只返回注释处理的此round中包括的package元素和type元素、成员声明、参数或者这些元素中声明的类型参数。 Element 表示一个程序元素，比如包、类或者方法。每个元素都表示一个静态的语言级构造（不表示虚拟机的运行时构造）。 元素应该使用equals(Object)方法进行比较。不保证总是使用相同的对象表示某个特定的元素。 要实现基于Element对象类的操作，可以使用visitor或者使用getKind()方法的结果。使用instanceof确定此建模层次结构中某一对象的有效类未必可靠，因为一个实现可以选择让单个对象实现多个Element子接口。 TypeElement 表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。注意，枚举类型是一种类，而注释类型是一种接口。 而DeclaredType表示一个类或接口类型，后者将成为前者的一种使用（或调用）。这种区别对于一般的类型是最明显的，对于这些类型，单个元素可以定义一系列完整的类型。 例如，元素java.util.Set对应于参数化类型java.util.Set&lt;String&gt;和java.util.Set&lt;Number&gt;（以及其他许多类型），还对应于原始类型java.util.Set。 扯远了，那我们就以上面的目录结构和实现方式，通过一个具体的例子要详细说明，例子真的很难找，我在网上找到了一个大神写的，虽然从这个例子中并不能看出注解的强大之处，但是对于讲解来说还是非常有用的: 我们要解决的问题是我们想要实现一个披萨店，该店会提供两种披萨(Margherita和Calzone)和一种甜点(Tiramisu)。 首先我们在app module中创建对应的接口和代码 ，如下: 123456789101112131415161718192021222324public interface Meal &#123; public float getPrice();&#125;public class MargheritaPizza implements Meal &#123; @Override public float getPrice() &#123; return 6.0f; &#125;&#125;public class CalzonePizza implements Meal &#123; @Override public float getPrice() &#123; return 8.5f; &#125;&#125;public class Tiramisu implements Meal &#123; @Override public float getPrice() &#123; return 4.5f; &#125;&#125; 如果消费者想要下单，那么它需要输入对应的物品名字:12345678910111213141516171819202122232425262728public class PizzaStore &#123; public Meal order(String mealName) &#123; if (mealName == null) &#123; throw new IllegalArgumentException(\"Name of the meal is null!\"); &#125; if (\"Margherita\".equals(mealName)) &#123; return new MargheritaPizza(); &#125; if (\"Calzone\".equals(mealName)) &#123; return new CalzonePizza(); &#125; if (\"Tiramisu\".equals(mealName)) &#123; return new Tiramisu(); &#125; throw new IllegalArgumentException(\"Unknown meal '\" + mealName + \"'\"); &#125; public static void main(String[] args) throws IOException &#123; PizzaStore pizzaStore = new PizzaStore(); Meal meal = pizzaStore.order(readConsole()); System.out.println(\"Bill: $\" + meal.getPrice()); &#125; 这样的话在order()方法中，会有很多if语句，并且每当我们添加一种新的披萨，我们都要添加一条新的if语句。但是我们可以使用注解和工厂模式，我们就可以让注解来自动生成这些在工厂中的if语句。我们期待的代码如下:1234567891011121314public class PizzaStore &#123; private MealFactory factory = new MealFactory(); public Meal order(String mealName) &#123; return factory.create(mealName); &#125; public static void main(String[] args) throws IOException &#123; PizzaStore pizzaStore = new PizzaStore(); Meal meal = pizzaStore.order(readConsole()); System.out.println(\"Bill: $\" + meal.getPrice()); &#125;&#125; MealFactory的实现应该如下:123456789101112131415161718192021public class MealFactory &#123; public Meal create(String id) &#123; if (id == null) &#123; throw new IllegalArgumentException(\"id is null!\"); &#125; if (\"Calzone\".equals(id)) &#123; return new CalzonePizza(); &#125; if (\"Tiramisu\".equals(id)) &#123; return new Tiramisu(); &#125; if (\"Margherita\".equals(id)) &#123; return new MargheritaPizza(); &#125; throw new IllegalArgumentException(\"Unknown id = \" + id); &#125;&#125; 接下来我们要做的就是通过注解来生成MealFactory中的代码。想法是这样的：我们将使用同样的type()注解那些属于同一个工厂的类，并且用注解的id()做一个映射，例如从”Calzone”映射到”ClzonePizza”类。我们使用@Factory注解到我们的类中，如下： 12345678910@Factory( id = \"Margherita\", type = Meal.class)public class MargheritaPizza implements Meal &#123; @Override public float getPrice() &#123; return 6f; &#125;&#125; 12345678910@Factory( id = \"Calzone\", type = Meal.class)public class CalzonePizza implements Meal &#123; @Override public float getPrice() &#123; return 8.5f; &#125;&#125; 12345678910@Factory( id = \"Tiramisu\", type = Meal.class)public class Tiramisu implements Meal &#123; @Override public float getPrice() &#123; return 4.5f; &#125;&#125; 你可能会问你自己，我们是否可以只把@Factory注解应用到Meal接口上？答案是注解是不能继承的。一个类class X被注解，并不意味着它的子类class Y extends X会自动被注解。在我们开始写处理器的代码之前，我们先规定如下一些规则： 只有类可以被@Factory注解，因为接口或者抽象类并不能用new操作实例化； 被@Factory注解的类，必须至少提供一个公开的默认构造器（即没有参数的构造函数）。否者我们没法实例化一个对象。 被@Factory注解的类必须直接或者间接的继承于type()指定的类型； 具有相同的type的注解类，将被聚合在一起生成一个工厂类。这个生成的类使用Factory后缀，例如type = Meal.class，将生成MealFactory工厂类； id只能是String类型，并且在同一个type组中必须唯一。 那我们接着看一下在compiler module中的自定义的FactoryProcessor类:123456789101112131415161718192021222324252627282930313233343536@AutoService(Processor.class)public class FactoryProcessor extends AbstractProcessor &#123; private Types typeUtils; private Elements elementUtils; private Filer filer; private Messager messager; private Map&lt;String, FactoryGroupedClasses&gt; factoryClasses = new LinkedHashMap&lt;String, FactoryGroupedClasses&gt;(); @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); typeUtils = processingEnv.getTypeUtils(); elementUtils = processingEnv.getElementUtils(); filer = processingEnv.getFiler(); messager = processingEnv.getMessager(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; annotataions = new LinkedHashSet&lt;String&gt;(); // 指定支持@Factory注解 annotataions.add(Factory.class.getCanonicalName()); return annotataions; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; ... &#125;&#125; 在init()方法中，我们初始化了几个变量: Elements: 处理Element的工具类 Types: 处理TypeMirror的工具类 Filer: 用来创建你要创建的文件 Messager:提供给注解处理器一个报告错误、警告以及提示信息的途径。 在注解的处理过程中会扫描所有的java源文件。源代码中的每一个部分都是一个特定类型的Element。换句话说:Element代表程序的元素，例如包、类或者方法等。每个Element代表一个构建，例如通过下面的例子我们来说明一下:12345678910111213package com.example; // PackageElementpublic class Foo &#123; // TypeElement private int a; // VariableElement private Foo other; // VariableElement public Foo () &#123;&#125; // ExecuteableElement public void setA ( // ExecuteableElement int newA // TypeElement ) &#123;&#125;&#125; 所以在注解中我们必须要换一个角度来看待源代码，它只是一个结构化的文本，我们可以像XML中的DOM一样去解析它。例如现在有一个代表public class Foo类的TypeElement元素，你可以遍历它的子元素，如下:1234TypeElement fooClass = ... ; for (Element e : fooClass.getEnclosedElements())&#123; // iterate over children Element parent = e.getEnclosingElement(); // parent == fooClass&#125; 正如你所见，Element代表的是源代码。TypeElement代表的是源代码中的类型元素，例如类。然而TypeElement并不包含类本身的信息。你可以从TypeElement中获取类的名字，但是你获取不到类的信息，例如它的父类。这种信息需要通过TypeMirror获取。你可以通过调用elements.asType()获取元素的TypeMirror。 接下来我们来继续实现process()方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344@AutoService(Processor.class)public class FactoryProcessor extends AbstractProcessor &#123; private Types typeUtils; private Elements elementUtils; private Filer filer; private Messager messager; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); typeUtils = processingEnv.getTypeUtils(); elementUtils = processingEnv.getElementUtils(); filer = processingEnv.getFiler(); messager = processingEnv.getMessager(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; annotataions = new LinkedHashSet&lt;String&gt;(); annotataions.add(Factory.class.getCanonicalName()); return annotataions; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; // roundEnv.getElementsAnnotatedWith(Factory.class))返回所有被注解了@Factory的元素的列表。 // 你可能已经注意到，我们并没有说“所有被注解了@Factory的类的列表”，因为它真的是返回Element的列表。 // 请记住：Element可以是类、方法、变量等。所以，接下来，我们必须检查这些Element是否是一个类 for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) &#123; // Check if a class has been annotated with @Factory if (annotatedElement.getKind() != ElementKind.CLASS) &#123; return false; &#125; &#125; return false; &#125;&#125; 在继续检查被注解@Fractory的类是否满足我们上面说的5条规则之前，我们将介绍一个让我们更方便继续处理的数据结构。有时候，一个问题或者解释器看起来如此简单，以至于程序员倾向于用一个面向过程方式来写整个处理器。但是你知道吗？一个注解处理器仍然是一个Java程序，所以我们需要使用面向对象编程、接口、设计模式，以及任何你将在其他普通Java程序中使用的技巧。 我们的FactoryProcessor非常简单，但是我们仍然想要把一些信息存为对象。在FactoryAnnotatedClass中，我们保存被注解类的数据，比如合法的类的名字，以及@Factory注解本身的一些信息。也就是说每一个使用了@Factory注解的类都对应一个FactoryAnnotatedClass类，所以，我们保存TypeElement和处理过的@Factory注解： 如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class FactoryAnnotatedClass &#123; private TypeElement annotatedClassElement; private String qualifiedSuperClassName; private String simpleTypeName; private String id; public FactoryAnnotatedClass(TypeElement classElement) throws IllegalArgumentException &#123; this.annotatedClassElement = classElement; Factory annotation = classElement.getAnnotation(Factory.class); id = annotation.id(); if (StringUtils.isEmpty(id)) &#123; throw new IllegalArgumentException( String.format(\"id() in @%s for class %s is null or empty! that's not allowed\", Factory.class.getSimpleName(), classElement.getQualifiedName().toString())); &#125; // Get the full QualifiedTypeName try &#123; Class&lt;?&gt; clazz = annotation.type(); // 返回底层阶级Java语言规范中定义的标准名称。 qualifiedSuperClassName = clazz.getCanonicalName(); simpleTypeName = clazz.getSimpleName(); &#125; catch (MirroredTypeException mte) &#123; DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror(); TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement(); qualifiedSuperClassName = classTypeElement.getQualifiedName().toString(); simpleTypeName = classTypeElement.getSimpleName().toString(); &#125; &#125; /** * 获取在&#123;@link Factory#id()&#125;中指定的id * return the id */ public String getId() &#123; return id; &#125; /** * 获取在&#123;@link Factory#type()&#125;指定的类型合法全名 * * @return qualified name */ public String getQualifiedFactoryGroupName() &#123; return qualifiedSuperClassName; &#125; /** * 获取在&#123;@link Factory#type()&#125;&#123;@link Factory#type()&#125;指定的类型的简单名字 * * @return qualified name */ public String getSimpleFactoryGroupName() &#123; return simpleTypeName; &#125; /** * 获取被@Factory注解的原始元素 */ public TypeElement getTypeElement() &#123; return annotatedClassElement; &#125;&#125; 上面我们用到了Class,因为这里的类型是一个java.lang.Class。这就意味着，他是一个真正的Class对象。因为注解处理是在编译Java源代码之前。我们需要考虑如下两种情况： 这个类已经被编译：这种情况是：如果第三方.jar包含已编译的被@Factory注解.class文件。在这种情况下，可以通过上面的方式在try代码块中直接获取。 这个还没有被编译：这种情况是我们尝试编译被@Fractory注解的源代码。这种情况下，直接获取Class会抛出MirroredTypeException异常。幸运的是，MirroredTypeException包含一个TypeMirror，它表示我们未编译类。因为我们已经知道它必定是一个类类型（我们已经在前面检查过），我们可以直接强制转换为DeclaredType，然后读取TypeElement来获取合法的名字。 好了，我们现在还需要一个数据结构类FactoryGroupedClasses，它将简单的组合所有的FactoryAnnotatedClasses到一起。12345678910111213141516171819202122232425public class FactoryGroupedClasses &#123; private String qualifiedClassName; private Map&lt;String, FactoryAnnotatedClass&gt; itemsMap = new LinkedHashMap&lt;String, FactoryAnnotatedClass&gt;(); public FactoryGroupedClasses(String qualifiedClassName) &#123; this.qualifiedClassName = qualifiedClassName; &#125; public void add(FactoryAnnotatedClass toInsert) throws IdAlreadyUsedException &#123; FactoryAnnotatedClass existing = itemsMap.get(toInsert.getId()); if (existing != null) &#123; throw new IdAlreadyUsedException(existing); &#125; itemsMap.put(toInsert.getId(), toInsert); &#125; public void generateCode(Elements elementUtils, Filer filer) throws IOException &#123; ... &#125;&#125; 正如你所见，这是一个基本的Map&lt;String, FactoryAnnotatedClass&gt;，这个映射表用来映射@Factory.id()到FactoryAnnotatedClass。我们选择Map这个数据类型，是因为我们要确保每个id是唯一的，我们可以很容易通过map查找实现。generateCode()方法将被用来生成工厂类代码（将在后面讨论）。 我们继续实现process()方法。接下来我们想要检查被注解的类必须有只要一个公开的构造函数，不是抽象类，继承于特定的类型，以及是一个公开类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177@AutoService(Processor.class)public class FactoryProcessor extends AbstractProcessor &#123; private Types typeUtils; private Elements elementUtils; private Filer filer; private Messager messager; private Map&lt;String, FactoryGroupedClasses&gt; factoryClasses = new LinkedHashMap&lt;String, FactoryGroupedClasses&gt;(); @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); typeUtils = processingEnv.getTypeUtils(); elementUtils = processingEnv.getElementUtils(); filer = processingEnv.getFiler(); messager = processingEnv.getMessager(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; annotataions = new LinkedHashSet&lt;String&gt;(); annotataions.add(Factory.class.getCanonicalName()); return annotataions; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; // roundEnv.getElementsAnnotatedWith(Factory.class))返回所有被注解了@Factory的元素的列表。 // 你可能已经注意到，我们并没有说“所有被注解了@Factory的类的列表”，因为它真的是返回Element的列表。 // 请记住：Element可以是类、方法、变量等。所以，接下来，我们必须检查这些Element是否是一个类 for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) &#123; // Check if a class has been annotated with @Factory if (annotatedElement.getKind() != ElementKind.CLASS) &#123; error(annotatedElement, \"Only classes can be annotated with @%s\", Factory.class.getSimpleName()); return true; // 退出处理 &#125; // 因为我们已经知道它是ElementKind.CLASS类型，所以可以直接强制转换 TypeElement typeElement = (TypeElement) annotatedElement; try &#123; FactoryAnnotatedClass annotatedClass = new FactoryAnnotatedClass(typeElement); // throws IllegalArgumentException if (!isValidClass(annotatedClass)) &#123; return true; // 已经打印了错误信息，退出处理过程 &#125; // 一旦我们检查isValidClass()成功，我们将添加FactoryAnnotatedClass到对应的FactoryGroupedClasses中 FactoryGroupedClasses factoryClass = factoryClasses.get(annotatedClass.getQualifiedFactoryGroupName()); if (factoryClass == null) &#123; String qualifiedGroupName = annotatedClass.getQualifiedFactoryGroupName(); factoryClass = new FactoryGroupedClasses(qualifiedGroupName); factoryClasses.put(qualifiedGroupName, factoryClass); &#125; // 如果和其他的@Factory标注的类的id相同冲突， // 抛出IdAlreadyUsedException异常 factoryClass.add(annotatedClass); &#125; catch (IllegalArgumentException e) &#123; // @Factory.id()为空 --&gt; 打印错误信息 error(typeElement, e.getMessage()); return true; &#125; catch (IdAlreadyUsedException e) &#123; FactoryAnnotatedClass existing = e.getExisting(); // 已经存在 error(annotatedElement, \"Conflict: The class %s is annotated with @%s with id ='%s' but %s already uses the same id\", typeElement.getQualifiedName().toString(), Factory.class.getSimpleName(), existing.getTypeElement().getQualifiedName().toString()); return true; &#125; &#125; // 为每个工厂生成Java文件 try &#123; for (FactoryGroupedClasses factoryClass : factoryClasses.values()) &#123; factoryClass.generateCode(elementUtils, filer); &#125; // TODO ...注意这里会遗留一个问题，我们后面再仔细说。 &#125; catch (IOException e) &#123; error(null, e.getMessage()); &#125; return true; &#125; private void error(Element e, String msg, Object... args) &#123; messager.printMessage( Diagnostic.Kind.ERROR, String.format(msg, args), e); &#125; private boolean isValidClass(FactoryAnnotatedClass item) &#123; // 转换为TypeElement, 含有更多特定的方法 TypeElement classElement = item.getTypeElement(); if (!classElement.getModifiers().contains(Modifier.PUBLIC)) &#123; error(classElement, \"The class %s is not public.\", classElement.getQualifiedName().toString()); return false; &#125; // 检查是否是一个抽象类 if (classElement.getModifiers().contains(Modifier.ABSTRACT)) &#123; error(classElement, \"The class %s is abstract. You can't annotate abstract classes with @%\", classElement.getQualifiedName().toString(), Factory.class.getSimpleName()); return false; &#125; // 检查继承关系: 必须是@Factory.type()指定的类型子类 TypeElement superClassElement = elementUtils.getTypeElement(item.getQualifiedFactoryGroupName()); if (superClassElement.getKind() == ElementKind.INTERFACE) &#123; // 检查接口是否实现了 if(!classElement.getInterfaces().contains(superClassElement.asType())) &#123; error(classElement, \"The class %s annotated with @%s must implement the interface %s\", classElement.getQualifiedName().toString(), Factory.class.getSimpleName(), item.getQualifiedFactoryGroupName()); return false; &#125; &#125; else &#123; // 检查子类 TypeElement currentClass = classElement; while (true) &#123; TypeMirror superClassType = currentClass.getSuperclass(); if (superClassType.getKind() == TypeKind.NONE) &#123; // 到达了基本类型(java.lang.Object), 所以退出 error(classElement, \"The class %s annotated with @%s must inherit from %s\", classElement.getQualifiedName().toString(), Factory.class.getSimpleName(), item.getQualifiedFactoryGroupName()); return false; &#125; if (superClassType.toString().equals(item.getQualifiedFactoryGroupName())) &#123; // 找到了要求的父类 break; &#125; // 在继承树上继续向上搜寻 currentClass = (TypeElement) typeUtils.asElement(superClassType); &#125; &#125; // 检查是否提供了默认公开构造函数 for (Element enclosed : classElement.getEnclosedElements()) &#123; if (enclosed.getKind() == ElementKind.CONSTRUCTOR) &#123; ExecutableElement constructorElement = (ExecutableElement) enclosed; if (constructorElement.getParameters().size() == 0 &amp;&amp; constructorElement.getModifiers() .contains(Modifier.PUBLIC)) &#123; // 找到了默认构造函数 return true; &#125; &#125; &#125; // 没有找到默认构造函数 error(classElement, \"The class %s must provide an public empty default constructor\", classElement.getQualifiedName().toString()); return false; &#125;&#125; 我们这里添加了isValidClass()方法，来检查是否我们所有的规则都被满足了： 必须是公开类：classElement.getModifiers().contains(Modifier.PUBLIC) 必须是非抽象类：classElement.getModifiers().contains(Modifier.ABSTRACT) 必须是@Factoy.type()指定的类型的子类或者接口的实现：首先我们使用elementUtils.getTypeElement(item.getQualifiedFactoryGroupName())创建一个传入的Class(@Factoy.type())的元素。是的，你可以仅仅通过已知的合法类名来直接创建TypeElement（使用TypeMirror）。接下来我们检查它是一个接口还是一个类：superClassElement.getKind() == ElementKind.INTERFACE。所以我们这里有两种情况：如果是接口，就判断classElement.getInterfaces().contains(superClassElement.asType())；如果是类，我们就必须使用currentClass.getSuperclass()扫描继承层级。注意，整个检查也可以使用typeUtils.isSubtype()来实现。 类必须有一个公开的默认构造函数：我们遍历所有的闭元素classElement.getEnclosedElements()，然后检查ElementKind.CONSTRUCTOR、Modifier.PUBLIC以及constructorElement.getParameters().size() == 0。 上面都实现完成后下面就是在FactoryGroupedClasses.generateCode()方法中去生成java文件了。写Java文件，和写其他普通文件没有什么两样。使用Filer提供的Writer对象，我们可以连接字符串来写我们生成的Java代码。但是这样是不是非常麻烦啊？还好良心企业Square给我们提供了Javapoet，我们可以用它来非常简单的去生成java文件。那我们接下来就使用javapoet来去生成代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class FactoryGroupedClasses &#123; /** * 将被添加到生成的工厂类的名字中 */ private static final String SUFFIX = \"Factory\"; private String qualifiedClassName; private Map&lt;String, FactoryAnnotatedClass&gt; itemsMap = new LinkedHashMap&lt;String, FactoryAnnotatedClass&gt;(); public FactoryGroupedClasses(String qualifiedClassName) &#123; this.qualifiedClassName = qualifiedClassName; &#125; public void add(FactoryAnnotatedClass toInsert) throws ProcessingException &#123; FactoryAnnotatedClass existing = itemsMap.get(toInsert.getId()); if (existing != null) &#123; // Alredy existing throw new ProcessingException(toInsert.getTypeElement(), \"Conflict: The class %s is annotated with @%s with id ='%s' but %s already uses the same id\", toInsert.getTypeElement().getQualifiedName().toString(), Factory.class.getSimpleName(), toInsert.getId(), existing.getTypeElement().getQualifiedName().toString()); &#125; itemsMap.put(toInsert.getId(), toInsert); &#125; public void generateCode(Elements elementUtils, Filer filer) throws IOException &#123; TypeElement superClassName = elementUtils.getTypeElement(qualifiedClassName); String factoryClassName = superClassName.getSimpleName() + SUFFIX; String qualifiedFactoryClassName = qualifiedClassName + SUFFIX; PackageElement pkg = elementUtils.getPackageOf(superClassName); String packageName = pkg.isUnnamed() ? null : pkg.getQualifiedName().toString(); MethodSpec.Builder method = MethodSpec.methodBuilder(\"create\") .addModifiers(Modifier.PUBLIC) .addParameter(String.class, \"id\") .returns(TypeName.get(superClassName.asType())); // check if id is null method.beginControlFlow(\"if (id == null)\") .addStatement(\"throw new IllegalArgumentException($S)\", \"id is null!\") .endControlFlow(); // Generate items map for (FactoryAnnotatedClass item : itemsMap.values()) &#123; method.beginControlFlow(\"if ($S.equals(id))\", item.getId()) .addStatement(\"return new $L()\", item.getTypeElement().getQualifiedName().toString()) .endControlFlow(); &#125; method.addStatement(\"throw new IllegalArgumentException($S + id)\", \"Unknown id = \"); TypeSpec typeSpec = TypeSpec.classBuilder(factoryClassName).addMethod(method.build()).build(); // Write file JavaFile.builder(packageName, typeSpec).build().writeTo(filer); &#125;&#125; 到这里，我感觉完成了，运行一下，结果发现报错了:1234567:compiler:jar UP-TO-DATE:app:compileDebugJavaWithJavac错误: Attempt to recreate a file for type com.charon.annotationdemo.inter.MealFactory错误: Attempt to recreate a file for type com.charon.annotationdemo.inter.MealFactory2 个错误Error:Execution failed for task ':app:compileDebugJavaWithJavac'.&gt; Compilation failed; see the compiler error output for details. 那我们继续来解决这个问题，这个问题是由于循环引起的，我们还要处理一个重要的事情就是循环的问题: 注解处理可能会执行多次，官方文档中是这样介绍的: Annotation processing happens in a sequence of rounds. On each round, a processor may be asked to process a subset of the annotations found on the source and class files produced by a prior round. The inputs to the first round of processing are the initial inputs to a run of the tool; these initial inputs can be regarded as the output of a virtual zeroth round of processing. 一个简单的定义：一个处理循环是调用一个注解处理器的process()方法。对应到我们的工厂模式的例子中：FactoryProcessor被初始化一次（不是每次循环都会新建处理器对象），然而，如果生成了新的源文件process()能够被调用多次。听起来有点奇怪不是么？原因是这样的，这些生成的文件中也可能包含@Factory注解，它们还将会被FactoryProcessor处理。 例如我们的PizzaStore的例子中将会经过3次循环处理： Round Input Output 1 CalzonePizza.java Tiramisu.java MargheritaPizza.java Meal.java PizzaStore.java MealFactory.java 2 MealFactory.java none 3 none none 会循环三次，但是第一次就会生成代码，所以上面会出现两次重复创建文件的错误。 解释处理循环还有另外一个原因。如果你看一下我们的FactoryProcessor代码你就能注意到，我们收集数据和保存它们在一个私有的域中Map&lt;String, FactoryGroupedClasses&gt; factoryClasses。在第一轮中，我们检测到了MagheritaPizza, CalzonePizza和Tiramisu，然后生成了MealFactory.java。在第二轮中把MealFactory作为输入。因为在MealFactory中没有检测到@Factory注解，我们预期并没有错误，然而我们得到如下的信息： 1234567:compiler:jar UP-TO-DATE:app:compileDebugJavaWithJavac错误: Attempt to recreate a file for type com.charon.annotationdemo.inter.MealFactory错误: Attempt to recreate a file for type com.charon.annotationdemo.inter.MealFactory2 个错误Error:Execution failed for task ':app:compileDebugJavaWithJavac'.&gt; Compilation failed; see the compiler error output for details. 这个问题是因为我们没有清除factoryClasses，这意味着，在第二轮的process()中，任然保存着第一轮的数据，并且会尝试生成在第一轮中已经生成的文件，从而导致这个错误的出现。在我们的这个场景中，我们知道只有在第一轮中检查@Factory注解的类，所以我们可以简单的修复这个问题，如下：12345678910111213141516@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; try &#123; for (FactoryGroupedClasses factoryClass : factoryClasses.values()) &#123; factoryClass.generateCode(elementUtils, filer); &#125; // 清除factoryClasses factoryClasses.clear(); &#125; catch (IOException e) &#123; error(null, e.getMessage()); &#125; ... return true;&#125; 我们要记住注解处理过程是需要经过多轮处理的，并且你不能重载或者重新创建已经生成的源代码。 好了，到这里就彻底完成了，运行一下，当然成功了，那生成的文件在哪里呢？ 那既然能生成，我们该怎么去调用呢？很简单，像平常一样去用。1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; private View view; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); view = findViewById(R.id.tv); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; MealFactory factory = new MealFactory(); factory.create(\"Calzone\"); &#125; &#125;); &#125;&#125; 你可能会发现报错，找不到类，你可以不用管它，直接运行，你会发现一切都OK的。当然如果你倒错了包你就当我没说。 作为Android开发者，当然应该很熟悉ButterKnife。在ButterKnife中使用@InjectView注解View。ButterKnifeProcessor生成一个MyActivity$$ViewInjector，但是在ButterKnife你不需要手动调用new MyActivity$$ViewInjector()来实例化一个ButterKnife注入的对象，而是使用Butterknife.inject(activity)。ButterKnife内部使用反射机制来实例化MyActivity$$ViewInjector()对象： 123try &#123; Class&lt;?&gt; injector = Class.forName(clsName + \"$$ViewInjector\");&#125; catch (ClassNotFoundException e) &#123; ... &#125; 但是反射机制会稍微有些慢，我们使用注解处理来生成本地代码，会不会导致很多的反射性能的问题？的确，反射机制的性能确实是一个问题。然而，它不需要手动去创建对象，确实提高了开发者的开发速度。ButterKnife中有一个哈希表HashMap来缓存实例化过的对象。所以MyActivity$$ViewInjector只是使用反射机制实例化一次，第二次需要MyActivity$$ViewInjector的时候，就直接从哈希表中获得。 FragmentArgs非常类似于ButterKnife。它使用反射机制来创建对象，而不需要开发者手动来做这些。FragmentArgs在处理注解的时候生成一个特别的查找表类，它其实就是一种哈希表，所以整个FragmentArgs库只是在第一次使用的时候，执行一次反射调用，一旦整个Class.forName()的Fragemnt的参数对象被创建，后面的都是本地代码运行了。 好了至此例子讲完了。 最后讲一下按照上面的三层分类:app,api,compiler进行分类的好处。我们这么做是因为想让我们的工厂模式的例子的使用者在他们的工程中只编译注解，而包含处理器模块只是为了编译。有点晕？我们举个例子，如果我们只有一个包。如果另一个开发者想要把我们的工厂模式处理器用于他的项目中，他就必须包含@Factory注解和整个FactoryProcessor的代码（包括FactoryAnnotatedClass和FactoryGroupedClasses）到他们项目中。我非常确定的是，他并不需要在他已经编译好的项目中包含处理器相关的代码。如果你是一个Android的开发者，你肯定听说过65536个方法的限制（即在一个.dex文件中，只能寻址65536个方法）。如果你在FactoryProcessor中使用guava，并且把注解和处理器打包在一个包中，这样的话，Android APK安装包中不只是包含FactoryProcessor的代码，而也包含了整个guava的代码。Guava有大约20000个方法。所以分开注解和处理器是非常有意义的。 ###使用注解提高代码的检查性 Google提供了Support-Annotations library来支持更多的注解功能。可以直接在build.gradle中添加如下代码: 123dependencies &#123; compile &apos;com.android.support:support-annotations:23.3.0&apos;&#125; Android提供了很多注解来支持在方法、参数和返回值上面使用，例如: @Nullable 可以为null @NonNull 不能为null 1234567891011import android.support.annotation.NonNull;... /** Add support for inflating the &lt;fragment&gt; tag. */ @NonNull @Override public View onCreateView(String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; ... &#125;... @StringRes R.string类型的资源。 123456import android.support.annotation.StringRes;... public abstract void setTitle(@StringRes int resId); ...遇到那种你写了个`setTitle(int resId)`他确给你传`setTitle(R.drawable.xxx)`的选手，用这种方式能很好的去提示下。 @DrawableRes Drawable类型的资源。 @ColorRes Color类型的资源。 @InterpolatorRes Interpolatro类型。 @AnyRes R.类型。 @UiThread 从UI thread调用。 @RequiresPermission 来验证该方法的调用者所需要有的权限。检查一个列表中的任何一个权限可以使用anyOf属性。想要检查多个权限时，可以使用allOf属性。如下: 12@RequiresPermission(Manifest.permission.SET_WALLPAPER)public abstract void setWallpaper(Bitmap bitmap) throws IOException; 检查多个权限: 123456@RequiresPermission(allOf = &#123; Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;)public static final void copyFile(String dest, String source) &#123; ...&#125; 示例Demo已上传到Github:AnnotationDemo 文中例子来自Hannes Dorfmann大神的ANNOTATION PROCESSING 101，我对其重新梳理了下，来让能正常使用，并且上面的示例已经过我实际运行: Hannes Dorfmann 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Retrofit详解(下)","date":"2014-11-01T17:11:00.000Z","path":"2014/11/02/Retrofit详解(下)/","text":"Retrofit详解(下)上一篇文件介绍了Retrofit的基本使用，接下来我们通过从源码的角度分析一下Retrofit的实现。 首先看一下它的基本使用方法: 123456789101112131415161718192021222324// 1Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .addConverterFactory(GsonConverterFactory.create()) .build();// 2GitHubService gitHubService = retrofit.create(GitHubService.class);// 3Call&lt;List&lt;Repo&gt;&gt; call = gitHubService.listRepos(\"CharonChui\");// 4call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123; @Override public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) &#123; List&lt;Repo&gt; data = response.body(); Log.i(\"@@@\", \"data size : \" + (data == null ? \"null\" : data.size() + \"\")); &#125; @Override public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) &#123; &#125;&#125;); 我把上面主要分为4个部分，接下来逐一分析: 1. 创建Retrofit并进行配置。1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .addConverterFactory(GsonConverterFactory.create()) .build(); 简单的一句话，却埋藏了很多。 这是典型的建造者模式、外观模式 就想平时我们写的下载模块，作为一个公共的模块，我们可以对外提供一个DownloadManager供外界使用，而对于里面的实现我们完全可以闭门造车。 具体baseUrl()、addConverterFactory()方法里面的具体实现就不去看了，比较简单。当然这里也用到了工厂设计模式。 2. 创建对应的服务类1GitHubService gitHubService = retrofit.create(GitHubService.class); 这一部分是如何实现的呢？我们看一下retrofit.create()方法的实现: 1234567891011121314151617181920212223242526272829public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; // 这里的Platform主要是为了检测当前的运行平台，是java还是android，会根据当前的平台来返回默认的CallAdapter private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; // 代理调用 return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; // 1，根据动态代理的方法去生成ServiceMethod这里动态代理的方法就是listRepos方法 ServiceMethod serviceMethod = loadServiceMethod(method); // 2，根绝ServiceMethod和参数去生成OkHttpCall，这里args是CharonChui OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); // 3, serviceMethod去进行处理并返回Call对象，拿到这个Call对象才能去执行网络请求。 return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 看到Proxy.newProxyInstance()就明白了，这里使用了动态代理。简单的说动态代理是在你要调用某个Class的方法前或后，插入你想要执行的代码。那这里要代理的是什么方法？ Call&lt;List&lt;Repo&gt;&gt; call = gitHubService.listRepos(&quot;CharonChui&quot;);，这里就是listRepos()方法。 就是说在调用listRepos()方法时会被动态代理所拦截，然后执行Proxy.newProxyInstance()里面的InvocationHandler.invoke()中的部分。 而invoke()方法的三个参数分别是啥？ 分别是Object proxy: 代理对象，Method method：调用的方法，就是listRepos()方法，Object... args：方法的参数，这里是CharonChui。 有关动态代理介绍可以看张孝祥老师的java1.5高新技术系列中的动态代理 这里就不仔细介绍动态代理了，上面的代码中又分为三部分: loadServiceMethod() new OkHttpCall() serviceMethod.callAdapter.adapt() 我们这里分别来进行分析。 loadServiceMethod() 实现如下: 12345678910111213ServiceMethod loadServiceMethod(Method method) &#123; ServiceMethod result; synchronized (serviceMethodCache) &#123; // ServiceMethod包含了请求的所有相关数据，以及获取请求的request和把请求结果转换成java对象，所以相比较而言较重，用缓存来提高效率。 result = serviceMethodCache.get(method); if (result == null) &#123; // build result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result; &#125; 会通过缓存的方式来获取一个`ServiceMethod`类。通过缓存来保证同一个`API`的同一个方法只会创建一次。 有关`ServiceMethod`类的文档介绍是: 1Adapts an invocation of an interface method into an HTTP call. 大体翻译一下就是将一个请求接口的方法转换到`Http Call`中调用。 而上面第一次使用的时候会通过`new ServiceMethod.Builder(this, method).build()`创建，那我们看一下它的实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public ServiceMethod build() &#123; // 创建CallAdapter用来代理Call callAdapter = createCallAdapter(); responseType = callAdapter.responseType(); if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError(\"'\" + Utils.getRawType(responseType).getName() + \"' is not a valid response body type. Did you mean ResponseBody?\"); &#125; // responseConverter用来解析结果将json等返回结果解析成java对象 responseConverter = createResponseConverter(); for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; if (httpMethod == null) &#123; throw methodError(\"HTTP method annotation is required (e.g., @GET, @POST, etc.).\"); &#125; if (!hasBody) &#123; if (isMultipart) &#123; throw methodError( \"Multipart can only be specified on HTTP methods with request body (e.g., @POST).\"); &#125; if (isFormEncoded) &#123; throw methodError(\"FormUrlEncoded can only be specified on HTTP methods with \" + \"request body (e.g., @POST).\"); &#125; &#125; int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(p, \"Parameter type must not include a type variable or wildcard: %s\", parameterType); &#125; // 解析对应method的注解，这里是listRepos方法的注解。 Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(p, \"No Retrofit annotation found.\"); &#125; // 通过注解和参数类型，解析并赋值到parameterHandlers中 parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; if (relativeUrl == null &amp;&amp; !gotUrl) &#123; throw methodError(\"Missing either @%s URL or @Url parameter.\", httpMethod); &#125; if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123; throw methodError(\"Non-body HTTP method cannot contain @Body.\"); &#125; if (isFormEncoded &amp;&amp; !gotField) &#123; throw methodError(\"Form-encoded method must contain at least one @Field.\"); &#125; if (isMultipart &amp;&amp; !gotPart) &#123; throw methodError(\"Multipart method must contain at least one @Part.\"); &#125; // 创建`ServiceMethod()`对象 return new ServiceMethod&lt;&gt;(this); &#125; 总起来说，就是创建`CallAdapter`、`responseConverter`、解析注解、设置参数，然后创建`ServiceMethod`对象。 而`ServiceMethod`的构造函数如下: 1234567891011121314ServiceMethod(Builder&lt;T&gt; builder) &#123; this.callFactory = builder.retrofit.callFactory(); this.callAdapter = builder.callAdapter; this.baseUrl = builder.retrofit.baseUrl(); this.responseConverter = builder.responseConverter; this.httpMethod = builder.httpMethod; this.relativeUrl = builder.relativeUrl; this.headers = builder.headers; this.contentType = builder.contentType; this.hasBody = builder.hasBody; this.isFormEncoded = builder.isFormEncoded; this.isMultipart = builder.isMultipart; this.parameterHandlers = builder.parameterHandlers; &#125; 看到吗？ 这一部分我们应该都稍微有点印象，因为在上一篇文章介绍使用方法的时候，基本会用到这里。 至于这里的CallAdapter、ResponseConverter、Headers、ParamterHandlers等这里就不分析了，最后我们再简单介绍下。 创建OkHttpCall 接下来会创建OkHttpCall，而OkHttpCall是Call的子类，那Call是什么鬼？ 它是具体的网络请求类。 文档中对Call类的介绍如下: 123456789101112131415161718/** * An invocation of a Retrofit method that sends a request to a webserver and returns a response. * Each call yields its own HTTP request and response pair. Use &#123;@link #clone&#125; to make multiple * calls with the same parameters to the same webserver; this may be used to implement polling or * to retry a failed call. * * &lt;p&gt;Calls may be executed synchronously with &#123;@link #execute&#125;, or asynchronously with &#123;@link * #enqueue&#125;. In either case the call can be canceled at any time with &#123;@link #cancel&#125;. A call that * is busy writing its request or reading its response may receive a &#123;@link IOException&#125;; this is * working as designed. * * @param &lt;T&gt; Successful response body type. */public interface Call&lt;T&gt; extends Cloneable &#123; // 这里我特地把这句话放上，Call集成了Cloneable接口。 // 每一个 call 对象实例只能被用一次，所以说 request 和 response 都是一一对应的。你其实可以通过 Clone 方法来创建一个一模一样的实例，这个开销是很小的。比如说：你可以在每次决定发请求前 clone 一个之前的实例。 ....&#125; `Retrofit`底层默认使用`OkHttp`，所以当然要创建`OkHttpCall`了。 - `serviceMethod.callAdapter.adapt(okHttpCall)` 这个`CallApdater`是什么鬼？ 12345/** * Adapts a &#123;@link Call&#125; into the type of &#123;@code T&#125;. Instances are created by &#123;@linkplain Factory a * factory&#125; which is &#123;@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed&#125; into * the &#123;@link Retrofit&#125; instance. */ 可以很简单的看出来这是一个结果类型转换的类。就是`Call`的适配器，作用就是创建/转换`Call`对象，把`Call`转换成预期的格式。`CallAdatper`创建是通过`CallAdapter.factory`工厂类进行的。`DefaultCallAdapter`为`Retrofit2`自带默认`Call`转换器，用来生成`OKHTTP`的`call`请求调用。 而它里面的`adapt()`方法的作用呢？ 123456789101112131415161718/** * Returns an instance of &#123;@code T&#125; which delegates to &#123;@code call&#125;. * &lt;p&gt; * For example, given an instance for a hypothetical utility, &#123;@code Async&#125;, this instance would * return a new &#123;@code Async&lt;R&gt;&#125; which invoked &#123;@code call&#125; when run. * &lt;pre&gt;&lt;code&gt; * &amp;#64;Override * public &amp;lt;R&amp;gt; Async&amp;lt;R&amp;gt; adapt(final Call&amp;lt;R&amp;gt; call) &#123; * return Async.create(new Callable&amp;lt;Response&amp;lt;R&amp;gt;&amp;gt;() &#123; * &amp;#64;Override * public Response&amp;lt;R&amp;gt; call() throws Exception &#123; * return call.execute(); * &#125; * &#125;); * &#125; * &lt;/code&gt;&lt;/pre&gt; */ &lt;R&gt; T adapt(Call&lt;R&gt; call); 所以分析到这里我们基本明白了`retrofit.create()`方法的作用，就是将请求接口的服务类转换成`Call`，然后将`Call`的结果转换成实体类。 3. 调用方法，得到Call对象1Call&lt;List&lt;Repo&gt;&gt; call = gitHubService.listRepos(\"CharonChui\"); 这个就不分析了，就是在ServiceMethod中返回的Call。 4. 调用Call.enqueue()在上面分析了，这个Call其实是OkHttpCall，那我们来看一下OkHttpCall.enqueue()方法的实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException(\"callback == null\"); okhttp3.Call call; Throwable failure; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already executed.\"); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; try &#123; // 调用createRawCall()方法创建Call call = rawCall = createRawCall(); &#125; catch (Throwable t) &#123; failure = creationFailure = t; &#125; &#125; &#125; if (failure != null) &#123; callback.onFailure(this, failure); return; &#125; if (canceled) &#123; call.cancel(); &#125; // 把请求任务加入到okhttp的请求队列中，执行网络请求，注意这里的Call是okhttp3.Call call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) throws IOException &#123; Response&lt;T&gt; response; try &#123; // 解析结果，该方法内部会将OkHttp中Request的执行结果转换成对应的Java对象。 response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; callSuccess(response); &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callFailure(Throwable e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callSuccess(Response&lt;T&gt; response) &#123; try &#123; callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;); &#125; 上面的部分也主要分为三部分: 创建Call 执行网络请求 解析结果 第一部分：创建Call我们分别进行分析，首先是createRawCall()方法的实现:12345678910private okhttp3.Call createRawCall() throws IOException &#123; // ServiceMethod.toRequest()方法的作用是将ServiceMethod中的网络请求相关的数据转换成一个OkHttp的网络请求所需要的Request对象。因为之前分析过所有Retrofit解析的网络请求相关的数据都是在ServiceMethod中 Request request = serviceMethod.toRequest(args); // 调用Factory.newCall方法 okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) &#123; throw new NullPointerException(\"Call.Factory returned null.\"); &#125; return call;&#125; 然后看一下Factory.newCall()方法:123interface Factory &#123; Call newCall(Request request); &#125; 它的实现类是OkHttpClient类中的newCall()方法，并且创建RealCall对象:123@Override public Call newCall(Request request) &#123; return new RealCall(this, request); &#125; 第二部分：执行网络请求这一部分是在call.enqueue()方法中执行的，上面我们分析了创建的Call最终是RealCall类，所以这里直接到看RealCall.enqueue()方法: 12345678910111213@Override public void enqueue(Callback responseCallback) &#123; enqueue(responseCallback, false); &#125; void enqueue(Callback responseCallback, boolean forWebSocket) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; // 调用OkHttpClient中的Dispatcher中的enqueue方法 client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket)); &#125; 我们接着看client.dispatcher().enqueue()方法: 123456789101112131415161718192021222324252627synchronized void enqueue(AsyncCall call) &#123; // maxRequests的个数是64; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); // 线程池执行 executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125; &#125;``` 而这个参数`AsyncCall`是什么鬼？ 它是`RealCall`的内部类，它里面的`execute()`方法是如何实现的？ 只要找到该方法的实现就算是完成了。 首先看一下`AsyncCall`的声明和构造: ```javafinal class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; private final boolean forWebSocket; private AsyncCall(Callback responseCallback, boolean forWebSocket) &#123; super(\"OkHttp %s\", redactedUrl().toString()); this.responseCallback = responseCallback; this.forWebSocket = forWebSocket; &#125; ... &#125; NamedRunnable是Runnable的实现类。我们看一下它的execute()方法:123456789101112131415161718192021222324@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; // 获取请求结果 Response response = getResponseWithInterceptorChain(forWebSocket); if (canceled) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); &#125; else &#123; signalledCallback = true; // 将响应结果设置给之前构造函数传递回来的回调 responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 接着看一下RealCall.getResponseWithInterceptorChain(): 12345678910111213141516171819202122232425262728293031323334353637383940414243private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException &#123; Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket); return chain.proceed(originalRequest); &#125; class ApplicationInterceptorChain implements Interceptor.Chain &#123; private final int index; private final Request request; private final boolean forWebSocket; ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) &#123; this.index = index; this.request = request; this.forWebSocket = forWebSocket; &#125; @Override public Connection connection() &#123; return null; &#125; @Override public Request request() &#123; return request; &#125; @Override public Response proceed(Request request) throws IOException &#123; // If there's another interceptor in the chain, call that. if (index &lt; client.interceptors().size()) &#123; Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket); Interceptor interceptor = client.interceptors().get(index); Response interceptedResponse = interceptor.intercept(chain); if (interceptedResponse == null) &#123; throw new NullPointerException(\"application interceptor \" + interceptor + \" returned null\"); &#125; return interceptedResponse; &#125; // No more interceptors. Do HTTP. return getResponse(request, forWebSocket); &#125; &#125; 又会调用getResponse()方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * Performs the request and returns the response. May return null if this call was canceled. */ Response getResponse(Request request, boolean forWebSocket) throws IOException &#123; // Copy body metadata to the appropriate request headers. RequestBody body = request.body(); if (body != null) &#123; Request.Builder requestBuilder = request.newBuilder(); MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(\"Content-Type\", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(\"Content-Length\", Long.toString(contentLength)); requestBuilder.removeHeader(\"Transfer-Encoding\"); &#125; else &#123; requestBuilder.header(\"Transfer-Encoding\", \"chunked\"); requestBuilder.removeHeader(\"Content-Length\"); &#125; request = requestBuilder.build(); &#125; // Create the initial HTTP engine. Retries and redirects need new engine for each attempt. engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null); int followUpCount = 0; while (true) &#123; if (canceled) &#123; engine.releaseStreamAllocation(); throw new IOException(\"Canceled\"); &#125; boolean releaseConnection = true; try &#123; engine.sendRequest(); engine.readResponse(); releaseConnection = false; &#125; catch (RequestException e) &#123; // The attempt to interpret the request failed. Give up. throw e.getCause(); &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null); if (retryEngine != null) &#123; releaseConnection = false; engine = retryEngine; continue; &#125; // Give up; recovery is not possible. throw e.getLastConnectException(); &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. HttpEngine retryEngine = engine.recover(e, false, null); if (retryEngine != null) &#123; releaseConnection = false; engine = retryEngine; continue; &#125; // Give up; recovery is not possible. throw e; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. if (releaseConnection) &#123; StreamAllocation streamAllocation = engine.close(); streamAllocation.release(); &#125; &#125; Response response = engine.getResponse(); Request followUp = engine.followUpRequest(); if (followUp == null) &#123; if (!forWebSocket) &#123; engine.releaseStreamAllocation(); &#125; return response; &#125; StreamAllocation streamAllocation = engine.close(); if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount); &#125; if (!engine.sameConnection(followUp.url())) &#123; streamAllocation.release(); streamAllocation = null; &#125; else if (streamAllocation.stream() != null) &#123; throw new IllegalStateException(\"Closing the body of \" + response + \" didn't close its backing stream. Bad interceptor?\"); &#125; request = followUp; engine = new HttpEngine(client, request, false, false, forWebSocket, streamAllocation, null, response); &#125; &#125; 完了没有？ 完了…. 上面只是简单的分析了下大体的调用流程和主要的类，但是好像并没有什么乱用，因为没有具体的去分析里面各部分的实现，如果都分析下来内容太多了。这里就不仔细看了，大体总结一下。 通过上面的分析，最终的网络请求是在OkHttp的Call中去执行，也就是说Retrofit其实是将一个Java接口通过注解等方式来解析参数等然后转换成一个请求交给OkHttp去执行，然后将执行结果进行解析转换暴露给上层调用者。而这一切是如何实现的呢？Retrofit非常巧妙的用注解来描述一个HTTP请求，将一个HTTP请求抽象成一个Java接口，然后用了动态代理的方式，动态的将这个接口的注解转换成一个HTTP请求，然后再将这个Http请求交给OkHttp执行。 动态代理用的太妙，而它的过程中也使用了大量的工厂模式，这里就不分析了。 参考: simple-http-retrofit-2 Retrofit API 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Retrofit详解(上)","date":"2014-10-31T17:11:00.000Z","path":"2014/11/01/Retrofit详解(上)/","text":"Retrofit详解(上)之前写过一篇文章volley-retrofit-okhttp之我们该如何选择网路框架来分析Volley与Retrofit之间的区别。之前一直用Volley比较多。但是随着Rx系列的走红，目前越来越多的项目使用RxJava+Retrofit这一黄金组合。而且Retrofit使用注解的方式比较方便以及2.x版本的提示让Retrofit更加完善，今天简单的来学习记录下。 有关更多Volley的知识请查看Volley源码分析 有关注解更多的知识请查看注解使用 有关更多[RxJava]的介绍请查看Rx详解系列.md) 简介Retrofit A type-safe HTTP client for Android and Java type-safe是什么鬼？类型安全代码指访问被授权可以访问的内存位置。例如，类型安全代码不能从其他对象的私有字段读取值。它只从定义完善的允许方式访问类型才能读取。 使用Gradle中集成: 12345678compile 'com.squareup.retrofit2:retrofit:2.1.0'``` `Retrofit 2`底层默认使用自家兄弟`OKHttp`作为网络层,并且在它上面进行构建。所以不需要在想`1.x`版本那样在项目中显式的定义`OkHttp`依赖。所以`Retrofit`与`OkHttp`的关系是后者专注与网络请求的高效优化，而前者专注于接口的封装和调用管理等。 ![image](https://github.com/CharonChui/Pictures/blob/master/retrofit_okhttp_relation.jpg?raw=true)当然你还需要在清单文件中添加网络请求的权限: 1234我们就以`Github`获取个人仓库的`api`来进行举例测试: ```javahttps://api.github.com/users/&#123;user&#125;/repos Retrofit会将你的api封装成Java接口 1234public interface GitHubService &#123; @GET(\"users/&#123;user&#125;/repos\") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);&#125; Retrofit类会生成一个GitHubService接口的实现类: 12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .build();GitHubService service = retrofit.create(GitHubService.class); 从创建的GithubService类返回的每个Call对象调用后都可以创建一个同步或异步的网络请求: 1Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"CharonChui\"); 上面返回的Call其实并不是真正的数据结果，它更像一条指令，你需要执行它: 12345678910111213141516// 同步调用List&lt;Repo&gt; data = repos.execute(); // 异步调用repos.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123; @Override public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) &#123; List&lt;Repo&gt; data = response.body(); Log.i(\"@@@\", \"data size : \" + (data == null ? \"null\" : data.size() + \"\")); &#125; @Override public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) &#123; &#125;&#125;); 那如何取消请求呢？ 1repos.cancel(); 上面这一部分代码，你要是拷贝运行后是运行不了的。当然了，因为木有Repo对象。但是添加Repo对象也是运行不了的。会报错。 123456789101112131415161718192021222324252627282930313233Process: com.charon.retrofitdemo, PID: 7229java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.charon.retrofitdemo/com.charon.retrofitdemo.MainActivity&#125;: java.lang.IllegalArgumentException: Unable to create converter for java.util.List&lt;com.charon.retrofitdemo.Repo&gt; for method GitHubService.listRepos at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2281) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2331) at android.app.ActivityThread.handleRelaunchActivity(ActivityThread.java:3974) at android.app.ActivityThread.access$1100(ActivityThread.java:143) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1250) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:136) at android.app.ActivityThread.main(ActivityThread.java:5291) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:515) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:849) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:665) at dalvik.system.NativeStart.main(Native Method)Caused by: java.lang.IllegalArgumentException: Unable to create converter for java.util.List&lt;com.charon.retrofitdemo.Repo&gt; for method GitHubService.listRepos at retrofit2.ServiceMethod$Builder.methodError(ServiceMethod.java:720) at retrofit2.ServiceMethod$Builder.createResponseConverter(ServiceMethod.java:706) at retrofit2.ServiceMethod$Builder.build(ServiceMethod.java:167) at retrofit2.Retrofit.loadServiceMethod(Retrofit.java:166) at retrofit2.Retrofit$1.invoke(Retrofit.java:145) at $Proxy0.listRepos(Native Method) at com.charon.retrofitdemo.MainActivity$override.onCreate(MainActivity.java:29) at com.charon.retrofitdemo.MainActivity$override.access$dispatch(MainActivity.java) at com.charon.retrofitdemo.MainActivity.onCreate(MainActivity.java:0) at android.app.Activity.performCreate(Activity.java:5304) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1090) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2245) ... 12 moreCaused by: java.lang.IllegalArgumentException: Could not locate ResponseBody converter for java.util.List&lt;com.charon.retrofitdemo.Repo&gt;. Tried: 这是什么鬼?难道官方给的示例代码有问题？ 从log上面我们能看出来是返回的数据结构不匹配导致的，返回的是ResponseBody的转换器无法转换为List&lt;Repo&gt;。 Retrofit是一个将API接口转换成回调对象的类，默认情况下Retrofit会根绝平台提供一些默认的配置，但是它是支持配置的。 Converters(解析数据)默认情况下，Retrofit只能将HTTP响应体反序列化为OkHttp的ResponseBody类型。并且通过@Body也只能接受RequestBody类型。 可以通过添加转换器来支持其他类型。它提供了6中类似的序列化类库来方便进行使用: Gson: com.squareup.retrofit2:converter-gson Jackson: com.squareup.retrofit2:converter-jackson Moshi: com.squareup.retrofit2:converter-moshi Protobuf: com.squareup.retrofit2:converter-protobuf Wire: com.squareup.retrofit2:converter-wire Simple XML: com.squareup.retrofit2:converter-simplexml Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars 我们这里通过Gson为例，讲解一下如何使用，首先需要在gradle文件中配置对应的支持模块。 12compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.squareup.retrofit2:converter-gson:2.1.0' 下面是一个通过使用GsonConverterFactory类来指定GitHubService接口使用Gson来解析结果的配置。 123456Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com\") .addConverterFactory(GsonConverterFactory.create()) .build();GitHubService service = retrofit.create(GitHubService.class); 经过这些改造，就可以了，贴一下完整的代码:1234567891011121314151617181920212223242526272829303132333435public interface GitHubService &#123; @GET(\"users/&#123;user&#125;/repos\") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);&#125;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHubService service = retrofit.create(GitHubService.class); Call&lt;List&lt;Repo&gt;&gt; call= service.listRepos(\"CharonChui\"); call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123; @Override public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) &#123; List&lt;Repo&gt; body = response.body(); Log.i(\"@@@\", \"call \" + body.size()); &#125; @Override public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) &#123; &#125; &#125;); &#125;&#125; 运行上面的代码,log会打印出12-14 14:43:38.900 21509-21509/com.charon.retrofitdemo I/@@@: call 26 到这里，我们入门的Hello World就完成了。 Retrofit支持的协议包括GET/POST/PUT/DELETE/HEAD/PATCH，当然你也可以直接用HTTP 来自定义请求。这些协议均以注解的形式进行配置，比如我们已经见过GET的用法. 我们发现在Retrofit创建的时候需要传入一个baseUrl(https://api.github.com/)，在GitHubService中会通过注解设置@GET(&quot;users/{user}/repos&quot;)，请求的完整Url就是通过baseUrl与注解的value也就是path路径结合起来组成。虽然提供了多种规则，但是统一使用下面这一种是最好的。123通过注解的value指定的是相对路径，baseUrl是目录形式：path = \"users/CharonChui/repos\"，baseUrl = \"https://api.github.com/\"Url = \"https://api.github.com/users/CharonChui/repos\" 上面介绍的例子中使用的是@Path。 @Query及@QueryMap假设我们有一个分页查询的功能:12GET(\"/list\")Call&lt;ResponseBody&gt; list(@Query(\"page\") int page); 这就相当于https://api.github.com/list?page=1这种。Query其实就是Url中?后面的k-v。而QueryMap就是多个查询条件。 @Field及@FieldMap用Post的场景相对比较多，绝大多数的服务端接口要做加密、校验等。所以使用Post提交表单的场景就会很多。 123@FormUrlEncoded@POST(\"user/edit\")Call&lt;User&gt; updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last); 当然FieldMap就是多个的版本了。 @Part及@PartMap上传文件时使用。12345public interface FileUploadService &#123; @Multipart@PUT(\"user/photo\")Call&lt;User&gt; updateUser(@Part(\"photo\") RequestBody photo, @Part(\"description\") RequestBody description);&#125; @Headers可以通过@Headers来设置静态的请求头 123456@Headers(&#123; \"Accept: application/vnd.github.v3.full+json\", \"User-Agent: Retrofit-Sample-App\"&#125;)@GET(\"users/&#123;username&#125;\")Call&lt;User&gt; getUser(@Path(\"username\") String username); 请求头信息可以通过@Header注解来动态更新 12@GET(\"user\")Call&lt;User&gt; getUser(@Header(\"Authorization\") String authorization) 如果传的值是null，该请求头将会被忽略，否则将会使用该值得toString。 RxJava+RetrofitRetrofit如何与RxJava结合使用呢？ 添加依赖 1234567compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.squareup.retrofit2:converter-gson:2.1.0'// 支持gsoncompile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'// 支持rxjava// rxjava partcompile 'io.reactivex:rxandroid:1.2.1'compile 'io.reactivex:rxjava:1.2.3' 修改Retrofit的配置，让其支持RxJava 12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 支持RxJava .build(); 修改GitHubService，将返回值改为Observable，而不是Call。 1234public interface GitHubService &#123; @GET(\"users/&#123;user&#125;/repos\") Observable&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);&#125; 执行部分 12345678910111213141516171819202122GitHubService service = retrofit.create(GitHubService.class);service.listRepos(\"CharonChui\") .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Repo&gt;&gt;() &#123; @Override public void onCompleted() &#123; Log.i(\"@@@\", \"onCompleted\"); &#125; @Override public void onError(Throwable e) &#123; Log.i(\"@@@\", \"onError : \" + e.toString()); &#125; @Override public void onNext(List&lt;Repo&gt; repos) &#123; Log.i(\"@@@\", \"onNext : \" + repos.size()); Toast.makeText(MainActivity.this, \"size : \" + repos.size(), Toast.LENGTH_SHORT).show(); &#125; &#125;); RxJava+Retrofit形式的时候，Retrofit把请求封装进Observable在请求结束后调用 onNext()或在请求失败后调用onError()。 Proguard配置如果项目中使用了Proguard，你需要添加如下配置:12345678910# Platform calls Class.forName on types which do not exist on Android to determine platform.-dontnote retrofit2.Platform# Platform used when running on RoboVM on iOS. Will not be used at runtime.-dontnote retrofit2.Platform$IOS$MainThreadExecutor# Platform used when running on Java 8 VMs. Will not be used at runtime.-dontwarn retrofit2.Platform$Java8# Retain generic type information for use by reflection by converters and adapters.-keepattributes Signature# Retain declared checked exceptions for use by a Proxy instance.-keepattributes Exceptions 邮箱 ：itgoyo@gmail.com Good Luck!","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]}]